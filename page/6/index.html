<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://blog.skuaka.cn/page/6/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Job/">Job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Op-System/">Op-System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openSSL/">openSSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postman/">postman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/steamcmd/">steamcmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travis/">travis</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-C-C++/Mess/C++多线程多路归并排序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/09/C-C++/Mess/C++多线程多路归并排序/" class="article-date">
      <time datetime="2019-04-09T07:58:43.000Z" itemprop="datePublished">2019-04-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/C-C++/Mess/C++多线程多路归并排序/">C++多线程多路归并排序函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-多线程多路归并排序函数"><a href="#C-多线程多路归并排序函数" class="headerlink" title="C++多线程多路归并排序函数"></a>C++多线程多路归并排序函数</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>各个线程对分配给它的数据分块进行快速排序(<code>std::sort</code>)。</li>
<li>主线程排序完分配给自己的数据分块后，需要等待(<code>std::future</code>,<code>std::promise</code>)各个线程完成。</li>
<li>主线程多路归并排序(需要自己实现，标准库只有二路归并)。</li>
</ul>
<h4 id="实现注意"><a href="#实现注意" class="headerlink" title="实现注意"></a>实现注意</h4><ul>
<li>本实现大量使用C++11特性。</li>
<li>c语言的qsort内部用到了静态变量，所以不是线程安全的。可以通过在主线程使用一次qsort解决。具体自行搜索或看<a href="https://blog.csdn.net/itegel84/article/details/5871491" target="_blank" rel="noopener">这篇</a>。而这里使用std::sort则没有这个问题。</li>
</ul>
<h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><ul>
<li>只支持数值类型，读者可自行扩展。</li>
<li>需要支持随机存储</li>
</ul>
<h4 id="数据分块大小"><a href="#数据分块大小" class="headerlink" title="数据分块大小"></a>数据分块大小</h4><p>设数据长度(data_len)为 D，新线程数量(thread_num)为 T，一个分块大小(chunk_size)为 C，最后一个分块的大小(last_chunk_size)为 LC。</p>
<p>直观地，如果工作线程数量可以整除数据长度，那么商就是块大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LC = C = D/(T+1)</span><br></pre></td></tr></table></figure>
<p>如果不能整除的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = D/(T+1)+1</span><br><span class="line">LC ∈ (C-(T+1), C)</span><br></pre></td></tr></table></figure>
<p>因为 T 非常小，所以最后一块的大小差别不大，<strong>本实现就由主线程来处理最后一块</strong>。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li>指向数据首地址的指针</li>
<li>数据长度</li>
<li>指定需要创建的新线程数量</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multi_threaded_sort.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MULTI_THREADED_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTI_THREADED_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IntegerType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_threaded_sort</span><span class="params">(IntegerType* in_data, <span class="keyword">size_t</span> data_len, <span class="keyword">size_t</span> thread_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// compile time type check</span></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral&lt;IntegerType&gt;::value,</span><br><span class="line">                  <span class="string">"Data type must be integer"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// under such conditions, multi-thread makes no sense</span></span><br><span class="line">    <span class="comment">// call std::sort directly</span></span><br><span class="line">    <span class="keyword">if</span>(data_len &lt;= <span class="number">1</span> || thread_num == <span class="number">0</span></span><br><span class="line">       || data_len &lt; (thread_num+<span class="number">1</span>)*(thread_num+<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(in_data, in_data+data_len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* one thread sort one chunk</span></span><br><span class="line"><span class="comment">     * main thread sort the last chunk */</span></span><br><span class="line">    <span class="keyword">size_t</span> chunk_size = data_len/(thread_num+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(data_len%(thread_num+<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ++chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for threads synchronize</span></span><br><span class="line">    <span class="keyword">auto</span> sort_promise = <span class="keyword">new</span> <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt;[thread_num];</span><br><span class="line">    <span class="keyword">auto</span> sort_future = <span class="keyword">new</span> <span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt;[thread_num];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;thread_num; ++i)</span><br><span class="line">        sort_future[i] = sort_promise[i].get_future();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create threads</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;thread_num; ++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">([=]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::sort(in_data + i*chunk_size, in_data + (i+<span class="number">1</span>)*chunk_size);</span></span></span><br><span class="line"><span class="function"><span class="params">            sort_promise[i].set_value();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line">        th.detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the last chunk</span></span><br><span class="line">    <span class="built_in">std</span>::sort(in_data + chunk_size*thread_num, in_data + data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before wait and block, do things not based on data</span></span><br><span class="line">    <span class="keyword">auto</span> out_data = <span class="keyword">new</span> IntegerType[data_len];</span><br><span class="line">    <span class="keyword">auto</span> index = <span class="keyword">new</span> <span class="keyword">size_t</span>[thread_num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;thread_num + <span class="number">1</span>; ++i)</span><br><span class="line">        index[i] = i * chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for all threads</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;thread_num; ++i)</span><br><span class="line">        sort_future[i].wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] sort_future;</span><br><span class="line">    <span class="keyword">delete</span>[] sort_promise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do merge sort</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; data_len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        IntegerType min_index;</span><br><span class="line">        IntegerType min_num = <span class="built_in">std</span>::numeric_limits&lt;IntegerType&gt;::max();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse every chunk and find the minimum</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt;thread_num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((index[j] &lt; (j+<span class="number">1</span>)*chunk_size)</span><br><span class="line">               &amp;&amp; (in_data[index[j]] &lt; min_num))</span><br><span class="line">            &#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">                min_num = in_data[index[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index[thread_num] &lt; data_len</span><br><span class="line">           &amp;&amp; (in_data[index[thread_num]] &lt; min_num))</span><br><span class="line">        &#123;</span><br><span class="line">            min_index = thread_num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out_data[i] = in_data[index[min_index]];</span><br><span class="line">        index[min_index]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(out_data, out_data + data_len, in_data);</span><br><span class="line">    <span class="keyword">delete</span>[] out_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MULTI_THREADED_SORT_H</span></span></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"multi_threaded_sort.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"this example check the correctness:"</span>;</span><br><span class="line">        <span class="keyword">short</span> data[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">93</span>, <span class="number">43</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">43</span>&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> N = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(<span class="keyword">short</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ninput "</span> &lt;&lt; N &lt;&lt; <span class="string">" data: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        multi_threaded_sort(data, N, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\tsort with 2 threads: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">        random_shuffle(data, data + N);<span class="comment">// before c++17</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nafter shuffle: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        multi_threaded_sort(data, N, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\tsort with 3 threads: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> N = <span class="number">654321</span>;   <span class="comment">// numbers to generate</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> T = <span class="number">6</span>;         <span class="comment">// threads to test</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\nthis example check the efficiency:\n"</span></span><br><span class="line">             &lt;&lt; <span class="string">"randomly generate "</span> &lt;&lt; N</span><br><span class="line">             &lt;&lt; <span class="string">" natural number and sort them...\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> random_data[T][N];</span><br><span class="line">        <span class="built_in">std</span>::random_device rd;</span><br><span class="line">        <span class="built_in">std</span>::default_random_engine rng&#123;rd()&#125;;</span><br><span class="line">        <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">short</span>&gt; dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            random_data[<span class="number">0</span>][i] = dis(rng);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; T; ++i)</span><br><span class="line">            copy(random_data[<span class="number">0</span>], random_data[<span class="number">0</span>] + N, random_data[i]);</span><br><span class="line"></span><br><span class="line">        chrono::time_point&lt;chrono::high_resolution_clock&gt; <span class="keyword">start_t</span>[T], <span class="keyword">end_t</span>[T];</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed[T];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">            <span class="keyword">start_t</span>[i] = chrono::high_resolution_clock::now();</span><br><span class="line">            <span class="keyword">if</span> (i)</span><br><span class="line">                multi_threaded_sort(random_data[<span class="number">1</span>], N, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sort(random_data[<span class="number">0</span>], random_data[<span class="number">0</span>] + N);</span><br><span class="line">            <span class="keyword">end_t</span>[i] = chrono::high_resolution_clock::now();</span><br><span class="line">            elapsed[i] = <span class="keyword">end_t</span>[i] - <span class="keyword">start_t</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Use std::sort() cost: "</span> &lt;&lt; elapsed[<span class="number">0</span>].count() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; T; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Add "</span> &lt;&lt; i &lt;&lt; <span class="string">" threads   cost: "</span> &lt;&lt; elapsed[i].count() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this example check the correctness:</span><br><span class="line">input 10 data: 2 5 5 3 93 43 3 0 -3 43 </span><br><span class="line">	sort with 2 threads: -3 0 2 3 3 5 5 43 43 93 </span><br><span class="line">after shuffle: 5 -3 3 5 43 43 3 0 2 93 </span><br><span class="line">	sort with 3 threads: -3 0 2 3 3 5 5 43 43 93 </span><br><span class="line"></span><br><span class="line">this example check the efficiency:</span><br><span class="line">randomly generate 654321 natural number and sort them...</span><br><span class="line">Use std::sort() cost: 36.1254 ms</span><br><span class="line">Add 1 threads   cost: 25.5484 ms</span><br><span class="line">Add 2 threads   cost: 9.9246 ms</span><br><span class="line">Add 3 threads   cost: 10.2634 ms</span><br><span class="line">Add 4 threads   cost: 11.2967 ms</span><br><span class="line">Add 5 threads   cost: 14.7214 ms</span><br></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul>
<li><p>因为线程本身创建和销毁需要时间，所以在数据量较少的情况下使用多线程肯定是不值得的，反而会变慢。</p>
</li>
<li><p>因为CPU核数是有限的，所以可以并发执行线程数肯定不会很高，所以创建过多线程也是没有用的，线程数达到某个数量(一般很小)后排序速度随线程数量增加而缓慢下降。</p>
</li>
</ul>
<p>对于上面两点，读者可以修改测试代码的 N 和 T 自己进行测试。</p>
<p>笔者水平有限，如有错误，还望指出。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/Mess/new和malloc区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/08/C-C++/Mess/new和malloc区别/" class="article-date">
      <time datetime="2019-04-08T11:28:56.000Z" itemprop="datePublished">2019-04-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/C-C++/Mess/new和malloc区别/">new和malloc区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>来自：<a href="http://www.cnblogs.com/QG-whz/p/5140930.html" target="_blank" rel="noopener">http://www.cnblogs.com/QG-whz/p/5140930.html</a></p>
<h3 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h3><table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">new/delete</th>
<th style="text-align:center">malloc/free</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分配内存的位置</td>
<td style="text-align:center">自由存储区</td>
<td style="text-align:center">堆</td>
</tr>
<tr>
<td style="text-align:center">内存分配成功的返回值</td>
<td style="text-align:center">完整类型指针</td>
<td style="text-align:center">void*</td>
</tr>
<tr>
<td style="text-align:center">内存分配失败的返回值</td>
<td style="text-align:center">默认抛出异常</td>
<td style="text-align:center">返回NULL</td>
</tr>
<tr>
<td style="text-align:center">分配内存的大小</td>
<td style="text-align:center">由编译器根据类型计算得出</td>
<td style="text-align:center">必须显式指定字节数</td>
</tr>
<tr>
<td style="text-align:center">处理数组</td>
<td style="text-align:center">有处理数组的new版本new[]</td>
<td style="text-align:center">需要用户计算数组的大小后进行内存分配</td>
</tr>
<tr>
<td style="text-align:center">已分配内存的扩充</td>
<td style="text-align:center">无法直观地处理</td>
<td style="text-align:center">使用realloc简单完成</td>
</tr>
<tr>
<td style="text-align:center">函数重载</td>
<td style="text-align:center">允许</td>
<td style="text-align:center">不允许</td>
</tr>
<tr>
<td style="text-align:center">构造函数与析构函数</td>
<td style="text-align:center">调用</td>
<td style="text-align:center">不调用</td>
</tr>
</tbody>
</table>
<h4 id="自由存储区和堆"><a href="#自由存储区和堆" class="headerlink" title="自由存储区和堆"></a>自由存储区和堆</h4><p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。</p>
<p>基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以<strong>通过重载操作符</strong>，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/Concept-gcc/C++命名规范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/07/C-C++/Concept-gcc/C++命名规范/" class="article-date">
      <time datetime="2019-04-07T08:37:00.000Z" itemprop="datePublished">2019-04-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/07/C-C++/Concept-gcc/C++命名规范/">C++命名规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-命名规范"><a href="#C-命名规范" class="headerlink" title="C++命名规范"></a>C++命名规范</h2><p>源自：<a href="https://www.cnblogs.com/heyonggang/p/3362873.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyonggang/p/3362873.html</a></p>
<h3 id="整体原则"><a href="#整体原则" class="headerlink" title="整体原则"></a>整体原则</h3><p>在引入细节之前，先说明一下命名规范的整体原则：</p>
<table>
<thead>
<tr>
<th>同一性</th>
<th>在编写一个子模块或派生类的时候，要遵循其基类或整体模块的命名风格，保持命名风格在整个模块中的同一性。</th>
</tr>
</thead>
<tbody>
<tr>
<td>标识符组成</td>
<td>标识符采用英文单词或其组合，应当直观且可以拼读，可望文知意，用词应当准确。</td>
</tr>
<tr>
<td>最小化长度 &amp;&amp; 最大化信息量原则</td>
<td>在保持一个标识符意思明确的同时，应当尽量缩短其长度。</td>
</tr>
<tr>
<td>避免过于相似</td>
<td>不要出现仅靠大小写区分的相似的标识符，例如“i”与“I”，“function”与“Function”等等。</td>
</tr>
<tr>
<td>避免在不同级别的作用域中重名</td>
<td>程序中不要出现名字完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但容易使人误解。</td>
</tr>
<tr>
<td>正确命名具有互斥意义的标识符</td>
<td>用正确的反义词组命名具有互斥意义的标识符，如：”nMinValue”和”nMaxValue”，”GetName()” 和 “SetName()” ….</td>
</tr>
<tr>
<td>避免名字中出现数字编号</td>
<td>尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。这是为了防止程序员偷懒，不肯为命名动脑筋而导致产生无意义的名字（因为用数字编号最省事）。</td>
</tr>
</tbody>
</table>
<h3 id="类-结构"><a href="#类-结构" class="headerlink" title="类/结构"></a>类/结构</h3><p>除了异常类等个别情况（不希望用户把该类看作一个普通的、正常的类之情况）外，C++类/结构<br>的命名应该遵循以下准则：</p>
<table>
<thead>
<tr>
<th>C++类/结构的命名</th>
<th>类的名称都要以大写字母“C”开头，后跟一个或多个单词。为便于界定，每个单词的首字母要大写。</th>
</tr>
</thead>
<tbody>
<tr>
<td>推荐的组成形式</td>
<td>类的命名推荐用”名词”或”形容词＋名词”的形式，例如：”CAnalyzer”, “CFastVector” ….</td>
</tr>
<tr>
<td>传统C结构体的命名</td>
<td>传统C结构体的名称全部由大写字母组成，单词间使用下划线界定，例如：”SERVICE_STATUS”, “DRIVER_INFO” ….</td>
</tr>
</tbody>
</table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table>
<thead>
<tr>
<th>函数的命名</th>
<th>函数的名称由一个或多个单词组成。为便于界定，每个单词的首字母要大写。</th>
</tr>
</thead>
<tbody>
<tr>
<td>推荐的组成形式</td>
<td>函数名应当使用”动词”或者”动词＋名词”（动宾词组）的形式。例如：”GetName()”, “SetValue()”, “Erase()”, “Reserve()” ….</td>
</tr>
<tr>
<td>保护成员函数</td>
<td>保护成员函数的开头应当加上一个下划线以示区别，例如：”<code>_SetState()</code>“ ….</td>
</tr>
<tr>
<td>私有成员函数</td>
<td>类似地，私有成员函数的开头应当加上两个下划线，例如：”<code>__DestroyImp()</code>“ ….</td>
</tr>
<tr>
<td>虚函数</td>
<td>虚函数习惯以“Do”开头，如：”DoRefresh()”, “_DoEncryption()” ….</td>
</tr>
<tr>
<td>回调和事件处理函数</td>
<td>回调和事件处理函数习惯以单词“On”开头。例如：”_OnTimer()”, “OnExit()” ….</td>
</tr>
</tbody>
</table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名由<strong><em>作用域前缀＋类型前缀＋一个或多个单词</em></strong>组成。为便于界定，每个单词的首字母要大写。</p>
<p>对于某些用途简单明了的局部变量，也可以使用简化的方式，如：i, j, k, x, y, z ….</p>
<p><strong>作用域前缀</strong></p>
<table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>无</em></td>
<td>局部变量</td>
</tr>
<tr>
<td>m_</td>
<td>类的成员变量（member）</td>
</tr>
<tr>
<td>sm_</td>
<td>类的静态成员变量（static member）</td>
</tr>
<tr>
<td>s_</td>
<td>静态变量（static）</td>
</tr>
<tr>
<td>g_</td>
<td>外部全局变量（global）</td>
</tr>
<tr>
<td>sg_</td>
<td>静态全局变量（static global）</td>
</tr>
<tr>
<td>gg_</td>
<td>进程间共享的共享数据段全局变量（global global）</td>
</tr>
</tbody>
</table>
<p><strong>类型前缀</strong></p>
<p>类型前缀可以组合使用，例如”gc”表示字符数组，”ppn”表示指向整型的指针的指针等等。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>整型和位域变量（number）</td>
</tr>
<tr>
<td>e</td>
<td>枚举型变量（enumeration）</td>
</tr>
<tr>
<td>c</td>
<td>字符型变量（char）</td>
</tr>
<tr>
<td>b</td>
<td>布尔型变量（bool）</td>
</tr>
<tr>
<td>f</td>
<td>浮点型变量（float）</td>
</tr>
<tr>
<td>p</td>
<td>指针型变量和迭代子（pointer）</td>
</tr>
<tr>
<td>pfn</td>
<td>特别针对指向函数的指针变量和函数对象指针（pointer of function）</td>
</tr>
<tr>
<td>g</td>
<td>数组（grid）</td>
</tr>
<tr>
<td>i</td>
<td>类的实例（instance）<br>对于经常用到的类，也可以定义一些专门的前缀，<br>如：std::string类的前缀可以定义为”st”，std::vector类的前缀可以定义为”v”。</td>
</tr>
</tbody>
</table>
<p><strong>推荐的组成形式</strong></p>
<p>变量的名字应当使用”名词”或者”形容词＋名词”。例如：”nCode”, “m_nState”，”nMaxWidth” ….</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量名由类型前缀＋全大写字母组成，单词间通过下划线来界定，如：cDELIMITER, nMAX_BUFFER ….</p>
<p>类型前缀的定义与变量命名规则中的相同。</p>
<h3 id="枚举-联合-typedef"><a href="#枚举-联合-typedef" class="headerlink" title="枚举/联合/typedef"></a>枚举/联合/typedef</h3><p>枚举、联合、typedef语句生成的类型名由全大写字母组成，单词间通过下划线来界定，如：FAR_PROC, ERROR_TYPE ….</p>
<h3 id="宏-枚举"><a href="#宏-枚举" class="headerlink" title="宏/枚举"></a>宏/枚举</h3><p>宏和枚举值由全大写字母组成，单词间通过下划线来界定，如：ERROR_UNKNOWN, OP_STOP ….</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Http/https与ssl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/06/Network/Http/https与ssl/" class="article-date">
      <time datetime="2019-04-06T12:39:23.000Z" itemprop="datePublished">2019-04-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/06/Network/Http/https与ssl/">https 与 ssl</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL，HTTP Secure。</p>
<p>HTTP端口：80，HTTPS端口：443。</p>
<p>在计算机网络上，HTTPS经由超文本传输协议（HTTP）进行通信，但利用SSL/TLS来加密数据包。</p>
<p><strong>HTTP的特点</strong></p>
<ul>
<li><p>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</p>
</li>
<li><p>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</p>
</li>
<li><p>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</p>
</li>
<li><p>简单快速、灵活</p>
</li>
<li><p>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</p>
</li>
</ul>
<p><strong>HTTPS的特点</strong></p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ol>
<h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了<strong>非对称加密</strong>，<strong>对称加密</strong>，<strong>HASH算法</strong>。握手过程的具体描述如下：</p>
<ul>
<li>1）浏览器将自己支持的一套加密规则发送给网站。 </li>
<li>2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。  </li>
<li>3）浏览器获得网站证书之后浏览器要做以下工作：  a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。  b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。  c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 </li>
<li> 4）网站接收浏览器发来的数据之后要做以下的操作：  a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。  b) 使用密码加密一段握手消息，发送给浏览器。 </li>
<li> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 </li>
</ul>
<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：</p>
<ul>
<li>非对称加密算法：RSA，DSA/DSS</li>
<li>对称加密算法：AES，RC4，3DES</li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<h4 id="通信时序图"><a href="#通信时序图" class="headerlink" title="通信时序图"></a>通信时序图</h4><p><img src="http://www.runoob.com/wp-content/uploads/2017/05/201208201734403507.png" alt="201208201734403507"></p>
<h3 id="SSL单向认证和SSL双向认证的区别"><a href="#SSL单向认证和SSL双向认证的区别" class="headerlink" title="SSL单向认证和SSL双向认证的区别"></a>SSL单向认证和SSL双向认证的区别</h3><p>SSL单向认证只要求站点部署了SSL证书就行，任何用户都可以去访问（IP被限制除外等），只是服务器提供了身份认证。SSL双向认证则是需要服务端与客户端提供身份认证，只能是服务端允许的客户去访问，安全性相对高一些。</p>
<p>双向认证SSL协议要求服务器和用户双方都有证书。单向认证SSL协议不需要客户拥有CA证书，只需将服务器验证客户证书的过程去掉，以及在协商对称密码方案、对称通话密钥时，服务器发送给客户的是没有加过密的（这并不影响SSL过程的安全性）密码方案。这样，双方具体的通讯内容，就是加过密的数据，如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够安全，这也是强调使用128位加密通讯的原因。</p>
<p>一般Web应用都是采用SSL单向认证的，原因很简单，用户数目广泛，且无需在通讯层对用户身份进行验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证，这时就需要做SSL双向认证。</p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>secure socket layer (安全套接字层)</p>
<p>SSL证书和我们日常用的身份证类似，是一个支持HTTPS网站的身份证明，SSL证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。</p>
<h3 id="证书的类型"><a href="#证书的类型" class="headerlink" title="证书的类型"></a>证书的类型</h3><p>实际上，我们使用的证书分很多种类型，SSL证书只是其中的一种。SSL证书负责传输公钥，是一种PKI（Public Key Infrastructure，公钥基础结构）证书。 我们常见的证书根据用途不同大致有以下几种：</p>
<ul>
<li> 1、SSL证书，用于加密HTTP协议，也就是HTTPS。</li>
<li> 2、代码签名证书，用于签名二进制文件，比如Windows内核驱动，Firefox插件，Java代码签名等等。</li>
<li> 3、客户端证书，用于加密邮件。</li>
<li> 4、双因素证书，网银专业版使用的USB Key里面用的就是这种类型的证书。</li>
</ul>
<p> 这些证书都是由受认证的证书颁发机构——我们称之为<strong>CA（Certificate Authority）</strong>机构来颁发，针对企业与个人的不同，可申请的证书的类型也不同，价格也不同。CA机构颁发的证书都是受信任的证书，对于SSL证书来说，如果访问的网站与证书绑定的网站一致就可以通过浏览器的验证而不会提示错误。</p>
<h3 id="SSL证书申请与规则"><a href="#SSL证书申请与规则" class="headerlink" title="SSL证书申请与规则"></a>SSL证书申请与规则</h3><p>SSL证书可以向CA机构通过付费的方式申请，也可以自己制作。 CA机构颁发的证书价格非常昂贵，而且有效期一般只有一年到三年不等（年数不同，价格也不同），过期之后还要再次交钱申请，因此一般只有企业才会申请证书。但是随着个人网站的增多，目前也有针对个人的SSL证书服务，价格相对便宜一些，国内的话400多块钱就能申请到一个，国外更是有免费的SSL证书可以申请。 在申请SSL证书时需要向CA机构提供网站域名，营业执照，以及申请人的身份信息等。网站的域名非常重要，申请人必须证明自己对域名有所有权，如果支持Hotmail.com，Gmail.com的SSL证书都可以随便申请，黑客们就不用做假证书欺骗了。</p>
<p>此外，一个证书一般只绑定一个域名，如果CA机构心情好的话，会免费再绑一个，比如你要申请域名时绑定的域名是 <a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> ，那么只有在浏览器地址是 <a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a>  的时候，这个证书才是受信任的，如果地址是 <a href="https://tt.runoob.com" target="_blank" rel="noopener">https://tt.runoob.com</a> 或者 <a href="https://login.runoob.com" target="_blank" rel="noopener">https://login.runoob.com</a> ，那么这个证书由于访问的域名与证书绑定的域名不同，仍然会被浏览器显示为不受信任的。</p>
<p>CA机构也提供申请通配符域名（例如，*.runoob.com），通配符域名相当于绑定了主域名下的所有域名，因此使用起来非常方便，但是价格也超级昂贵，一个通配符域名一年大概得5000块钱，只有企业才可以申请。 </p>
<hr>
<p>以上说的是向CA机构申请证书的情况，如果个人网站只为加密传输也可以自己制作SSL证书，自己制作的证书不会受到浏览器的信任，在访问的时候由于证书验证失败而给出警告。</p>
<h3 id="SSL证书欺骗"><a href="#SSL证书欺骗" class="headerlink" title="SSL证书欺骗"></a>SSL证书欺骗</h3><p>对HTTPS最常见的攻击手段就是SSL证书欺骗或者叫SSL劫持，是一种典型的中间人攻击。不过SSL劫持并非只是用于攻击目的，在一些特殊情况下利用SSL劫持我们可以更顺畅的访问网络，我会在后文提到。</p>
<p>以攻击为目的的SSL劫持如果不注意浏览器安全提示的话，很容易就中招。当网络中有中间人发起SSL劫持攻击时，攻击者需要伪造一个SSL证书发给浏览器，这个时候由于伪造的SSL证书不受信任，浏览器会给出提示。</p>
<p>这里有一个误区，当SSL证书不受信任的时候，并不一定就是有SSL劫持发生，有种例外情况是：一些个人网站买不起合法的SSL证书，因此会自己制作一个SSL证书来加密传输的数据。如果你经常访问某个个人网站，而且你知道这个网站是干什么的，那么这种情况可以不用担心。但是如果你访问的是网银，在线支付，或者是hotmail.com，gmail.com等，这类公司性质的网站一定会申请合法的SSL证书（12306.cn除外），一旦SSL证书不受信任，应该果断的终止访问，这个时候网络中一定会存在异常行为，对于一些小区宽带的用户一定要注意这点。</p>
<p>所以作为个人用户，你一定要知道你访问的是什么网站，如果你只是一个没有多少计算机只是的普通网民，我相信你不会经常上那些自己制作SSL证书的个人网站（12306.cn除外），因此如果你没有办法判断网络是不是有异常，只要是证书有问题的，干脆就别再访问了。</p>
<blockquote>
<p>小提示：对于12306.cn，一定要按照网站说的那样，”为保障您顺畅购票，请下载安装根证书”。</p>
</blockquote>
<p>总结一下使用SSL证书要注意的问题：</p>
<ul>
<li>1、除非必要，不要随意安装根证书。安装根证书的时候一定要明确证书的来源。</li>
<li>2、对于网银，在线支付，重要邮箱等网站，一定要确保SSL证书是没有问题的，如果浏览器给出SSL证书错误的警告，一定要拒绝访问。一些小区宽带用户一定要注意这点。</li>
<li>3、由于现在个人申请SSL证书比较便宜，一定要注意挂着合法SSL证书的钓鱼网站（国外比较常见）。对于钓鱼网站，一定要看清域名，另外别相信什么中奖的消息，同时要安装带有钓鱼防护功能的安全软件。</li>
</ul>
<h3 id="证书如何保证安全传输"><a href="#证书如何保证安全传输" class="headerlink" title="证书如何保证安全传输"></a>证书如何保证安全传输</h3><p>数字证书包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要，然后根据证书上描述的计算证书的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</p>
<p>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3><ol>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</li>
<li>SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>
<h3 id="成本考虑"><a href="#成本考虑" class="headerlink" title="成本考虑"></a>成本考虑</h3><p>SSL证书需要购买申请，功能越强大的证书费用越高。</p>
<p>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p>
<p>根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</p>
<p>HTTPS连接缓存不如HTTP高效，流量成本高。</p>
<p>HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</p>
<p>HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</p>
<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><p>SSL只是一个协议，openssl则是SSL的实现版，另外openssl还包含了公钥私钥的生成、摘要生成等各种工具。</p>
<p><strong>使用场景</strong></p>
<p>我们知道，有些时候我们浏览网站的时候会有一些广告，这些广告什么的不一定是原网站挂上去的，也有可能是中间的运营商在中间篡改了内容导致的，可以使用https技术（一般是基于openssl）来对数据进行加密，保证数据不被篡改。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p><strong>学习来源</strong></p>
<p><a href="http://www.runoob.com/w3cnote/https-ssl-intro.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/https-ssl-intro.html</a></p>
<p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noopener">https://blog.csdn.net/xiaoming100001/article/details/81109617</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Develop/Git笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/01/Develop/Git笔记/" class="article-date">
      <time datetime="2019-04-01T07:24:56.000Z" itemprop="datePublished">2019-04-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/Develop/Git笔记/">Git使用笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Git使用笔记"><a href="#Git使用笔记" class="headerlink" title="Git使用笔记"></a>Git使用笔记</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的快速教程</a></p>
<p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">官方教程</a></p>
<p><a href="https://www.jianshu.com/p/bf5755a8a6f1" target="_blank" rel="noopener">一篇简书 Check-in Dance</a></p>
<p><strong>常用命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add 1.txt</span><br><span class="line">git commit -m <span class="string">"bug fix"</span></span><br><span class="line">git rm 1.txt</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git diff 1.txt</span><br><span class="line">git diff HEAD -- 1.txt //查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> [--graph] [--pretty=oneline] [--abbrev-commit]</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line">git reset --hard HEAD~3</span><br><span class="line">git reset --hard bde57</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git checkout -- 1.txt</span><br><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line">// 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line">// 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，</span><br><span class="line">//			 第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line">// 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</span><br><span class="line"></span><br><span class="line">git branch							//查看分支</span><br><span class="line">git branch &lt;name&gt; 			//创建分支</span><br><span class="line">git checkout &lt;name&gt;			//切换分支</span><br><span class="line">git checkout -b &lt;name&gt;	//创建+切换分支</span><br><span class="line">git merge &lt;name&gt;				//合并某分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt;		//删除分支</span><br><span class="line">git branch -D &lt;name&gt;		//强行删除分支</span><br><span class="line"></span><br><span class="line">git merge --no-ff -m <span class="string">"xxx"</span> &lt;branch&gt;	//禁用 Fast forward</span><br><span class="line"></span><br><span class="line">git cherry-pick &lt;commit-id&gt;	// merge 指定 commit</span><br><span class="line"></span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply [stash@&#123;4&#125;]</span><br><span class="line">git stash drop [stash@&#123;2&#125;]</span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line">git remote [-v]</span><br><span class="line">git push [-u] origin master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:xxx/xxx.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xxx/xxx.git</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; [&lt;commit-id&gt;]</span><br><span class="line">git show &lt;tagname&gt; / &lt;commit-id&gt;</span><br><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">git push origin &#123;&lt;tagname&gt; / --tags&#125;</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;	//先本地删除，然后远程删除</span><br><span class="line"></span><br><span class="line">// 配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ch checkout</span><br><span class="line">git config --global alias.co commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">// 仓库的Git配置文件在仓库目录下.git/config中。</span><br><span class="line">// 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。</span><br></pre></td></tr></table></figure>
<h3 id="IDE-Git使用"><a href="#IDE-Git使用" class="headerlink" title="IDE+Git使用"></a>IDE+Git使用</h3><p>在mac平台，拿Clion举个例子，大部分IDE都差不多。</p>
<ol>
<li><p>先创建本地仓库并且发布(命令行或者GitHub Desktop)</p>
</li>
<li><p>Clion只需要在上一步创建的位置上创建新项目，便会自动使用Git进行版本控制。</p>
</li>
<li><p>工具栏只能pull和commit，而push在菜单栏里。</p>
</li>
<li><p>如果不想上传clion自动创建的文件夹，可以添加ignore文件名(命令行或者GitHub Desktop)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake-build*</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：</p>
<ul>
<li>可以设置commit的时候检查todo注释</li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/IO/libevent基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/27/Network/IO/libevent基础/" class="article-date">
      <time datetime="2019-03-27T14:47:57.000Z" itemprop="datePublished">2019-03-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/Network/IO/libevent基础/">libevent基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>官方文档：<a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org </a>.</p>
<p>本篇是对官方文档的学习摘录。有目录方便查找。</p>
<hr>
<p>各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，<strong>libevent就是对这些高效IO的封装，提供统一的API，简化开发。</strong></p>
<p><em>libevent</em> is meant to replace the event loop found in event driven network servers. An application just needs to call<em>event_dispatch()</em> and then add or remove events dynamically without having to change the event loop.</p>
<p>Libevent can also be used for multi-threaded applications, either by isolating each event_base so that only a single thread accesses it, or by locked access to a single shared event_base. </p>
<p>Libevent additionally provides a sophisticated framework for buffered network IO, with support for sockets, filters, rate-limiting, SSL, zero-copy file transmission, and IOCP. Libevent includes support for several useful protocols, including DNS, HTTP, and a minimal RPC framework.</p>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><strong>Libevent is divided into the following components:</strong></p>
<p><strong>evutil</strong></p>
<p>Generic functionality to abstract out the differences between different platforms’ networking implementations.</p>
<p><strong>event</strong> and <strong>event_base</strong></p>
<p>This is <em>the heart of Libevent</em>. It provides an abstract API to the various platform-specific, event-based nonblocking IO backends. It can let you know when sockets are ready to read or write, do basic timeout functionality, and detect OS signals.</p>
<p><strong>bufferevent</strong></p>
<p>These functions provide a more convenient wrapper around Libevent’s event-based core. They let your application request buffered reads and writes, and rather than informing you when sockets are ready to do, they let you know when IO has actually occurred.</p>
<p><strong>evbuffer</strong></p>
<p>This module implements the buffers underlying bufferevents, and provides functions for efficient and/or convenient access.</p>
<p><strong>evhttp</strong></p>
<p>A simple HTTP client/server implementation.</p>
<p><strong>evdns</strong></p>
<p>A simple DNS client/server implementation.</p>
<p><strong>evrpc</strong></p>
<p>A simple RPC implementation.</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>When Libevent is built, by default it installs the following libraries:</p>
<ul>
<li><p>libevent_core</p>
<p>All core event and buffer functionality. This library contains all the event_base, evbuffer, bufferevent, and utility functions.</p>
</li>
<li><p>libevent_extra</p>
<p>This library defines protocol-specific functionality that you may or may not want for your application, <em>including HTTP, DNS, and RPC</em>.</p>
</li>
<li><p>libevent</p>
<p>This library <em>exists for historical reasons</em>; it contains the contents of both libevent_core and libevent_extra. <em>You shouldn’t use it; it may go away in a future version of Libevent</em>.</p>
</li>
</ul>
<p>The following libraries are installed only on some platforms:</p>
<ul>
<li><p>libevent_pthreads</p>
<p>This library adds threading and locking implementations based on the pthreads portable threading library. It is separated from libevent_core so that you don’t need to link against pthreads to use Libevent unless you are <em>actually</em> using Libevent in a multithreaded way.</p>
</li>
<li><p>libevent_openssl</p>
<p>This library provides support for encrypted communications using bufferevents and the OpenSSL library. It is separated from libevent_core so that you don’t need to link against OpenSSL to use Libevent unless you are <em>actually</em> using encrypted connections.</p>
</li>
</ul>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>All current public Libevent headers are <strong>installed under the <em>event2</em> directory</strong>. </p>
<table>
<thead>
<tr>
<th>OLD HEADER</th>
<th>REPLACED BY CURRENT HEADERS</th>
</tr>
</thead>
<tbody>
<tr>
<td>event.h</td>
<td>event2/event*.h, event2/buffer*.h event2/bufferevent*.h event2/tag*.h</td>
</tr>
<tr>
<td>evdns.h</td>
<td>event2/dns*.h</td>
</tr>
<tr>
<td>evhttp.h</td>
<td>event2/http*.h</td>
</tr>
<tr>
<td>evrpc.h</td>
<td>event2/rpc*.h</td>
</tr>
<tr>
<td>evutil.h</td>
<td>event2/util*.h</td>
</tr>
</tbody>
</table>
<h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><h3 id="Lib-setup"><a href="#Lib-setup" class="headerlink" title="Lib setup"></a>Lib setup</h3><p>在开始调用libevent之前，可以进行一些设置来影响程序的行为。</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/03/27/Network/IO/libevent基础/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Operating-System/操作系统知识笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/25/Operating-System/操作系统知识笔记/" class="article-date">
      <time datetime="2019-03-25T13:03:29.000Z" itemprop="datePublished">2019-03-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Operating-System/操作系统知识笔记/">操作系统知识笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="操作系统知识点"><a href="#操作系统知识点" class="headerlink" title="操作系统知识点"></a>操作系统知识点</h2><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>IPC(Inter-Process Communication)进程间通信，提供了各种进程间通信的方法。在Linux C编程中有几种方法</p>
<ol>
<li>半双工Unix管道</li>
<li>FIFOs(命名管道)</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>Unix域套接字</li>
</ol>
<h3 id="多核CPU和进程线程"><a href="#多核CPU和进程线程" class="headerlink" title="多核CPU和进程线程"></a>多核CPU和进程线程</h3><ol>
<li>单CPU中进程只能是并发，多CPU计算机中进程可以并行。</li>
<li>单CPU单核中线程只能并发，单CPU多核中线程可以并行。</li>
</ol>
<h3 id="用户态和内核态的切换"><a href="#用户态和内核态的切换" class="headerlink" title="用户态和内核态的切换"></a>用户态和内核态的切换</h3><p>　　因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p>
<p>一般存在以下三种情况会发生从用户态到内核态的切换：</p>
<p>1）<strong>系统调用</strong>：原因如上分析。</p>
<p>2）<strong>异常事件</strong>： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</p>
<p>3）<strong>外围设备的中断</strong>：<strong><em>当外围设备完成用户的请求操作后，会向CPU发出中断信号</em></strong>，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
<p>　　注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<h3 id="进程与线程的上下文切换"><a href="#进程与线程的上下文切换" class="headerlink" title="进程与线程的上下文切换"></a>进程与线程的上下文切换</h3><p>来自：<a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52845869</a></p>
<p>线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p>
<p>所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Op-System/">Op-System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Op-System/">Op-System</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/Concept/数据库理论知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/25/Database/Concept/数据库理论知识/" class="article-date">
      <time datetime="2019-03-25T12:24:14.000Z" itemprop="datePublished">2019-03-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Database/Concept/数据库理论知识/">数据库理论知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据库理论知识"><a href="#数据库理论知识" class="headerlink" title="数据库理论知识"></a>数据库理论知识</h2><p>以下来自：<a href="https://juejin.im/post/5b55b842f265da0f9e589e79#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79#heading-1</a></p>
<h3 id="聚集和非聚集索引"><a href="#聚集和非聚集索引" class="headerlink" title="聚集和非聚集索引"></a>聚集和非聚集索引</h3><p>简单概括：</p>
<ul>
<li>聚集索引就是以<strong>主键</strong>创建的索引</li>
<li>非聚集索引就是以<strong>非主键</strong>创建的索引</li>
</ul>
<p>区别：</p>
<ul>
<li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li>
<li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li>
<li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li>
</ul>
<p><strong>非聚集索引也叫做二级索引</strong>，不用纠结那么多名词，将其等价就行了~</p>
<p>非聚集索引在建立的时候也<strong>未必是单列</strong>的，可以多个列来创建索引。</p>
<ul>
<li>此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则–&gt;后面有说)</li>
<li><strong>创建多个单列(非聚集)索引的时候，会生成多个索引树</strong>(所以过多创建索引会占用磁盘空间)</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>在创建多列索引中也涉及到了一种特殊的索引–&gt;<strong>覆盖索引</strong></p>
<ul>
<li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li>
<li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li>
<li>覆盖索引就是把要<strong>查询出的列和索引对应</strong>，不做回表操作！</li>
</ul>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p><strong>最左匹配原则</strong>：</p>
<ul>
<li>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。</li>
<li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询<code>(&gt;、&lt;、between、like</code>左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>
<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>
</ul>
<p>例子：</p>
<ul>
<li>如有索引<code>(a, b, c, d)</code>，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配)</li>
</ul>
<h3 id="自动优化顺序"><a href="#自动优化顺序" class="headerlink" title="=自动优化顺序"></a>=自动优化顺序</h3><p><strong>不需要考虑=、in等条件查询的顺序</strong>，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>例子：</p>
<p>如有索引<code>(a, b, c, d)</code>，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p>
<h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><p>这部分来自：<a href="https://www.cnblogs.com/sessionbest/articles/8689255.html" target="_blank" rel="noopener">https://www.cnblogs.com/sessionbest/articles/8689255.html</a></p>
<ol>
<li>按照索引列值的唯一性，索引可分为唯一索引和非唯一索引；</li>
<li>按照索引列的个数：单列索引和复合索引；</li>
<li>按照索引列的物理组织方式。</li>
</ol>
<p><strong>物理组织方式</strong>：</p>
<p>一、<strong>B树索引</strong></p>
<p>最常用的索引，各叶子节点中包括的数据有索引列的值和数据表中对应行的ROWID，简单的说，在B树索引中，是通过在索引中保存排过续的索引列值与相对应记录的ROWID来实现快速查询的目的。</p>
<p>可以保证无论用户要搜索哪个分支的叶子结点，都需要经过相同的索引层次，即都需要相同的I/O次数。</p>
<p>注1：索引是针对字段创建的，相同字段不能创建一个以上的索引；</p>
<p>注2：默认的索引是不唯一的，但是也可以加上unique，表示该索引的字段上没有重复值(定义unique约束时会自动创建)；</p>
<p>注3：创建主键时，默认在主键上创建了B树索引，因此不能再在主键上创建索引。</p>
<p>二、<strong>位图索引</strong></p>
<p>有些字段中使用B树索引的效率仍然不高，例如性别的字段中，只有“男、女”两个值，则即便使用了B树索引，在进行检索时也将返回接近一半的记录。</p>
<p>所以当字段的基数很低时，需要使用位图索引。(“低”的标准是取值数量 &lt; 行数*1%)</p>
<p><img src="http://118.25.53.128/Picture/Database/bitmap_index.jpg" alt="bitmap_index"></p>
<p>位图索引的逻辑结构如上图所示：索引中不再记录rowid和键值，而是将每个值作为一列，用0和1表示该行是否等于该键值(0表示否;1表示是)。其中位图索引的行顺序与原表的行顺序一致，可以在查询数据的过程中对应计算出行的原始物理位置。</p>
<p>注：位图索引不可能是唯一索引，也不能进行键值压缩。</p>
<p>三、<strong>反向键索引</strong></p>
<p>考虑这个情况：某一字段的值是1-1000顺序排列，建立B树索引后依旧递增，到后来该B数索引不断在后面增加分支，会形成不对称树。</p>
<p>反向键索引是<strong>一种特殊的B树索引</strong>，在存储构造中与B树索引完全相同，但是针对数值时，反向键索引会先反向每个键值的字节，然后对反向后的新数据进行索引。例如输入2008则转换为8002，这样当数值一次增加时，其反向键在大小中的分布仍然是比较平均的。</p>
<p>注：键的反转由系统自行完成。对于用户是透明的。</p>
<p>四、<strong>基于函数的索引</strong></p>
<p>有的时候，需要进行如下查询：<code>select * from t1 where to_char(date,&#39;yyyy&#39;)&gt;&#39;2007&#39;;</code></p>
<p>但是即便在date字段上建立了索引，还是不得不进行全表扫描。在这种情况下，可以使用基于函数的索引。</p>
<p>注：简单来说，基于函数的索引，就是将查询要用到的表达式作为索引项。</p>
<p>五、<strong>全局索引和局部索引</strong></p>
<p>这个索引貌似很复杂，其实很简单。总得来说一句话，就是无论怎么分区，都是为了方便管理。</p>
<p>具体索引和表的关系有三种：</p>
<p>1、局部分区索引：分区索引和分区表1对1</p>
<p>2、全局分区索引：分区索引和分区表N对N</p>
<p>3、全局非分区索引：非分区索引和分区表1对N</p>
<h3 id="热备份、冷备份"><a href="#热备份、冷备份" class="headerlink" title="热备份、冷备份"></a>热备份、冷备份</h3><p>来自：<a href="https://www.cnblogs.com/a12436109/p/3606135.html" target="_blank" rel="noopener">https://www.cnblogs.com/a12436109/p/3606135.html</a></p>
<p>线路<strong><em>倒换</em></strong>是指把互为备用的两条线路之一条传送的信号转移到另一条的过程或技术。</p>
<p>热备份是实时备份，发生倒换也不影响业务；冷备份则是周期性备份（如：定时每天凌晨开始备份），发生倒换时，备机的数据不是最新的。</p>
<p>简单解释下。<br>热备份就是2个完全一样的系统，包括硬盘，内存里的内容都一模一样，所不同的是主用与其他设备即时通信，它将根据移动用户的数据变化而变化，对于备份的设备则是实时与主用设备保持一致，一句话就是：主用随现网变，备用随主用变。而且是任何部分都要变。这就牵涉到一个问题，就是修改主用设备的数据时候必须同时修改备用，如果只修改一个就会出数据不一致的告警，甚至引起主备一直切换，直至他们重新同步。</p>
<p>冷备份也是2个完全一样的系统，但是备用处于休息状态，硬盘也是存系统文件，配置文件等，对于用户数据，现网运行情况只是做定时更新，内存根本就是停滞状态，只有在主用倒掉的时候，备用才会启用，用户数据也会恢复倒上次更新的情况（当然如果与主用的硬盘通信状态没断的时候还是会再与其同步最后一次），内存里会重新加载需要用的数据。、</p>
<p>打个比方就例如你需要看通过电视看场球赛，为了安全起见，你准备了2个一样的电视，热备份就是两个同时开开，同时放一个节目，只要你看的那个电视（主用）坏掉了，你扭头就能看另一个电视，而冷备份就是你就开了一台电视，如果主用电视坏了你还要开备用电视，或者还要选台选节目。</p>
<p>所以热备份不会影响业务，而冷备份会使业务暂时中断，只是时间不会太长。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Database/">Database</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Operating-System/Linux虚拟地址空间" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/24/Operating-System/Linux虚拟地址空间/" class="article-date">
      <time datetime="2019-03-24T08:31:27.000Z" itemprop="datePublished">2019-03-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/Operating-System/Linux虚拟地址空间/">Linux虚拟地址空间</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Linux虚拟地址空间"><a href="#Linux虚拟地址空间" class="headerlink" title="Linux虚拟地址空间"></a>Linux虚拟地址空间</h2><blockquote>
<p>整理自：<a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3754433.html</a></p>
<p>另一篇已经写了C程序内存结构，这篇是更详细的。</p>
</blockquote>
<p><strong>在多任务操作系统中</strong>，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是<strong>虚拟地址空间(Virtual Address Space)</strong>，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<p><strong>虚拟地址通过页表(Page Table)映射到物理内存</strong>，页表由操作系统维护并被处理器引用。<strong>每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</strong></p>
<p><strong>内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误</strong>(page fault)。</p>
<p><strong>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存</strong>。内核代码和数据总是可寻址，随时准备处理中断和系统调用。<strong>与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</strong>。</p>
<hr>
<p><strong>Linux进程在虚拟内存中的标准内存段布局</strong>如下图所示：</p>
<p><img src="http://118.25.53.128/Picture/Op/vitural_addr.jpg" alt="vitural_addr"></p>
<p>其中，用户地址空间中的蓝色条带对应于映射到物理内存的不同内存段，灰白区域表示未映射的部分。这些段只是简单的内存地址范围，与Intel处理器的段没有关系。</p>
<p>上图中<strong>Random stack offset等随机值意在防止恶意程序</strong>。Linux通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。execve(2)负责为进程代码段和数据段建立映射，真正将代码段和数据段的内容读入内存是由系统的缺页异常处理程序按需完成的。另外，execve(2)还会将BSS段清零。</p>
<p>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。</p>
<p>BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</p>
<hr>
<h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><p>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由 mm_struct 结构体表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>           <span class="comment">/* 内存区域链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>                  <span class="comment">/* VMA 形成的红黑树 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>               <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;                <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;               <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;               <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm;               <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;                 <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;                <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;                   <span class="comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;        <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;                  <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                   <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Op/mm_struct.png" alt="mm_struct"></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程是进程的执行单元，每个线程都运行在进程的上下文中，共享该进程虚拟地址空间里的：</p>
<ul>
<li><strong>代码段、数据段、堆、共享库、打开的文件</strong>。</li>
</ul>
<p>每个线程都有自己的线程上下文，包括：</p>
<ul>
<li><strong>线程 ID、栈、栈指针、PC、通用目的寄存器、条件码</strong>。</li>
</ul>
<p>各自独立的线程栈的内存模型并不整齐清楚，它们都保存在进程虚拟地址空间的栈区域中，通常被相应的线程独立访问，但<strong>并不对其他线程设防</strong>。</p>
<p><img src="http://118.25.53.128/Picture/Op/thread_model.png" alt="thread_model"></p>
<p><strong>线程栈</strong></p>
<p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。<strong>线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别</strong>。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是父进程而 tsk 在 fork() 执行期间是共享子进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用，它不带有 VM_STACK_FLAGS 标记。<strong>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方</strong>。</p>
<p><strong>线程的栈在哪？</strong></p>
<p>Stack space for a new thread is created by the parent thread with <code>mmap(MAP_ANONYMOUS|MAP_STACK)</code>. So they’re in the “memory map segment”. It can end up anywhere that a large <code>malloc()</code> could go. (glibc <code>malloc(3)</code> uses <code>mmap(MAP_ANONYMOUS)</code> for large allocations.)</p>
<hr>
<h3 id="各个分段的含义"><a href="#各个分段的含义" class="headerlink" title="各个分段的含义"></a>各个分段的含义</h3><ul>
<li><p><strong>内核空间</strong></p>
<p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
</li>
<li><p><strong>栈</strong>(stack)</p>
<p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</li>
</ul>
<p>持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。<strong>进程中的每个线程都有属于自己的栈。</strong>向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则<strong>栈会动态增长</strong>，程序继续运行。<strong>映射的栈区扩展到所需大小后，不再收缩。</strong></p>
<p>Linux中<code>ulimit -s</code>命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。</p>
<p>堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。</p>
<p>堆栈的大小在运行时由内核动态调整。</p>
</li>
<li><p><strong>内存映射段(mmap)</strong></p>
<p>此处，内核<strong>将硬盘文件的内容直接映射到内存</strong>, 任何应用程序都可通过<strong>Linux的mmap()</strong>系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。<strong>内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库</strong>。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。<strong>在 Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值 MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。</strong></p>
<p>（该区域用于映射用到的动态链接库。在Linux 2.4版本中，若可执行文件依赖共享库，则系统会为这些动态库在从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间。在Linux 2.6内核中，共享库的起始地址被往上移动至更靠近栈区的位置。）</p>
<p>（从进程地址空间的布局可以看到，在有共享库的情况下，留给堆的可用空间还有两处：一处是从.bss段到0x40000000，约不到1GB的空间；另一处是从共享库到栈之间的空间，约不到2GB。这两块空间大小取决于栈、共享库的大小和数量。这样来看，是否应用程序可申请的最大堆空间只有2GB？事实上，这与Linux内核版本有关。在上面给出的进程地址空间经典布局图中，共享库的装载地址为0x40000000，这实际上是Linux kernel 2.6版本之前的情况了，在2.6版本里，共享库的装载地址已经被挪到靠近栈的位置，即位于0xBFxxxxxx附近，因此，此时的堆范围就不会被共享库分割成2个“碎片”，故kernel 2.6的32位Linux系统中，malloc申请的最大内存理论值在2.9GB左右。）</p>
</li>
<li><p><strong>堆</strong>(heap)</p>
<p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。<strong>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问</strong>。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。</p>
<p>分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p>
<p>堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p>
</li>
<li><p>【扩展阅读】<strong>栈和堆的区别</strong></p>
<ul>
<li>①<strong>管理方式</strong>：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。</li>
<li>②<strong>生长方向</strong>：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li>
<li>③<strong>空间大小</strong>：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。</li>
<li>④<strong>存储内容</strong>：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。</li>
<li>⑤<strong>分配方式</strong>：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。</li>
<li>⑥<strong>分配效率</strong>：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。</li>
<li>⑦<strong>分配后系统响应</strong>：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。     操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。     此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</li>
<li>⑧<strong>碎片问题</strong>：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。     可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。</li>
</ul>
</li>
<li><p><strong>BSS段</strong>(Block Started by Symbol)</p>
<p>BSS段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li>
<li>未定义且初值不为0的符号(该初值即common block的大小)</li>
</ul>
<p>C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可<strong>减少目标文件体积</strong>。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p>
<p>注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要<strong>为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突</strong>，而不是被未知值覆盖。</p>
</li>
<li><p><strong>数据段</strong>(Data)</p>
<p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p>
<p>数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p>
</li>
<li><p>【扩展阅读】<strong>数据段与BSS段的区别</strong></p>
<ul>
<li><p>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。</p>
<p>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p>
</li>
<li><p>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p>
</li>
</ul>
</li>
<li><p><strong>代码段</strong>(text)</p>
<p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p>代码段最容易受优化措施影响。</p>
</li>
<li><p><strong>保留区</strong></p>
<p><strong>位于虚拟地址空间的最低部分</strong>，未赋予物理地址。任何对它的引用都是非法的，<strong>用于捕捉使用空指针和小整型值指针引用内存的异常情况</strong>。</p>
<p>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。<strong>C语言将无效指针赋值为0也是出于这种考虑</strong>，因为0地址上正常情况下不会存放有效的可访问数据。</p>
</li>
</ul>
<hr>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><p>进程运行过程中，代码指令根据流程依次执行，只需访问一次(当然跳转和递归可能使代码执行多次)；而数据(数据段和BSS段)通常需要访问多次，因此单独开辟空间以方便访问和节约空间。具体解释如下：</p>
<p>当程序被装载后，数据和指令分别映射到两个虚存区域。数据区对于进程而言可读写，而指令区对于进程只读。两区的权限可分别设置为可读写和只读。以防止程序指令被有意或无意地改写。</p>
<p>现代CPU具有极为强大的缓存(Cache)体系，程序必须尽量提高缓存命中率。<strong>指令区和数据区的分离有利于提高程序的局部性</strong>。现代CPU一般数据缓存和指令缓存分离，故程序的指令和数据分开存放有利于<strong>提高CPU缓存命中率。</strong></p>
<p>当系统中运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分。若系统中运行数百进程，通过共享指令将节省大量空间(尤其对于有动态链接的系统)。其他只读数据如程序里的图标、图片、文本等资源也可共享。而每个副本进程的数据区域不同，它们是进程私有的。</p>
<p>此外，临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。全局数据和静态数据可能在整个程序执行过程中都需要访问，因此单独存储管理。堆区由用户自由分配，以便管理。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Op-System/">Op-System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Op-System/">Op-System</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++ref" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/23/C-C++/C++Collection/C++ref/" class="article-date">
      <time datetime="2019-03-23T10:28:23.000Z" itemprop="datePublished">2019-03-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/C-C++/C++Collection/C++ref/">C++ref</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-ref"><a href="#C-ref" class="headerlink" title="C++ ref"></a>C++ ref</h2><p>像thread类 和 bind函数的参数只能按值传递（内部decay，移除了引用），如果想传递引用，那么就需要 <code>std::ref</code>，const引用则用<code>cref</code>。</p>
<p>ref的返回类型为<code>std::reference_wrapper</code>，其实这个模板类保存了传入参数的地址，然后定义了左值引用的类型转化函数，所以把它赋值给一个引用就可以让这个引用获得对象内保存的地址，看起来就和真正的引用一样了。</p>
<p>官方实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">reference_wrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// types</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// construct/copy/destroy</span></span><br><span class="line">  reference_wrapper(T&amp; ref) <span class="keyword">noexcept</span> : _ptr(<span class="built_in">std</span>::addressof(ref)) &#123;&#125;</span><br><span class="line">  reference_wrapper(T&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  reference_wrapper(<span class="keyword">const</span> reference_wrapper&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// assignment</span></span><br><span class="line">  reference_wrapper&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> reference_wrapper&amp; x) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// access</span></span><br><span class="line">  <span class="keyword">operator</span> T&amp; () <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">  <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">ArgTypes</span> &gt;</span></span><br><span class="line"><span class="class">  <span class="title">std</span>:</span>:<span class="keyword">invoke_result_t</span>&lt;T&amp;, ArgTypes...&gt;</span><br><span class="line">    <span class="keyword">operator</span>() ( ArgTypes&amp;&amp;... args ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::invoke(get(), <span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// deduction guides</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">reference_wrapper</span>(<span class="title">reference_wrapper</span>&lt;T&gt;) -&gt; <span class="title">reference_wrapper</span>&lt;T&gt;;</span></span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2022 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>