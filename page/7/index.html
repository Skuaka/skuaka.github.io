<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://blog.skuaka.cn/page/7/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Job/">Job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Op-System/">Op-System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openSSL/">openSSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postman/">postman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/steamcmd/">steamcmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travis/">travis</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-Network/Tcp/ICMP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/Network/Tcp/ICMP/" class="article-date">
      <time datetime="2019-03-22T14:49:12.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/Network/Tcp/ICMP/">ICMP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><strong>互联网控制消息协议</strong>（英语：<strong>I</strong>nternet <strong>C</strong>ontrol <strong>M</strong>essage <strong>P</strong>rotocol，缩写：<strong>ICMP</strong>）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
<p>ICMP依靠IP來完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了ping和traceroute这两个特別的例子。</p>
<h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p>ICMP报头从IP报头的第160位开始（IP首部20字节）（除非使用了IP报头的可选部分）。</p>
<p><img src="Picture/ICMP_header.jpg" alt="ICMP_header"></p>
<ul>
<li><strong>Type</strong> - ICMP的類型,标识生成的错误报文；</li>
<li><strong>Code</strong> - 進一步劃分ICMP的類型,该字段用来查找产生错误的原因.；例如，ICMP的目標不可達類型可以把這個位設為1至15等來表示不同的意思。</li>
<li><strong>Checksum</strong> - 校验码部分,這個字段包含有從ICMP報頭和數據部分計算得來的，用於檢查錯誤的數據，其中此校验码字段的值視為0。</li>
<li><strong>ID</strong> - 這個字段包含了ID值，在Echo Reply類型的消息中要返回這個字段。</li>
<li><strong>Sequence</strong> - 這個字段包含一個序號，同樣要在Echo Reply類型的消息中要返回這個字段。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Tcp/IP头_TCP头_UDP头" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/" class="article-date">
      <time datetime="2019-03-22T14:49:12.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/">IP头_TCP头_UDP头</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>源自：<a href="https://www.cnblogs.com/shenpengyan/p/5912567.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenpengyan/p/5912567.html</a></p>
<h3 id="报文封装整体结构"><a href="#报文封装整体结构" class="headerlink" title="报文封装整体结构"></a>报文封装整体结构</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_封装结构.jpg" alt="o_封装结构"></p>
<h3 id="mac帧头定义"><a href="#mac帧头定义" class="headerlink" title="mac帧头定义"></a>mac帧头定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据帧定义，头14个字节，尾4个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MAC_FRAME_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span> m_cDstMacAddress[<span class="number">6</span>];    <span class="comment">//目的mac地址</span></span><br><span class="line">   <span class="keyword">char</span> m_cSrcMacAddress[<span class="number">6</span>];    <span class="comment">//源mac地址</span></span><br><span class="line">	 <span class="keyword">short</span> m_cType;       　　　　　<span class="comment">//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp</span></span><br><span class="line">&#125;__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="ip头部定义"><a href="#ip头部定义" class="headerlink" title="ip头部定义"></a>ip头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_ip_header.jpg" alt="o_ip头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> m_cVersionAndHeaderLen;					<span class="comment">//版本信息(前4位)，头长度(后4位)</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfService;								<span class="comment">// 服务类型8位</span></span><br><span class="line"> <span class="keyword">short</span> m_sTotalLenOfPacket;						<span class="comment">//数据包长度</span></span><br><span class="line"> <span class="keyword">short</span> m_sPacketID;										<span class="comment">//数据包标识</span></span><br><span class="line"> <span class="keyword">short</span> m_sSliceinfo;									<span class="comment">//分片使用</span></span><br><span class="line"> <span class="keyword">char</span> m_cTTL;													<span class="comment">//存活时间</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfProtocol;							<span class="comment">//协议类型</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;      　　　　　　 	<span class="comment">//校验和</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSourIp;							<span class="comment">//源ip</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiDestIp;							<span class="comment">//目的ip</span></span><br><span class="line">&#125; __attribute__((packed))IP_HEADER, *PIP_HEADER ;</span><br></pre></td></tr></table></figure>
<ul>
<li>版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</li>
<li>报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。</li>
<li>服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。<strong><em>第4至第7比特分别代表延迟、吞吐量、可靠性和花费</em></strong>。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</li>
<li>总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</li>
<li><strong>标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</strong></li>
<li>标志位字段：占3比特。标志一份数据报<strong>是否要求分段</strong>。</li>
<li>段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</li>
<li>生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</li>
<li>协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</li>
<li>头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</li>
<li>源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</li>
<li>可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</li>
</ul>
<h3 id="tcp头部定义"><a href="#tcp头部定义" class="headerlink" title="tcp头部定义"></a>tcp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_tcp_header.jpg" alt="o_tcp头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*TCP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">short</span> m_sSourPort;										<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sDestPort;										<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSequNum;						<span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiAcknowledgeNum;			<span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sHeaderLenAndFlag;						<span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="keyword">short</span> m_sWindowSize;									<span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;										<span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_surgentPointer;							<span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;__attribute__((packed))TCP_HEADER, *PTCP_HEADER;</span><br><span class="line"><span class="comment">/*TCP头中的选项定义</span></span><br><span class="line"><span class="comment">kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">KIND = </span></span><br><span class="line"><span class="comment">  1表示 无操作NOP，无后面的部分</span></span><br><span class="line"><span class="comment">  2表示 maximum segment 后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  3表示 windows scale 后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  4表示 SACK permitted，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  5表示 这是一个SACK包，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  8表示 时间戳，LENGTH为10，含8个字节的时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</p>
</li>
<li><p>顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，当前所携带的数据的第一个字节的顺序号。</p>
<p>（如：本次连接共要发送1000个字节，已发出了100个字节，现在发送下一个报文，假设每个报文携带的数据为100字节，则这个报文的头结构中的序号是100【注：从0开始编号】）</p>
</li>
<li><p><strong>确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含源端期望收到目标端的下一个数据字节的序号。</strong></p>
<p>（如上例中那个报文已被正确接收，则接收端会发送一个ACK=1且确认序号=200的应答报文给发送方。）</p>
</li>
<li><p>头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p>
</li>
<li><p>标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p>
<ul>
<li><p>URG：紧急指针（urgent pointer）有效。</p>
</li>
<li><p>ACK：确认序号有效。</p>
</li>
<li><p>PSH：接收方应该尽快将这个报文段交给应用层。</p>
</li>
<li><p>RST：重建连接。</p>
</li>
<li><p>SYN：发起一个连接。</p>
</li>
<li><p>FIN：释放一个连接。</p>
</li>
</ul>
</li>
<li><p><strong>窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</strong></p>
</li>
<li><p>TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p>
</li>
<li><p><strong>紧急指针字段：占16比特。它是一个偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。</strong></p>
</li>
<li><p>选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
</li>
</ul>
<h3 id="udp头部定义"><a href="#udp头部定义" class="headerlink" title="udp头部定义"></a>udp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_udp_header.jpg" alt="o_udp头部"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*UDP头定义，共8个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UDP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usSourPort;					<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usDestPort;					<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usLength;						<span class="comment">// 数据包长度16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usCheckSum;					<span class="comment">// 校验和16bit</span></span><br><span class="line">&#125;__attribute__((packed))UDP_HEADER, *PUDP_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++线程池" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/C-C++/C++Collection/C++线程池/" class="article-date">
      <time datetime="2019-03-22T05:05:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/C-C++/C++Collection/C++线程池/">C++线程池</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-线程池原理（转）"><a href="#C-线程池原理（转）" class="headerlink" title="C++线程池原理（转）"></a>C++线程池原理（转）</h2><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><p>目前的大多数网络服务器都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。 </p>
<p>传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。</p>
<p>我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。</p>
<ol>
<li>T1：线程创建时间</li>
<li>T2：线程执行时间，包括线程的同步等时间</li>
<li>T3：线程销毁时间</li>
</ol>
<p>那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。</p>
<p>除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。</p>
<p>因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p>
<p>基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>事实上，线程池并不是万能的。它有其特定的使用场合。</p>
<p>线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。 </p>
<p>总之线程池通常适合下面的几个场合： </p>
<ol>
<li>单位时间内<strong>处理任务频繁而且任务处理时间短</strong>。</li>
<li><strong>对实时性要求较高</strong>。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。 </li>
<li>必须<strong>经常面对高突发性事件</strong>，如果采取传统方法，会不停地大量产生线程，销毁线程。此时采用动态线程池可以避免这种情况的发生。</li>
</ol>
<h3 id="线程池框架"><a href="#线程池框架" class="headerlink" title="线程池框架"></a>线程池框架</h3><p>一般线程池都必须具备下面几个组成部分：</p>
<ul>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中实际执行的线程</li>
<li>任务接口：尽管线程池大多数情况下是用来支持网络服务器，但是我们将线程执行的任务抽象出来，形成任务接口，从而使得线程池与具体的任务无关。</li>
<li>任务队列：线程池的概念具体到实现则可能是队列，链表之类的数据结构，其中保存执行线程。</li>
</ul>
<hr>
<p>我们实现的通用线程池框架由五个重要部分组成CThreadManage，CThreadPool，CThread，CJob，</p>
<ul>
<li><p>CWorkerThread，除此之外框架中还包括线程同步使用的类CThreadMutex和CCondition。 </p>
</li>
<li><p>CJob是所有的任务的基类，其提供一个接口Run，所有的任务类都必须从该类继承，同时实现Run方法。该方法中实现具体的任务逻辑。 </p>
</li>
<li><p>CThread是Linux中线程的包装，其封装了Linux线程最经常使用的属性和方法，它也是一个抽象类，是所有线程类的基类，具有一个接口Run。 </p>
</li>
<li><p>CWorkerThread是实际被调度和执行的线程类，其从CThread继承而来，实现了CThread中的Run方法。 </p>
</li>
<li><p>CThreadPool是线程池类，其负责保存线程，释放线程以及调度线程。 </p>
</li>
<li><p>CThreadManage是线程池与用户的直接接口，其屏蔽了内部的具体实现。 </p>
</li>
<li><p>CThreadMutex用于线程之间的互斥。 </p>
</li>
<li><p>CCondition则是条件变量的封装，用于线程之间的同步。 </p>
</li>
</ul>
<p>线程池的时序很简单。CThreadManage直接跟客户端打交道，其接受需要创建的线程初始个数，并接受客户端提交的任务。这儿的任务是具体的非抽象的任务。CThreadManage的内部实际上调用的都是CThreadPool的相关操作。CThreadPool创建具体的线程，并把客户端提交的任务分发给CWorkerThread，CWorkerThread实际执行具体的任务。</p>
<h3 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h3><h4 id="CThreadManage"><a href="#CThreadManage" class="headerlink" title="CThreadManage"></a>CThreadManage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadManage</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*    m_Pool; </span><br><span class="line">    <span class="keyword">int</span>          m_NumOfThread; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetParallelNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    CThreadManage();</span><br><span class="line">    CThreadManage(<span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadManage();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：m_Pool指向实际的线程池。m_NumOfThread是初始创建时候允许创建的并发的线程个数。另外Run和TerminateAll方法只是简单的调用CThreadPool的一些相关方法。具体实现如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CThreadManage::CThreadManage()&#123; </span><br><span class="line">    m_NumOfThread = <span class="number">10</span>; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::CThreadManage(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::~CThreadManage()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Pool)</span><br><span class="line">    <span class="keyword">delete</span> m_Pool;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::SetParallelNum(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::Run(CJob* job,<span class="keyword">void</span>* jobdata)&#123; </span><br><span class="line">    m_Pool-&gt;Run(job,jobdata); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::TerminateAll(<span class="keyword">void</span>)&#123; </span><br><span class="line">    m_Pool-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CThread"><a href="#CThread" class="headerlink" title="CThread"></a>CThread</h4><p>CThread 类实现了对Linux中线程操作的封装，它是所有线程的基类，也是一个抽象类，提供了一个抽象接口Run，所有的CThread都必须实现该Run方法。CThread的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>          m_ErrCode; </span><br><span class="line">    Semaphore    m_ThreadSemaphore;  <span class="comment">//the inner semaphore, which is used to realize </span></span><br><span class="line">    <span class="keyword">unsigned</span>     <span class="keyword">long</span> m_ThreadID;   </span><br><span class="line">    <span class="keyword">bool</span>         m_Detach;       <span class="comment">//The thread is detached </span></span><br><span class="line">    <span class="keyword">bool</span>         m_CreateSuspended;  <span class="comment">//if suspend after creating </span></span><br><span class="line">    <span class="keyword">char</span>*        m_ThreadName; </span><br><span class="line">    ThreadState m_ThreadState;      <span class="comment">//the state of the thread </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetErrcode</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>&#123;m_ErrCode = errcode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ThreadFunction</span><span class="params">(<span class="keyword">void</span>*)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThread(); </span><br><span class="line">    CThread(<span class="keyword">bool</span> createsuspended,<span class="keyword">bool</span> detach); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThread(); </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadState</span><span class="params">(ThreadState state)</span></span>&#123;m_ThreadState = state;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Terminate</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">//Terminate the threa </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">//Start to execute the thread </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">Exit</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Wakeup</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">   </span><br><span class="line">    <span class="function">ThreadState  <span class="title">GetThreadState</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadState;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetLastError</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ErrCode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadName</span><span class="params">(<span class="keyword">char</span>* thrname)</span></span>&#123;<span class="built_in">strcpy</span>(m_ThreadName,thrname);&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetThreadName</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadName;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetThreadID</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadID;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">SetPriority</span><span class="params">(<span class="keyword">int</span> priority)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetPriority</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetConcurrency</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetConcurrency</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Detach</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Join</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Yield</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">Self</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>线程的状态可以分为四种，空闲、忙碌、挂起、终止(包括正常退出和非正常退出)。由于目前Linux线程库不支持挂起操作，因此，我们的此处的挂起操作类似于暂停。如果线程创建后不想立即执行任务，那么我们可以将其“暂停”，如果需要运行，则唤醒。有一点必须注意的是，一旦线程开始执行任务，将不能被挂起，其将一直执行任务至完毕。<br>线程类的相关操作均十分简单。线程的执行入口是从Start()函数开始，其将调用函数ThreadFunction，ThreadFunction再调用实际的Run函数，执行实际的任务。 </p>
<h4 id="CThreadPool"><a href="#CThreadPool" class="headerlink" title="CThreadPool"></a>CThreadPool</h4><p>CThreadPool是线程的承载容器，一般可以将其实现为堆栈、单向队列或者双向队列。在我们的系统中我们使用STL Vector对线程进行保存。CThreadPool的实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadPool</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_MaxNum;   <span class="comment">//the max thread num that can create at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailLow; <span class="comment">//The min num of idle thread that shoule kept </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailHigh;    <span class="comment">//The max num of idle thread that kept at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailNum; <span class="comment">//the normal thread num of idle num; </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_InitNum;  <span class="comment">//Normal thread num; </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function">CWorkerThread* <span class="title">GetIdleThread</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">AppendToIdleList</span><span class="params">(CWorkerThread* jobthread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToBusyList</span><span class="params">(CWorkerThread* idlethread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToIdleList</span><span class="params">(CWorkerThread* busythread)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">DeleteIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">CreateIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThreadMutex m_BusyMutex;    <span class="comment">//when visit busy list,use m_BusyMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_IdleMutex;    <span class="comment">//when visit idle list,use m_IdleMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_JobMutex; <span class="comment">//when visit job list,use m_JobMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line"></span><br><span class="line">    CCondition       m_BusyCond; <span class="comment">//m_BusyCond is used to sync busy thread list </span></span><br><span class="line">    CCondition       m_IdleCond; <span class="comment">//m_IdleCond is used to sync idle thread list </span></span><br><span class="line">    CCondition       m_IdleJobCond;  <span class="comment">//m_JobCond is used to sync job list </span></span><br><span class="line">    CCondition       m_MaxNumCond; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_ThreadList; </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_BusyList;     <span class="comment">//Thread List </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_IdleList; <span class="comment">//Idle List </span></span><br><span class="line"></span><br><span class="line">    CThreadPool(); </span><br><span class="line">    CThreadPool(<span class="keyword">int</span> initnum); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadPool(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetMaxNum</span><span class="params">(<span class="keyword">int</span> maxnum)</span></span>&#123;m_MaxNum = maxnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetMaxNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_MaxNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailLowNum</span><span class="params">(<span class="keyword">int</span> minnum)</span></span>&#123;m_AvailLow = minnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailLowNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailLow;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailHighNum</span><span class="params">(<span class="keyword">int</span> highnum)</span></span>&#123;m_AvailHigh = highnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailHighNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailHigh;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetActualAvailNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAllNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetBusyNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_BusyList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetInitNum</span><span class="params">(<span class="keyword">int</span> initnum)</span></span>&#123;m_InitNum = initnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetInitNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_InitNum;&#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">CThreadPool::CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">    m_MaxNum = <span class="number">50</span>; </span><br><span class="line">    m_AvailLow = <span class="number">5</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = <span class="number">10</span> ;  </span><br><span class="line">    m_AvailHigh = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;Start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::CThreadPool(<span class="keyword">int</span> initnum) </span><br><span class="line">&#123; </span><br><span class="line">    assert(initnum&gt;<span class="number">0</span> &amp;&amp; initnum&lt;=<span class="number">30</span>); </span><br><span class="line">    m_MaxNum   = <span class="number">30</span>; </span><br><span class="line">    m_AvailLow = initnum<span class="number">-10</span>&gt;<span class="number">0</span>?initnum<span class="number">-10</span>:<span class="number">3</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = initnum ;  </span><br><span class="line">    m_AvailHigh = initnum+<span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::~CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">   TerminateAll(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::TerminateAll() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; m_ThreadList.size();i++) &#123; </span><br><span class="line">    CWorkerThread* thr = m_ThreadList[i]; </span><br><span class="line">    thr-&gt;Join(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CWorkerThread* CThreadPool::GetIdleThread(<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(m_IdleList.size() ==<span class="number">0</span> ) </span><br><span class="line">    m_IdleCond.Wait(); </span><br><span class="line">   </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> ) </span><br><span class="line">    &#123; </span><br><span class="line">    CWorkerThread* thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">    <span class="keyword">return</span> thr; </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//add an idle thread to idle list </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::AppendToIdleList(CWorkerThread* jobthread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(jobthread); </span><br><span class="line">    m_ThreadList.push_back(jobthread); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//move and idle thread to busy thread </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToBusyList(CWorkerThread* idlethread) </span><br><span class="line">&#123; </span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    m_BusyList.push_back(idlethread); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line">  </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),idlethread); </span><br><span class="line">    <span class="keyword">if</span>(pos !=m_IdleList.end()) </span><br><span class="line">    m_IdleList.erase(pos); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToIdleList(CWorkerThread* busythread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(busythread); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_BusyList.begin(),m_BusyList.end(),busythread); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_BusyList.end()) </span><br><span class="line">    m_BusyList.erase(pos); </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_IdleCond.Signal(); </span><br><span class="line">    m_MaxNumCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//create num idle thread and put them to idlelist </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::CreateIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::DeleteIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter into CThreadPool::DeleteIdleThreadn"</span>); </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete Num is %dn"</span>,num); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr; </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),thr); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_IdleList.end()) </span><br><span class="line">        m_IdleList.erase(pos); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idle thread available num:%d n"</span>,m_AvailNum); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idlelist              num:%d n"</span>,m_IdleList.size()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadPool::Run(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    assert(job!=<span class="literal">NULL</span>); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//if the busy thread num adds to m_MaxNum,so we should wait </span></span><br><span class="line">    <span class="keyword">if</span>(GetBusyNum() == m_MaxNum) </span><br><span class="line">        m_MaxNumCond.Wait(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size()&lt;m_AvailLow) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">        CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        CreateIdleThread(m_MaxNum-GetAllNum()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    CWorkerThread*  idlethr = GetIdleThread(); </span><br><span class="line">    <span class="keyword">if</span>(idlethr !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">    idlethr-&gt;m_WorkMutex.Lock(); </span><br><span class="line">    MoveToBusyList(idlethr); </span><br><span class="line">    idlethr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    job-&gt;SetWorkThread(idlethr); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Job is set to thread %d n"</span>,idlethr-&gt;GetThreadID()); </span><br><span class="line">    idlethr-&gt;SetJob(job,jobdata); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CThreadPool中存在两个链表，一个是空闲链表，一个是忙碌链表。Idle链表中存放所有的空闲进程，当线程执行任务时候，其状态变为忙碌状态，同时从空闲链表中删除，并移至忙碌链表中。在CThreadPool的构造函数中，我们将执行下面的代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++) </span><br><span class="line">&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该代码中，我们将创建m_InitNum个线程，创建之后即调用AppendToIdleList放入Idle链表中，由于目前没有任务分发给这些线程，因此线程执行Start后将自己挂起。<br>事实上，线程池中容纳的线程数目并不是一成不变的，其会根据执行负载进行自动伸缩。为此在CThreadPool中设定四个变量：<br>m_InitNum：处世创建时线程池中的线程的个数。<br>m_MaxNum:当前线程池中所允许并发存在的线程的最大数目。<br>m_AvailLow:当前线程池中所允许存在的空闲线程的最小数目，如果空闲数目低于该值，表明负载可能过重，此时有必要增加空闲线程池的数目。实现中我们总是将线程调整为m_InitNum个。<br>m_AvailHigh：当前线程池中所允许的空闲的线程的最大数目，如果空闲数目高于该值，表明当前负载可能较轻，此时将删除多余的空闲线程，删除后调整数也为m_InitNum个。<br>m_AvailNum：目前线程池中实际存在的线程的个数，其值介于m_AvailHigh和m_AvailLow之间。如果线程的个数始终维持在m_AvailLow和m_AvailHigh之间，则线程既不需要创建，也不需要删除，保持平衡状态。因此如何设定m_AvailLow和m_AvailHigh的值，使得线程池最大可能的保持平衡态，是线程池设计必须考虑的问题。<br>线程池在接受到新的任务之后，线程池首先要检查是否有足够的空闲池可用。检查分为三个步骤：<br>      (1)检查当前处于忙碌状态的线程是否达到了设定的最大值m_MaxNum，如果达到了，表明目前没有空闲线程可用，而且也不能创建新的线程，因此必须等待直到有线程执行完毕返回到空闲队列中。<br>      (2)如果当前的空闲线程数目小于我们设定的最小的空闲数目m_AvailLow，则我们必须创建新的线程，默认情况下，创建后的线程数目应该为m_InitNum，因此创建的线程数目应该为( 当前空闲线程数与m_InitNum);但是有一种特殊情况必须考虑，就是现有的线程总数加上创建后的线程数可能超过m_MaxNum，因此我们必须对线程的创建区别对待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">         CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         CreateIdleThread(m_MaxNum-GetAllNum());</span><br></pre></td></tr></table></figure>
<p>如果创建后总数不超过m_MaxNum，则创建后的线程为m_InitNum；如果超过了，则只创建( m_MaxNum-当前线程总数 )个。<br>      (3)调用GetIdleThread方法查找空闲线程。如果当前没有空闲线程，则挂起；否则将任务指派给该线程，同时将其移入忙碌队列。<br>当线程执行完毕后，其会调用MoveToIdleList方法移入空闲链表中，其中还调用m_IdleCond.Signal()方法，唤醒GetIdleThread()中可能阻塞的线程。 </p>
<h4 id="CWorkerThread"><a href="#CWorkerThread" class="headerlink" title="CWorkerThread"></a>CWorkerThread</h4><p>CWorkerThread是CThread的派生类，是事实上的工作线程。在CThreadPool的构造函数中，我们创建了一定数量的CWorkerThread。一旦这些线程创建完毕，我们将调用Start()启动该线程。Start方法最终会调用Run方法。Run方法是个无限循环的过程。在没有接受到实际的任务的时候，m_Job为NULL，此时线程将调用Wait方法进行等待，从而处于挂起状态。一旦线程池将具体的任务分发给该线程，其将被唤醒，从而通知线程从挂起的地方继续执行。CWorkerThread的完整定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>:</span><span class="keyword">public</span> CThread </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*  m_ThreadPool; </span><br><span class="line">    CJob*    m_Job; </span><br><span class="line">    <span class="keyword">void</span>*    m_JobData; </span><br><span class="line">   </span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line">    <span class="keyword">bool</span>      m_IsEnd; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CCondition   m_JobCond; </span><br><span class="line">    CThreadMutex m_WorkMutex; </span><br><span class="line">    CWorkerThread(); </span><br><span class="line">    <span class="keyword">virtual</span> ~CWorkerThread(); </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetJob</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function">CJob*   <span class="title">GetJob</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_Job;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetThreadPool</span><span class="params">(CThreadPool* thrpool)</span></span>; </span><br><span class="line">    <span class="function">CThreadPool* <span class="title">GetThreadPool</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadPool;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">CWorkerThread::CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_JobData = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool = <span class="literal">NULL</span>; </span><br><span class="line">    m_IsEnd = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">CWorkerThread::~CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Job) </span><br><span class="line">    <span class="keyword">delete</span> m_Job; </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool != <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">delete</span> m_ThreadPool; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CWorkerThread::Run() </span><br><span class="line">&#123; </span><br><span class="line">    SetThreadState(THREAD_RUNNING); </span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">while</span>(m_Job == <span class="literal">NULL</span>) </span><br><span class="line">        m_JobCond.Wait(); </span><br><span class="line"></span><br><span class="line">    m_Job-&gt;Run(m_JobData); </span><br><span class="line">    m_Job-&gt;SetWorkThread(<span class="literal">NULL</span>); </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool-&gt;MoveToIdleList(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool-&gt;m_IdleList.size() &gt; m_ThreadPool-&gt;GetAvailHighNum()) </span><br><span class="line">    &#123; </span><br><span class="line">m_ThreadPool-&gt;DeleteIdleThread(m_ThreadPool-&gt;m_IdleList.size()-m_T </span><br><span class="line">hreadPool-&gt;GetInitNum()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_WorkMutex.Unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetJob(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_Job = job; </span><br><span class="line">    m_JobData = jobdata; </span><br><span class="line">    job-&gt;SetWorkThread(<span class="keyword">this</span>); </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    m_JobCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetThreadPool(CThreadPool* thrpool) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_ThreadPool = thrpool; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当线程执行任务之前首先必须判断空闲线程的数目是否低于m_AvailLow，如果低于，则必须创建足够的空闲线程，使其数目达到m_InitNum个，然后将调用MoveToBusyList()移出空闲队列，移入忙碌队列。当任务执行完毕后，其又调用MoveToIdleList()移出忙碌队列，移入空闲队列，等待新的任务。<br>      除了Run方法之外，CWorkerThread中另外一个重要的方法就是SetJob，该方法将实际的任务赋值给线程。当没有任何执行任务即m_Job为NULL的时候，线程将调用m_JobCond.Wait进行等待。一旦Job被赋值给线程，其将调用m_JobCond.Signal方法唤醒该线程。由于m_JobCond属于线程内部的变量，每个线程都维持一个m_JobCond，只有得到任务的线程才被唤醒，没有得到任务的将继续等待。无论一个线程何时被唤醒，其都将从等待的地方继续执行m_Job-&gt;Run(m_JobData)，这是线程执行实际任务的地方。<br>      在线程执行给定Job期间，我们必须防止另外一个Job又赋给该线程，因此在赋值之前，通过m_VarMutex进行锁定， Job执行期间，其于的Job将不能关联到该线程；任务执行完毕，我们调用m_VarMutex.Unlock()进行解锁，此时，线程又可以接受新的执行任务。<br>在线程执行任务结束后返回空闲队列前，我们还需要判断当前空闲队列中的线程是否高于m_AvailHigh个。如果超过m_AvailHigh，则必须从其中删除(m_ThreadPool-&gt;m_IdleList.size()-m_ThreadPool-&gt;GetInitNum())个线程，使线程数目保持在m_InitNum个。 </p>
<h4 id="CJob"><a href="#CJob" class="headerlink" title="CJob"></a>CJob</h4><p>CJob类相对简单，其封装了任务的基本的属性和方法，其中最重要的是Run方法，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CJob</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>      m_JobNo;        <span class="comment">//The num was assigned to the job </span></span><br><span class="line">    <span class="keyword">char</span>*    m_JobName;      <span class="comment">//The job name </span></span><br><span class="line">    CThread  *m_pWorkThread;     <span class="comment">//The thread associated with the job </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CJob( <span class="keyword">void</span> ); </span><br><span class="line">    <span class="keyword">virtual</span> ~CJob(); </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetJobNo</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobNo; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobNo</span><span class="params">(<span class="keyword">int</span> jobno)</span></span>&#123; m_JobNo = jobno;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetJobName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobName; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobName</span><span class="params">(<span class="keyword">char</span>* jobname)</span></span>; </span><br><span class="line">    <span class="function">CThread *<span class="title">GetWorkThread</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="keyword">return</span> m_pWorkThread; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetWorkThread</span> <span class="params">( CThread *pWorkThread )</span></span>&#123; </span><br><span class="line">        m_pWorkThread = pWorkThread; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span> <span class="params">( <span class="keyword">void</span> *ptr )</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line">CJob::CJob(<span class="keyword">void</span>) </span><br><span class="line">:m_pWorkThread(<span class="literal">NULL</span>) </span><br><span class="line">,m_JobNo(<span class="number">0</span>) </span><br><span class="line">,m_JobName(<span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">&#125; </span><br><span class="line">CJob::~CJob()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_JobName) </span><br><span class="line">    <span class="built_in">free</span>(m_JobName); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CJob::SetJobName(<span class="keyword">char</span>* jobname) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=m_JobName)    &#123; </span><br><span class="line">        <span class="built_in">free</span>(m_JobName); </span><br><span class="line">        m_JobName = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=jobname)    &#123; </span><br><span class="line">        m_JobName = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(jobname)+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">strcpy</span>(m_JobName,jobname); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池使用示例"><a href="#线程池使用示例" class="headerlink" title="线程池使用示例"></a>线程池使用示例</h3><p>至此我们给出了一个简单的与具体任务无关的线程池框架。使用该框架非常的简单，我们所需要的做的就是派生CJob类，将需要完成的任务实现在Run方法中。然后将该Job交由CThreadManage去执行。下面我们给出一个简单的示例程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CXJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CXJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CXJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CXJOB\n"</span>); </span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CYJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CYJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CYJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CYJob\n"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    CThreadManage* manage = <span class="keyword">new</span> CThreadManage(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        CXJob*   job = <span class="keyword">new</span> CXJob(); </span><br><span class="line">        manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">    CYJob* job = <span class="keyword">new</span> CYJob(); </span><br><span class="line">    manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    manage-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CXJob和CYJob都是从Job类继承而来，其都实现了Run接口。CXJob只是简单的打印一句”The Job comes from CXJob”，CYJob也只打印”The Job comes from CYJob”，然后均休眠2秒钟。在主程序中我们初始创建10个工作线程。然后分别执行40次CXJob和一次CYJob。</p>
<h2 id="C-11线程池"><a href="#C-11线程池" class="headerlink" title="C++11线程池"></a>C++11线程池</h2><p>100行代码，源自 <a href="https://github.com/progschj/ThreadPool" target="_blank" rel="noopener">GitHub</a> .这个线程池的任务要用future获取返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h c++11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadPool(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">enqueue</span>(<span class="title">F</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">        -&gt; <span class="title">std</span>:</span>:future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;;</span><br><span class="line">    ~ThreadPool();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt; <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    <span class="built_in">std</span>::mutex queue_mutex;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">    <span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">size_t</span> threads)</span><br><span class="line">    :   stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.emplace_back(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.wait(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">ThreadPool</span>:</span>:enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">    -&gt; <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line">    <span class="comment">//return_type是函数返回值，return_type()就可以作为packaged_task的模板参数</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//packaged_task可以用bind构造，比如：packaged_task task(bind(f,1));</span></span><br><span class="line">		<span class="comment">//make_shared将函数参数构造为模板类型，并指向构造后的对象。</span></span><br><span class="line">		<span class="comment">//使用shared_ptr的原因是下面lambda表达式将这个task指针传入了tasks队列的Function对象，值传递引用计数+1，等任务被执行后，task才被析构。</span></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt; <span class="built_in">std</span>::packaged_task&lt;return_type()&gt; &gt;(</span><br><span class="line">            <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::future&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"enqueue on stopped ThreadPool"</span>);</span><br><span class="line"></span><br><span class="line">        tasks.emplace([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_one();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_all();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::thread &amp;worker: workers)</span><br><span class="line">        worker.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ThreadPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        results.emplace_back(</span><br><span class="line">            pool.enqueue([i] &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"world "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> i*i;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; result: results)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/20/C-C++/C++Collection/C++algorithm/" class="article-date">
      <time datetime="2019-03-20T07:51:15.000Z" itemprop="datePublished">2019-03-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/C-C++/C++Collection/C++algorithm/">c++algorithm</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="c-算法库"><a href="#c-算法库" class="headerlink" title="c++算法库"></a>c++算法库</h1><h2 id="不修改元素的序列操作"><a href="#不修改元素的序列操作" class="headerlink" title="不修改元素的序列操作"></a>不修改元素的序列操作</h2><p>序列操作的前两个参数都是指向序列首尾的迭代器。</p>
<table>
<thead>
<tr>
<th>all_of(C++11)<br>any_of(C++11)<br>none_of(C++11)</th>
<th>checks if a predicate is true for all, any or none <br>of the elements in a range</th>
</tr>
</thead>
<tbody>
<tr>
<td>for_each</td>
<td>applies a function to a range of elements</td>
</tr>
<tr>
<td>for_each_n(C++17)</td>
<td>applies a function object <strong><em>to the first n elements</em></strong> of a sequence</td>
</tr>
<tr>
<td>count<br>count_if</td>
<td>returns the number of elements satisfying specific criteria</td>
</tr>
<tr>
<td>mismatch</td>
<td>finds the first position where two ranges differ</td>
</tr>
<tr>
<td>find<br>find_if<br>find_if_not(C++11)</td>
<td>finds the first element satisfying specific criteria</td>
</tr>
<tr>
<td>find_end</td>
<td>finds the last sequence of elements in a certain range</td>
</tr>
<tr>
<td>find_first_of</td>
<td>searches for any one of a set of elements<br>在第一个范围内找存在于第二个范围内的任何一个数。</td>
</tr>
<tr>
<td>adjacent_find</td>
<td>finds the first two adjacent items that are equal <br>(or satisfy a given predicate)</td>
</tr>
<tr>
<td>search</td>
<td>searches for a range of elements<br>find是找一个数，search是找一个序列。</td>
</tr>
<tr>
<td>search_n</td>
<td>searches a range for a number of consecutive copies of an element</td>
</tr>
</tbody>
</table>
<h2 id="会修改元素的序列操作"><a href="#会修改元素的序列操作" class="headerlink" title="会修改元素的序列操作"></a>会修改元素的序列操作</h2><table>
<thead>
<tr>
<th>copy<br>copy_if(C++11)</th>
<th>copies a range of elements to a new location</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy_n(C++11)</td>
<td>copies a number of elements to a new location</td>
</tr>
<tr>
<td>copy_backward</td>
<td>copies a range of elements in backwards order</td>
</tr>
<tr>
<td>move(C++11)</td>
<td>moves a range of elements to a new location</td>
</tr>
<tr>
<td>move_backward(C++11)</td>
<td>moves a range of elements to a new location in backwards order</td>
</tr>
<tr>
<td>fill</td>
<td>copy-assigns the given value to every element in a range</td>
</tr>
<tr>
<td>fill_n</td>
<td>copy-assigns the given value to N elements in a range</td>
</tr>
<tr>
<td>transform</td>
<td>applies a function to a range of elements</td>
</tr>
<tr>
<td>generate</td>
<td>assigns the results of successive function calls to every element in a range</td>
</tr>
<tr>
<td>generate_n</td>
<td>assigns the results of successive function calls to N elements in a range</td>
</tr>
<tr>
<td>remove<br>remove_if</td>
<td>removes elements satisfying specific criteria</td>
</tr>
<tr>
<td>remove_copy<br>remove_copy_if</td>
<td>copies a range of elements omitting those that satisfy specific criteria</td>
</tr>
<tr>
<td>replace<br>replace_if</td>
<td>replaces all values satisfying specific criteria with another value</td>
</tr>
<tr>
<td>replace_copy<br>replace_copy_if</td>
<td>copies a range, replacing elements satisfying specific criteria with another value</td>
</tr>
<tr>
<td>swap</td>
<td>swaps the values of two objects</td>
</tr>
<tr>
<td>swap_ranges</td>
<td>swaps two ranges of elements</td>
</tr>
<tr>
<td>iter_swap</td>
<td>swaps the elements pointed to by two iterators</td>
</tr>
<tr>
<td>reverse</td>
<td>reverses the order of elements in a range</td>
</tr>
<tr>
<td>reverse_copy</td>
<td>creates a copy of a range that is reversed</td>
</tr>
<tr>
<td>rotate</td>
<td>rotates the order of elements in a range</td>
</tr>
<tr>
<td>rotate_copy</td>
<td>copies and rotate a range of elements</td>
</tr>
<tr>
<td>shift_left(C++20)<br>shift_right(C++20)</td>
<td>shifts elements in a range</td>
</tr>
<tr>
<td>random_shuffle<br>(until C++17)<br>shuffle(C++11)</td>
<td>randomly re-orders elements in a range</td>
</tr>
<tr>
<td>sample(C++17)</td>
<td>selects n random elements from a sequence</td>
</tr>
<tr>
<td>unique</td>
<td>removes consecutive duplicate elements in a range</td>
</tr>
<tr>
<td>unique_copy</td>
<td>creates a copy of some range of elements that contains no consecutive duplicates</td>
</tr>
</tbody>
</table>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><table>
<thead>
<tr>
<th>is_partitioned(C++11)</th>
<th>determines if the range is partitioned by the given predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition</td>
<td>divides a range of elements into two groups,<br><strong>returns</strong> iterator to the first element of the second group.</td>
</tr>
<tr>
<td>partition_copy(C++11)</td>
<td>copies a range dividing the elements into two groups</td>
</tr>
<tr>
<td>stable_partition</td>
<td>divides elements into two groups while preserving their relative order</td>
</tr>
<tr>
<td>partition_point(C++11)</td>
<td>locates the partition point of a partitioned range</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::partition(v.begin(), v.end(), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"><span class="built_in">std</span>::copy(<span class="built_in">std</span>::begin(v), it, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" * "</span>;</span><br><span class="line"><span class="built_in">std</span>::copy(it,<span class="built_in">std</span>::end(v), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>基于排序的算法，基本上都可以增加一个参数，即比较函数。</p>
<p>需要随机访问迭代器。</p>
<table>
<thead>
<tr>
<th>is_sorted(C++11)</th>
<th>checks whether a range is sorted into ascending order</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_sorted_until(C++11)</td>
<td>finds the largest sorted subrange</td>
</tr>
<tr>
<td>sort</td>
<td>sorts a range into ascending order</td>
</tr>
<tr>
<td>partial_sort</td>
<td>sorts the first N elements of a range</td>
</tr>
<tr>
<td>partial_sort_copy</td>
<td>copies and partially sorts a range of elements</td>
</tr>
<tr>
<td>stable_sort</td>
<td>(稳定排序)sorts a range of elements while preserving order between equal elements</td>
</tr>
<tr>
<td>nth_element</td>
<td>partially sorts the given range making sure that it is partitioned by the given element</td>
</tr>
</tbody>
</table>
<p><strong>partial_sort:</strong></p>
<p>partial_sort(first, middle, last);</p>
<p>其实就是类似<em>用堆找第K大数</em>的方法，先 <code>make_heap(first, middle)</code>，然后不断比较替换堆顶，最后<code>sort_heap(first, heap);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出[first,last)中6个最小的元素，并且排序在[first,middle)，其余部分无序</span></span><br><span class="line">partial_sort(v.begin(), v.begin()+<span class="number">6</span>, v.end());</span><br></pre></td></tr></table></figure>
<p><strong>nth_element:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>
<p>排序后a[n]就是数列中第n+1大的数（下标从0開始计数），a[start,n)中的数肯定不大于a[n,end]中的数。但是a[start,n), a[n,end]内的大小顺序还不一定。<strong>并不返回值。</strong></p>
<p><strong>partial_sort_copy:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partial_sort_copy( InputIt first, InputIt last, RandomIt d_first, RandomIt d_last );</span><br></pre></td></tr></table></figure>
<p>将排序后的内容复制到新的地方。输入输出迭代器范围的一大一小会产生不同效果，见如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v0&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"> </span><br><span class="line">    it = <span class="built_in">std</span>::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writing to the smaller vector in ascending order gives: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : v1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">if</span>(it == v1.end())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The return value is the end iterator\n"</span>;</span><br><span class="line"> </span><br><span class="line">    it = <span class="built_in">std</span>::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(), </span><br><span class="line">                                <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writing to the larger vector in descending order gives: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : v2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"The return value is the iterator to "</span> &lt;&lt; *it &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writing to the smaller vector in ascending order gives: 1 2 3</span><br><span class="line">The return value is the end iterator</span><br><span class="line">Writing to the larger vector in descending order gives: 5 4 3 2 1 15 16</span><br><span class="line">The return value is the iterator to 15</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>前提是已经排序。</strong></p>
<table>
<thead>
<tr>
<th>binary_search</th>
<th>determines if an element exists in a certain range</th>
</tr>
</thead>
<tbody>
<tr>
<td>lower_bound</td>
<td>returns an iterator to the first element <strong><em>not less</em></strong> than the given value</td>
</tr>
<tr>
<td>upper_bound</td>
<td>returns an iterator to the first element <strong><em>greater</em></strong> than a certain value</td>
</tr>
<tr>
<td>equal_range</td>
<td>returns range of elements matching a specific key</td>
</tr>
</tbody>
</table>
<p><strong>equal_range:</strong></p>
<p>试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound），因此，[i,j)内的每个元素都等同于value，而且[i,j)是[first,last)之中符合此一性质的最大子区间。</p>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><table>
<thead>
<tr>
<th>merge</th>
<th>merges two sorted ranges</th>
</tr>
</thead>
<tbody>
<tr>
<td>inplace_merge</td>
<td>merges two ordered ranges in-place</td>
</tr>
</tbody>
</table>
<p><strong>inplace_merge:</strong></p>
<p>Merges two consecutive sorted ranges <code>[first, middle)</code> and <code>[middle, last)</code> into one sorted range <code>[first, last)</code></p>
<p>用inplace_merge<strong>实现归并排序</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge_sort</span>(<span class="title">Iter</span> <span class="title">first</span>, <span class="title">Iter</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (last - first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Iter middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(first, middle);</span><br><span class="line">        merge_sort(middle, last);</span><br><span class="line">        <span class="built_in">std</span>::inplace_merge(first, middle, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">8</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    merge_sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : v) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table>
<thead>
<tr>
<th>includes</th>
<th>returns true if one set is a subset of another</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_difference</td>
<td>computes the difference between two sets</td>
</tr>
<tr>
<td>set_intersection</td>
<td>computes the intersection of two sets</td>
</tr>
<tr>
<td>set_symmetric_difference</td>
<td>computes the symmetric difference between two sets</td>
</tr>
<tr>
<td>set_union</td>
<td>computes the union of two sets</td>
</tr>
</tbody>
</table>
<p><strong>set_开头的函数</strong>的第五个参数是一个输出迭代器，可以用输出容器的插入迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s1&#123;<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s2&#123;<span class="string">"2"</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s3;</span><br><span class="line">	</span><br><span class="line">set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), </span><br><span class="line">               insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt;(s3,s3.begin()));</span><br><span class="line">copy(s3.begin(),s3.end(),ostream_iterator&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line"><span class="comment">//output: 1 3</span></span><br></pre></td></tr></table></figure>
<p><strong>set_symmetric_difference:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>  &#125;;</span><br><span class="line">&#123;  <span class="number">2</span>,    <span class="number">5</span>,    <span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">//set_symmetric_difference</span></span><br><span class="line">&#123;<span class="number">1</span>,  <span class="number">3</span>,<span class="number">4</span>,  <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>排序算法基本默认都是递增的，而堆排序如果要递增排序的话，则是建立最大堆，这就是我理解的默认是建立最大堆而不是最小堆的原因。</p>
<table>
<thead>
<tr>
<th>is_heap(C++11)</th>
<th>checks if the given range is a max heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_heap_until(C++11)</td>
<td>finds the largest subrange that is a max heap</td>
</tr>
<tr>
<td>make_heap</td>
<td>creates a max heap out of a range of elements</td>
</tr>
<tr>
<td>push_heap</td>
<td>inserts the element at the position <code>last-1</code> into the <em>max heap</em></td>
</tr>
<tr>
<td>pop_heap</td>
<td>swaps <code>first</code> and  <code>last-1</code> and makes the subrange <code>[first, last-1)</code> into a <em>max heap</em>.</td>
</tr>
<tr>
<td>sort_heap</td>
<td>turns a max heap into a range of elements sorted in ascending order</td>
</tr>
</tbody>
</table>
<p>example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"initially      : "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::make_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after make_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::pop_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after pop_heap : "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::push_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after push_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::sort_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after sort_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initially      : 3 1 4 1 5 9 </span><br><span class="line">after make_heap: 9 5 4 1 1 3 </span><br><span class="line">after pop_heap : 5 3 4 1 1 9 </span><br><span class="line">after push_heap: 9 3 5 1 1 4 </span><br><span class="line">after sort_heap: 1 1 3 4 5 9</span><br></pre></td></tr></table></figure>
<h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><table>
<thead>
<tr>
<th>max</th>
<th>returns the greater of the given values</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_element</td>
<td>returns the largest element in a range</td>
</tr>
<tr>
<td>min</td>
<td>returns the smaller of the given values</td>
</tr>
<tr>
<td>min_element</td>
<td>returns the smallest element in a range</td>
</tr>
</tbody>
</table>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table>
<thead>
<tr>
<th>equal</th>
<th>determines if two sets of elements are the same</th>
</tr>
</thead>
<tbody>
<tr>
<td>lexicographical_compare</td>
<td>returns true if one range is lexicographically less than another</td>
</tr>
</tbody>
</table>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><table>
<thead>
<tr>
<th>is_permutation(C++11)</th>
<th>determines if a sequence is a permutation of another sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td>next_permutation</td>
<td>generates the next greater lexicographic permutation of a range of elements</td>
</tr>
<tr>
<td>prev_permutation</td>
<td>generates the next smaller lexicographic permutation of a range of elements</td>
</tr>
</tbody>
</table>
<p><strong>next_permutation:</strong></p>
<p>Transforms the range <code>[first, last)</code> into the next permutation from the set of all permutations that are lexicographically ordered with respect to <code>operator&lt;</code> or <code>comp</code>. Returns true if such permutation exists, otherwise transforms the range into the first permutation (as if by <code>std::sort(first, last)</code>) and returns false.</p>
<p><strong>prev_permutation</strong>类似，都是反过来。</p>
<p>example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3,5,4,1,2 is a permutation of 1,2,3,4,5? "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::boolalpha</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::is_permutation(v1.begin(), v1.end(), v2.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3,5,4,1,1 is a permutation of 1,2,3,4,5? "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::boolalpha</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::is_permutation(v1.begin(), v1.end(), v3.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span> is a permutation of <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>? <span class="literal">true</span></span><br><span class="line"><span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span> is a permutation of <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>? <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Unp/unp笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/17/Network/Unp/unp笔记/" class="article-date">
      <time datetime="2019-03-17T07:01:56.000Z" itemprop="datePublished">2019-03-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/17/Network/Unp/unp笔记/">《unp》笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="《unp》笔记"><a href="#《unp》笔记" class="headerlink" title="《unp》笔记"></a>《unp》笔记</h2><p>以前读的《Unix网络编程》，最近整理一下概念性的知识点。</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p><img src="http://118.25.53.128/Picture/Unp/unp01.jpg" alt="unp01"></p>
<p>TCP和UDP之间留有空隙，表明网络应用是可以直接绕过传输层使用IPv4或IPv6的。这就是所谓的原始套接字。</p>
<p>本书所讲的套接字编程是从顶上三层进入传输层的接口。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP特性"><a href="#TCP特性" class="headerlink" title="TCP特性"></a>TCP特性</h4><ul>
<li><p>TCP含有用于动态估算客户和服务器之间的<strong>RTT</strong>的算法，以便知道它等待一个确认需要多少时间。</p>
<ul>
<li>RTT-(round-trip time) 往返时间。RTT在一个局域网上大约是几毫秒，广域网则可能数秒。</li>
</ul>
</li>
<li><p>TCP通过给其中每个字节关联一个<strong>序列号</strong>对所发送的数据进行排序。</p>
<p>接收端可以按顺序重排或丢弃重复。</p>
</li>
<li><p>TCP提供<strong>流量控制</strong></p>
<p>TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为<strong>窗口通告</strong>。</p>
</li>
<li><p>TCP是<strong>全双工</strong>的。</p>
</li>
</ul>
<h4 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h4><p><img src="http://118.25.53.128/Picture/Unp/unp02.jpg" alt="unp02"></p>
<ol>
<li><p>服务器必须准备好接受外来的连接。这称为<strong>被动打开</strong>。</p>
<p>通常需要socket、bind、listen。</p>
</li>
<li><p>客户端通过调用connect发起<strong>主动打开</strong>。</p>
<p>客户端发送一个SYN(同步)分节，它告诉服务器客户将在连接中发送的数据的<strong>初始序列号</strong>。</p>
<p>通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部、可能有的TCP选项。</p>
</li>
<li><p>服务器确认(ACK)客户端的SYN，同时自己也发送一个SYN分节。</p>
</li>
<li><p>客户端确认(ACK)服务器的SYN。</p>
</li>
</ol>
<hr>
<p><strong>PS：</strong>ACK中的确认号是发送这个ACK的一端所期待的下一个序列号。</p>
<p>​    因为SYN分节占据一个字节的序列号空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加1.</p>
<p>​    类似地，每一个FIN的ACK也这样。</p>
<h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4><p>每一个SYN可以含有多个TCP选项。</p>
<ul>
<li><strong>MSS选项</strong>。通告对端它的最大分节大小(maximum segment size)，也就是在本次连接的每个TCP分节中愿意接受的最大数据量。</li>
<li><strong>窗口规模选项</strong>。TCP连接任何一端能够通告对端的最大窗口大小是65535(2^16 -1)，因为在TCP首部中相应的字段占16位。但是当今因特网上有时需要更大的窗口以获得更大的吞吐量。这个新选项指定TCP首部中的通告窗口必须扩大的位数(0~14)。因此所提供的最大窗口接近1GB(<code>65535*2^14</code>)</li>
<li><strong>时间戳选项</strong>。作为网络编程人员无需考虑。</li>
</ul>
<h4 id="TCP连接终止"><a href="#TCP连接终止" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h4><p><img src="http://118.25.53.128/Picture/Unp/unp03.jpg" alt="unp03"></p>
<ol>
<li><strong>主动关闭</strong>。调用close，于是发送一个FIN分节表示数据发送完毕。</li>
<li><strong>被动关闭</strong>。客户端的FIN由TCP确认，它的接收也作为一个文件结束符(EOF，end-of-file)传递给接收端应用进程。</li>
<li>一段时间后，接收到EOF的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。</li>
<li>确认服务器的FIN。</li>
</ol>
<hr>
<p>每个方向都需要一个FIN和一个ACK。<strong>通常</strong>终止一个连接需要4个分节。但是：</p>
<ul>
<li>某些情况下步骤1的FIN随数据一起发送；</li>
<li>步骤2和步骤3发送的分节可能被合并成一个分节。</li>
</ul>
<h4 id="TCP连接的分组交换"><a href="#TCP连接的分组交换" class="headerlink" title="TCP连接的分组交换"></a>TCP连接的分组交换</h4><p><img src="http://118.25.53.128/Picture/Unp/unp04.jpg" alt="unp04"></p>
<ul>
<li>服务器对客户请求的ACK是伴随其数据应答发送的，这种做法称为捎带，它通常在服务器处理请求并应答的时间少于200ms时发生的，如果服务器耗时更长，那么我们将看到先是确认后是应答。</li>
</ul>
<h5 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h5><p>该状态持续2MSL时间。</p>
<p><strong>MSL</strong>是Maximum Segment Lifetime英文的缩写，中文可以译为“<strong>报文最大生存时间</strong>”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>区别于<strong>TTL</strong>：tcp报文（segment）是ip数据报（datagram）的数据部分，而ip头中有一个<strong>TTL</strong>域(time to live)，这个生存时间是由源主机设置初始值，存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<p><strong>为什么要等待2MSL时间？</strong></p>
<ol>
<li><p>可靠地实现TCP全双工连接的终止</p>
<p>主要目的是怕最后一个ACK包对方没收到，那么对方在超时后(1MSL)将重发FIN包，主动关闭端接收到(1MSL)重发的FIN包后可以再发一个ACK应答包。</p>
</li>
<li><p>允许老的重复分节在网络中消逝</p>
<p>我们假设在关闭一个连接，过一段时间后在相同的IP和端口之间建立另一个连接，后一个连接称为前一个连接的<strong>化身</strong>。通过设置2MSL的TIME_WAIT状态，我们就可以确保每次成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消失了。</p>
<p>这个规则存在一个例外：如果到达的SYN的序列号大于前一化身的结束序列号，源自Berkeley的实现将给当前处于TIME_WAIT状态的连接启动新的化身。</p>
</li>
<li><p>在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>客户在调用函数connect之前不必非得调用bind函数。如果需要，内核会确定源IP地址，并选择一个临时端口。</p>
<p>如果是TCP套接字，调用connect将激发三路握手，仅在成功或者出错时返回，返回错误有三种情况：</p>
<ol>
<li><p>若<strong>客户没有收到SYN分节的响应</strong>，则返回<code>ETIMEDOUT</code>错误。</p>
<p>一般的实现无响应等待6s后再发送一个，若仍无响应则等24s发送一个。若等了75s仍未响应，则返回本错误。</p>
</li>
<li><p>若<strong>客户的SYN响应是RST</strong>，则表明服务器在指定端口没有进程在等待连接(也许服务器根本没运行)。</p>
<p>这是一种<em>硬错误</em>，马上返回<code>ECONNREFUSED</code>错误。</p>
</li>
<li><p>若客户发出的SYN在某个路由器上引发了”目的地不可达”ICMP错误，则认为是一种<em>软错误</em>，并按照第一种情况继续发送。若等了75s仍未响应，则把保存的消息(ICMP错误)作为<code>EHOSTUNREACH</code>或<code>ENETUNREACH</code>错误返回给进程。</p>
<p>对于第三种，以下两种情况也是可能的：</p>
<ul>
<li>按照本地系统的转发表，根本没有到达远程系统的路径</li>
<li>connect调用根本不等待就返回</li>
</ul>
</li>
</ol>
<p><strong>注意：如果connect()失败</strong>，必须close该套接字，不可对它再次调用connect。</p>
<h5 id="产生RST的三个条件"><a href="#产生RST的三个条件" class="headerlink" title="产生RST的三个条件"></a>产生RST的三个条件</h5><ol>
<li>目的地为某端口的SYN到达，但是该端口上没有正在监听的服务器。</li>
<li>TCP想取消某个连接。</li>
<li>TCP收到一个根本不存在的连接上的分节。</li>
</ol>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind把一个本地协议地址赋予一个套接字，对于TCP则是IP和端口号的组合。</p>
<p>对于TCP，可以都指定、也可以只指定一个、也可以都不指定。</p>
<ul>
<li>端口号赋0可以让内核选择端口，使用通配地址(INADDR_ANY，也就是0)可以让内核选择地址。</li>
<li>一般服务器要定端口，不定ip；客户端都不需要定。</li>
</ul>
<p>从bind返回的常见错误就是<code>EADDRINUSE</code> 地址已使用。</p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h4><p>listen仅由TCP服务器调用，它做两件事：</p>
<ol>
<li>当socket()创建一个套接字时，它被假设为一个主动套接字，listen()把一个未连接的套接字转化为一个被动套接字。</li>
<li>本函数的第二个参数<em>规定</em>了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列：SYN已收到，正在完成三路握手。SYN_RECD状态。</li>
<li>已完成连接队列：已经完成三路握手。ESTABLISHED状态。</li>
</ul>
<p><img src="Picture/unp05.jpg" alt="unp05"></p>
<p><img src="Picture/unp06.jpg" alt="unp06"></p>
<p>如果三路握手完成，该项就从未完成队列移动到已完成队列队尾。当进程调用accept()时，已完成队列的队头将返回给进程；或者该队列为空，那么进程睡眠等待唤醒。</p>
<p>当一个客户SYN到达时，如果队列是满的，那么TCP就忽略该分节，而不发送RST。因为这么做是暂时的，客户会重发SYN分节。</p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>如果accept成功，那么其返回值是内核生成的全新的描述符（<em>已连接套接字</em>，区别于<em>监听套接字</em>），代表与所返回客户的TCP连接。</p>
<h3 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h3><h4 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h4><p>设置后，如果两小时内在该套接字的任一方向上都没有数据交换，TCP 就会自动给对端发送一个<strong>保持存活探测分节</strong>(keep-alive probe)。这是一个对端必须响应的 TCP 分节，它会导致以下三种情况之一：</p>
<ol>
<li><p>ACK。</p>
</li>
<li><p>RST，返回 <code>ECONNRESET</code> 错误。</p>
</li>
<li><p>没有任何响应，隔一段时间再发送几次，还没有响应则放弃，返回 <code>ETIMEOUT</code> 错误。</p>
<p>然而如果套接字收到一个 ICMP 错误作为某个探测分节的响应，则返回相应的错误。</p>
</li>
</ol>
<h4 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h4><p>可以改变close的行为。</p>
<p>本选项要求在用户进程与内核间传递如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l_onoff;	<span class="comment">// 0 = off, nonzero = on</span></span><br><span class="line">  <span class="keyword">int</span> l_linger;	<span class="comment">// linger time, seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果 <code>l_onoff</code> 为 0，即关闭本选项，TCP 默认设置生效，close 立即返回。</p>
</li>
<li><p>如果 <code>l_onoff</code> 非 0，</p>
<ul>
<li><p><code>l_linger</code> 为 0，TCP 将丢弃套接字发送缓冲区的数据，并发送一个 RST 给对端，没有四次挥手。</p>
</li>
<li><p><code>l_linger</code> 非 0，如果在套接字发送缓冲区仍有数据，那么进程将睡眠，直到：(a)所有数据都发送完且被确认，(b) <code>l_linger</code> 延滞时间到。</p>
<p>如果是因为延滞时间到，那么返回 <code>EWOULDBLOCK</code> 错误。</p>
</li>
</ul>
<p>如果套接字设置了<strong><em>非阻塞</em></strong>，那么它将不等待 <code>close</code> 完成，即使延滞时间非 0 也是如此。</p>
</li>
</ol>
<p><strong>总结来说，当关闭客户端时，可以在以下3个不同的时机返回：</strong></p>
<ol>
<li><code>close</code> 立即返回。</li>
<li><code>close</code> 一直拖延直到接收了对于客户端 FIN 的 ACK 才返回。</li>
<li>后跟一个 read 调用的 写关闭<code>shutdown</code> 一直等到接收了对端的 FIN 才返回。</li>
</ol>
<h4 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h4><p>默认情况下 Nagle 算法是开启的，本选项可以关闭此算法。</p>
<h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><p><strong><em>目的</em></strong>：减少广域网(WAN)上小分组的数目。</p>
<p><strong><em>内容</em></strong>：如果某个给定连接上有待确认数据，那么原本应该作为用户写操作响应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。</p>
<p>这里”小”分组的定义就是小于 MSS 的任何分组，TCP 总是尽可能地发送最大大小的分组。</p>
<h5 id="ACK-延滞算法"><a href="#ACK-延滞算法" class="headerlink" title="ACK 延滞算法"></a>ACK 延滞算法</h5><p>Nagle 算法通常与 ACK 延滞算法联合使用。</p>
<p><strong><em>内容</em></strong>：TCP 在接收到数据后不立即发送 ACK，而是等待一小段时间才发送 ACK。TCP 期待在这一小段时间内自身有数据要发送回对端，被延滞的 ACK 就可以由这些数据捎带，从而省掉一个 TCP 分节。</p>
<h5 id="不适合的情况"><a href="#不适合的情况" class="headerlink" title="不适合的情况"></a>不适合的情况</h5><ul>
<li><p>在快速的<strong><em>局域网</em></strong>上，我们通常不会注意到 Nagle 算法对客户进程的影响，然而在<strong><em>广域网</em></strong>上，小分组所需的确认时间可能长达一秒，本来就有的延迟被 Nagle 算法进一步放大。</p>
</li>
<li><p>对于服务器不在相反方向产生数据以便携带 ACK 的情况，客户可能察觉到明显的延迟。</p>
</li>
<li><p>客户以若干小片数据向服务器发送单个逻辑请求，比如发送一个 4 字节的请求类型后跟 396 字节的请求数据。</p>
<p>如果客户先执行 4 字节的 write 调用，再执行 396 字节的 write 调用，那么第二个写操作的数据将一直等到服务器的 TCP 确认了第一个写操作的 4 字节数据后才由客户的 TCP 发送出去。</p>
<p>如果服务器需要接收到 400 字节才进行操作，此时服务器的 TCP 将延滞该 4 字节的 ACK。</p>
<p>有<strong><em>三种办法修正</em></strong>这类程序：</p>
<ol>
<li>使用 writev 而不是调用两次 write，（首选方法）。</li>
<li>把两次数据复制到单个缓冲区，然后对该缓冲区调用一次 write。</li>
<li>设置 TCP_NODELAY 套接字选项。但是这最不可取，有损网络。</li>
</ol>
</li>
</ul>
<h3 id="Socket-Errno"><a href="#Socket-Errno" class="headerlink" title="Socket Errno"></a>Socket Errno</h3><p><a href="https://blog.csdn.net/huangwei858/article/details/47723613" target="_blank" rel="noopener">https://blog.csdn.net/huangwei858/article/details/47723613</a></p>
<p><a href="https://blog.csdn.net/u010629326/article/details/76021420" target="_blank" rel="noopener">https://blog.csdn.net/u010629326/article/details/76021420</a></p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Algorithm/逆元" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/14/Algorithm/逆元/" class="article-date">
      <time datetime="2019-03-14T12:31:21.000Z" itemprop="datePublished">2019-03-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/Algorithm/逆元/">逆元</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="逆元（inv）"><a href="#逆元（inv）" class="headerlink" title="逆元（inv）"></a>逆元（inv）</h3><h4 id="什么是逆元"><a href="#什么是逆元" class="headerlink" title="什么是逆元"></a>什么是逆元</h4><p>当求解公式：(a/b)%m 时，因b可能会过大，会出现爆精度的情况，所以需变除法为乘法：</p>
<p>设c是b的逆元，则有<code>b*c≡1(mod m)</code>；</p>
<p>则<code>(a/b)%m = (a/b)*1%m = (a/b)*b*c%m = a*c(mod m)</code>;</p>
<p>即a/b的模等于a*c的模；</p>
<h4 id="求逆元的方法"><a href="#求逆元的方法" class="headerlink" title="求逆元的方法"></a>求逆元的方法</h4><h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h5><p>当p为质数时候，<code>a^(p-1)≡1(mod p)</code></p>
<p>所以 <code>a^(p-2)</code> 是 a 的逆元</p>
<p>复杂度O(logn)。</p>
<p>例子 p=1000000007</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ret * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickpow(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阶乘的逆元"><a href="#阶乘的逆元" class="headerlink" title="阶乘的逆元"></a>阶乘的逆元</h4><p>记数字 x 的逆元为f(x)</p>
<p>因为 <code>n! = (n-1)! * n</code></p>
<p>所以 <code>f(n!) = f( (n-1)! * n) = f( (n-1)! ) * f(n)</code></p>
<p>所以 <code>f( (n-1)! ) = f(n!) * n</code>  (逆元的逆元就是他自身)</p>
<p>这样子我们就可以用后项推出前面的项了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘</span></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">    fac[i] = (fac[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line"><span class="comment">//逆元</span></span><br><span class="line">inv[MAXN<span class="number">-1</span>] = quickpow(fac[MAXN<span class="number">-1</span>], MOD<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXN<span class="number">-2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    inv[i] = (inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++线程库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/14/C-C++/C++Collection/C++线程库/" class="article-date">
      <time datetime="2019-03-14T07:35:04.000Z" itemprop="datePublished">2019-03-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/C-C++/C++Collection/C++线程库/">C++线程库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="C-11线程库"><a href="#C-11线程库" class="headerlink" title="C++11线程库"></a>C++11线程库</h1><p>线程相关库整体上分为几大块：线程类，锁类（以及锁的管理类），条件变量类，future类</p>
<p>锁有互斥锁、定时锁、递归锁、读写锁。</p>
<p>本篇学习自官方文档，所以中英穿插。</p>
<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><h3 id="thread类-C-11"><a href="#thread类-C-11" class="headerlink" title="thread类(C++11)"></a>thread类(C++11)</h3><p>Defined in header <code>&lt;thread&gt;</code></p>
<p>No two <code>std::thread</code> objects may represent the same thread of execution; <code>std::thread</code> is not <em>CopyConstructible</em> or <em>CopyAssignable</em>, although it is <em>MoveConstructible</em> and <em>MoveAssignable</em>.</p>
<h4 id="thread-id类"><a href="#thread-id类" class="headerlink" title="thread::id类"></a>thread::id类</h4><p>The class <code>thread::id</code> is a lightweight, trivially copyable class that serves as a unique identifier of <code>std::thread</code> objects.</p>
<p>只定义了 比较运算符 和 输出用的&lt;&lt;运算符。线程用<code>get_id()</code>可获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread::id t1_id = t1.get_id();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1's id: "</span> &lt;&lt; t1_id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">t1.join();</span><br></pre></td></tr></table></figure>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates new thread object which does not represent a thread.</span></span><br><span class="line">thread() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Move constructor</span></span><br><span class="line">thread( thread&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constructor 3</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">explicit</span> <span class="title">thread</span>( <span class="title">Function</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The copy constructor is deleted; threads are not copyable. </span></span><br><span class="line">thread(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p><strong>//constructor 3</strong></p>
<p>Creates new <code>std::thread</code> object and associates it with a thread of execution. The new thread of execution starts executing </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::invoke(decay_copy(<span class="built_in">std</span>::forward&lt;Function&gt;(f)), </span><br><span class="line">            decay_copy(<span class="built_in">std</span>::forward&lt;Args&gt;(args))...);</span><br></pre></td></tr></table></figure>
<p>where <code>decay_copy</code> is defined as </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="keyword">decay_t</span>&lt;T&gt; decay_copy(T&amp;&amp; v) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(v); &#125;</span><br></pre></td></tr></table></figure>
<p>注意，假如是按值传递对象参数，那么传递给thread的参数时第一次拷贝，decay_copy时候再拷贝一次，接下来如果线程函数的参数是引用，则不再拷贝，如果线程函数的参数是值，那么再拷贝一次。</p>
<p>所以一共会进行2次或3次的拷贝。</p>
<p>如果想传递引用，只能用<code>std::ref</code>。</p>
<p><strong>example</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br></pre></td></tr></table></figure>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread::<span class="function">id <span class="title">get_id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the implementation defined underlying thread handle.</span></span><br><span class="line"><span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//Returns the number of concurrent threads supported by the implementation. The value should be considered only a hint.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hardware_concurrency</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong></p>
<p><strong>线程ID</strong>: 唯一标识线程</p>
<p><strong>线程句柄</strong>: 基本上，所有操作线程的windowsAPI均使用线程句柄。每多一个句柄，线程对象就多一个引用计数，当引用计数为0时，线程对象将被系统回收。<em>一个线程对象可以有很多个句柄指向它</em>。</p>
<h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Blocks the current thread until the thread identified by *this finishes its execution.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.</span></span><br><span class="line"><span class="comment">//join()函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swaps two thread objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( thread&amp; other )</span></span>;</span><br></pre></td></tr></table></figure>
<p>去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，要么join()函数被调用（并结束），要么detach()函数被调用。<strong>如果一个C++线程对象当销毁时仍然可以被join，异常会被抛出。</strong></p>
<p><strong>在<code>std::thread</code>的析构函数中，<code>std::terminate</code>会被调用如果线程没有join或者detach。!!!</strong></p>
<hr>
<p>当一个程序终止时（比如main返回），剩下的在后台的detached线程执行不会再等待；相反它们的执行会被挂起并且它们的本地线程对象会被销毁。</p>
<p>关键地，这意味着这些线程的栈不是完好无损的，因此一些析构函数不会被执行。所以：</p>
<ul>
<li><p>请使用 join</p>
</li>
<li><p>除非你需要更灵活并且想要独立地提供一种同步机制来等待线程完成，在这种情况下你应该使用detach</p>
</li>
</ul>
<h3 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread::"></a>this_thread::</h3><p>Defined in namespace <code>std::this_thread</code></p>
<table>
<thead>
<tr>
<th>yield()</th>
<th>suggests that the implementation reschedule execution of threads</th>
</tr>
</thead>
<tbody>
<tr>
<td>get_id()</td>
<td>returns the thread id of the current thread</td>
</tr>
<tr>
<td>sleep_for()</td>
<td>stops the execution of the current thread for a specified time duration</td>
</tr>
<tr>
<td>sleep_until()</td>
<td>stops the execution of the current thread until a specified time point</td>
</tr>
</tbody>
</table>
<p><strong>yield()：</strong></p>
<p>对具体实现（<strong>译注</strong>：具体实现指的是操作系统的调度器）提出一个提醒以重新规划线程的执行，即让其他线程先运行。</p>
<p>该方法的具体行为取决于实现，尤其是正在使用的操作系统调度器的机制以及系统的状态。比如，一个先进先出的实时调度器（Linux中的SCHED_FIFO）将会使当前线程暂停，并将其置于同优先级线程队列的末尾（如果同优先级线程队列里没有其他线程，yield就没有效果了。）</p>
<p><strong>sleep_for()：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::this_thread::sleep_for;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line">sleep_for(<span class="number">2</span>s);</span><br></pre></td></tr></table></figure>
<h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><ul>
<li>The storage for the object is allocated when the thread begins and deallocated when the thread ends. </li>
<li>Each thread has its own instance of the object. </li>
<li><code>thread_local</code> can appear together with <code>static</code> or <code>extern</code> to adjust linkage.</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><strong>多线程下的volatile</strong>   </p>
<p>当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</p>
<p>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。</p>
<p>volatile的意思是<strong>让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值</strong>。</p>
<h2 id="Mutual-exclusion"><a href="#Mutual-exclusion" class="headerlink" title="Mutual exclusion"></a>Mutual exclusion</h2><p>有互斥锁、定时锁、递归锁、读写锁。</p>
<h3 id="lt-mutex-gt"><a href="#lt-mutex-gt" class="headerlink" title="&lt;mutex&gt;"></a><code>&lt;mutex&gt;</code></h3><p>Defined in header <code>&lt;mutex&gt;</code></p>
<p>Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.</p>
<h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex m;	<span class="comment">//construct</span></span><br><span class="line">m.lock();	<span class="comment">//locks the mutex, blocks if the mutex is not available</span></span><br><span class="line">m.unlock();	<span class="comment">//unlock</span></span><br><span class="line">m.try_lock();	<span class="comment">//tries to lock the mutex, returns true if the lock was acquired successfully, otherwise false.</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes</strong></p>
<ul>
<li><p>mutex is not copy-assignable </p>
</li>
<li><p>If <code>lock()</code> is called by a thread that already owns the <code>mutex</code>, the behavior is undefined.</p>
</li>
<li><p><code>std::mutex</code> is usually not accessed directly: std::unique_lock, std::lock_guard, or std::scoped_lock (since C++17) manage locking in a more exception-safe manner.</p>
</li>
</ul>
<h4 id="timed-mutex"><a href="#timed-mutex" class="headerlink" title="timed_mutex"></a>timed_mutex</h4><p>多了两个方法：<code>try_lock_for</code> 和 <code>try_lock_until</code>，介绍一下前者，后者类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">try_lock_for</span>( <span class="title">const</span> <span class="title">std</span>:</span>:chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Tries to lock the mutex. Blocks until specified <code>timeout_duration</code> has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. </p>
</li>
<li><p>If <code>timeout_duration</code> is less or equal <code>timeout_duration.zero()</code>, the function behaves like try_lock().</p>
</li>
</ul>
<h4 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h4><p>比起 mutex，没有新增成员方法。</p>
<p><strong>递归锁</strong>：同一个线程可以多次获得该资源锁，别的线程必须等该线程释放所有次数的锁才可以获得。</p>
<p><strong>递归锁的作用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">recursive_mutex mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    foo();</span><br><span class="line">    mutex.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo函数和bar函数都获取了同一个锁，而bar函数又会调用foo函数。如果MutexLock锁是个非递归锁，则这个程序会立即死锁。因此在为一段程序加锁时要格外小心，否则很容易因为这种调用关系而造成死锁。 </p>
<p><strong>但不建议使用</strong></p>
<p>递归锁用起来固然简单，但往往会隐藏某些代码问题。因此在能使用非递归锁的情况下，应该尽量使用非递归锁，因为死锁相对来说，更容易通过调试发现。程序设计如果有问题，应该暴露的越早越好。</p>
<h4 id="recursive-timed-mutex"><a href="#recursive-timed-mutex" class="headerlink" title="recursive_timed_mutex"></a>recursive_timed_mutex</h4><p>顾名思义，无需解释。</p>
<h3 id="lt-shared-mutex-gt"><a href="#lt-shared-mutex-gt" class="headerlink" title="&lt;shared_mutex&gt;"></a><code>&lt;shared_mutex&gt;</code></h3><p>即读写锁</p>
<h4 id="shared-mutex"><a href="#shared-mutex" class="headerlink" title="shared_mutex"></a>shared_mutex</h4><p>In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:</p>
<ul>
<li><p><em>shared</em> - several threads can share ownership of the same mutex.</p>
</li>
<li><p><em>exclusive</em> - only one thread can own the mutex.</p>
</li>
</ul>
<p>Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.</p>
<p>分为写锁定和读锁定：</p>
<ul>
<li><p>Exclusive locking</p>
<p><code>lock()</code>、<code>try_lock()</code>、<code>unlock()</code></p>
</li>
<li><p>Shared locking</p>
<p><code>lock_shared()</code>、<code>try_lock_shared()</code>、<code>unlock_shared()</code></p>
</li>
</ul>
<h4 id="shared-timed-mutex"><a href="#shared-timed-mutex" class="headerlink" title="shared_timed_mutex"></a>shared_timed_mutex</h4><p>类似的，加了四个方法：</p>
<p><code>try_lock_for()</code>、<code>try_lock_until()</code></p>
<p><code>try_lock_shared_for()</code>、<code>try_lock_shared_until()</code></p>
<h3 id="management"><a href="#management" class="headerlink" title="management"></a>management</h3><p>Defined in header <code>&lt;mutex&gt;</code></p>
<p>这些管理对象只有构造函数和析构函数。</p>
<p>构造时传入mutex对象，并且试图调用静态方法<code>lock()</code>（有重载），当管理对象离开它的作用域时会被析构，析构时会调用静态方法<code>unlock()</code>。</p>
<h4 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h4><p>最基本的。构造函数只能接受一个mutex。</p>
<h4 id="scoped-lock-C-17"><a href="#scoped-lock-C-17" class="headerlink" title="scoped_lock(C++17)"></a>scoped_lock(C++17)</h4><p>deadlock-avoiding RAII wrapper for multiple mutexes.</p>
<p>据stackoverflow上所说，<code>boost::mutex::scoped_lock</code> is a typedef for <code>boost::unique_lock&lt;boost::mutex&gt;</code>。</p>
<p>其实就是实现RAII语义的包装类，没什么特点。</p>
<p><em>和 lock_guard 比，它的构造函数使用了可变参数模板，可以接受多个mutex。</em></p>
<h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><h4 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h4><p>这两个一起讲，因为它们的<em>方法名</em>都一样，比起上面两个管理器：</p>
<ul>
<li><p>多了<code>swap()</code> 和 <code>release()</code>，（参考智能指针）所以<em>可以移动所有权</em>。（注意，移动的时候mutex仍然是锁住的）。</p>
</li>
<li><p>拥有 <code>timed_mutex</code> 所拥有的所有方法名。</p>
</li>
<li><p>多了两个observer：</p>
<p><code>mutex()</code> 返回指向关联的 mutex 的指针。</p>
<p><code>owns_lock()</code> 返回bool值，表明是否拥有锁住的 mutex。</p>
<p>该类同时还有个bool的类型转化函数，就是调用的 <code>owns_lock()</code>。</p>
</li>
</ul>
<hr>
<p>它们俩的<strong>区别</strong>，简单的说就是读写锁的读写操作：</p>
<p>shared_lock是read lock。被锁后仍允许其他线程执行同样被shared_lock的代码。这是一般做读操作时的需要。</p>
<p>unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。在写操作时，一般用这个，可以同时限制unique_lock的写和share_lock的读。</p>
<hr>
<h4 id="tag-type"><a href="#tag-type" class="headerlink" title="tag type"></a>tag type</h4><p><code>unique_lock</code> 和 <code>shared_lock</code> 的构造函数可以有第二个参数，即标签类型，代表不同的含义：</p>
<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Effect(s)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>defer_lock_t</td>
<td>do not acquire ownership of the mutex</td>
</tr>
<tr>
<td>try_to_lock_t</td>
<td>try to acquire ownership of the mutex without blocking</td>
</tr>
<tr>
<td>adopt_lock_t</td>
<td>assume the calling thread already has ownership of the mutex</td>
</tr>
</tbody>
</table>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once()"></a>call_once()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Callable</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span>( <span class="title">std</span>:</span>:once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>
<p>Executes the <em>Callable</em> object <code>f</code> exactly once, even if called concurrently, from several threads.</p>
<p><code>std::once_flag</code> is neither copyable nor movable.</p>
<p> call_once保证函数 <code>f</code>只被执行一次，如果有多个线程同时执行函数<code>f</code>调用，则只有一个活动线程(active call)会执行函数，其他的线程在这个线程执行返回之前会处于”passive execution”(被动执行状态)——不会直接返回，直到活动线程对fn调用结束才返回。对于所有调用函数fn的并发线程，数据可见性都是同步的(一致的)。</p>
<p>如果活动线程在执行 <code>f</code> 时抛出异常，则会从处于”passive execution”状态的线程中挑一个线程成为活动线程继续执行 <code>f</code>，依此类推。一旦活动线程返回，所有”passive execution”状态的线程也返回,不会成为活动线程。(实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::once_flag flag1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag1, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.join();</span><br><span class="line">    st2.join();</span><br><span class="line">&#125;<span class="comment">//只输出一次</span></span><br></pre></td></tr></table></figure>
<h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>Defined in header <code>&lt;condition_variable&gt;</code></p>
<p>只有两个条件变量：</p>
<ul>
<li><code>condition_variable</code> 只能用于 <code>std::unique_lock</code></li>
<li><code>condition_variable_any</code>：可以用于任意的锁</li>
</ul>
<p>只有两种方法：</p>
<ol>
<li><p>提醒别的线程我好了</p>
<p><code>notify_one()</code> 和  <code>notify_all()</code></p>
</li>
<li><p>解开作为参数的锁并且一直阻塞直到别的线程发送提醒（或到达指定的时间），然后重新获得锁。</p>
<p><code>wait()</code> 、 <code>wait_for()</code> 、 <code>wait_until()</code></p>
<p>详细讲一下 <code>wait()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;					<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>Atomically <strong>unlocks lock</strong>, <strong>blocks the current executing thread</strong>, and <strong>adds it to the list of threads waiting on <code>*this</code></strong>. The thread will <strong>be unblocked when <code>notify_all()</code> or <code>notify_one()</code> is executed</strong>. It may also be unblocked spuriously. <strong>When unblocked, regardless of the reason, lock is reacquired and wait exits</strong>.</p>
</li>
<li><p>Equivalent to<code>while (!pred()) { wait(lock);}</code> </p>
<p>所以如果 <code>pred()</code> 一开始就不为0，那根本就不用等待.</p>
<p>This overload may <strong>be used to ignore spurious awakenings</strong> while waiting for a specific condition to become true.</p>
<p><strong>Note that</strong> <code>lock</code> must be acquired before entering this method, and it is reacquired after </p>
<p><code>wait(lock)</code> exits, which means that <code>lock</code> can be used to guard access to <code>pred()</code>.</p>
</li>
</ol>
</li>
</ol>
<p><strong>Notes：</strong></p>
<p>Calling this function if lock.mutex() is not locked by the current thread is undefined behavior.</p>
<p>Calling this function if lock.mutex() is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</p>
<p>直接看例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Wait until main() sends data</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> ready;&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// after the wait, we own the lock.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread is processing data\n"</span>;</span><br><span class="line">    data += <span class="string">" after processing"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Send data back to main()</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread signals data processing completed\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Manual unlocking is done before notifying, to avoid waking up</span></span><br><span class="line">    <span class="comment">// the waiting thread only to block again (see notify_one for details)</span></span><br><span class="line">    lk.unlock();</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"> </span><br><span class="line">    data = <span class="string">"Example data"</span>;</span><br><span class="line">    <span class="comment">// send data to the worker thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main() signals data ready for processing\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_one();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// wait for the worker</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">        cv.wait(lk, []&#123;<span class="keyword">return</span> processed;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Back in main(), data = "</span> &lt;&lt; data &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    worker.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() signals data ready for processing</span><br><span class="line">Worker thread is processing data</span><br><span class="line">Worker thread signals data processing completed</span><br><span class="line">Back in main(), data = Example data after processing</span><br></pre></td></tr></table></figure>
<h3 id="cv-status"><a href="#cv-status" class="headerlink" title="cv_status"></a>cv_status</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">cv_status</span> &#123;</span></span><br><span class="line">    no_timeout,</span><br><span class="line">    timeout   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::cv_status</code> is used by the <code>wait_for</code> and <code>wait_until</code> methods.</p>
<table>
<thead>
<tr>
<th><code>no_timeout</code></th>
<th>the condition variable was awakened with <code>notify_all</code>, <code>notify_one</code>, or spuriously</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>timeout</code></td>
<td>the condition variable was awakened by timeout expiration</td>
</tr>
</tbody>
</table>
<h3 id="notify-all-at-thread-exit"><a href="#notify-all-at-thread-exit" class="headerlink" title="notify_all_at_thread_exit"></a>notify_all_at_thread_exit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">( <span class="built_in">std</span>::condition_variable&amp; cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk )</span></span>;</span><br></pre></td></tr></table></figure>
<p>It provides a mechanism to notify other threads that a given thread has completely finished, including destroying all <code>thread_local</code> objects. <strong>It operates as follows:</strong></p>
<ol>
<li>destroy thread_locals;</li>
<li>unlock mutex;</li>
<li>notify cv.</li>
</ol>
<ul>
<li><p>Ownership of the previously acquired lock <code>lk</code> is transferred to internal storage.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::notify_all_at_thread_exit(cv, <span class="built_in">std</span>::move(lk));</span><br></pre></td></tr></table></figure>
</li>
<li><p>The execution environment is modified such that when the current thread exits, the condition variable <code>cond</code> is notified as if by:</p>
<ul>
<li>lk.unlock();</li>
<li>cond.notify_all();</li>
</ul>
</li>
</ul>
<p>An equivalent effect may be achieved with the facilities provided by std::promise or std::packaged_task.</p>
<h2 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h2><p>Defined in header <code>&lt;future&gt;</code></p>
<hr>
<p>这个库提供异步任务（比如函数被分发到不同的线程）的返回值获取和异常捕获。</p>
<p>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a <em>shared state</em>, in which the asynchronous task may write its return value or store an exception, and which may be examined, waited for, and otherwise manipulated by other threads that hold instances of <code>std::future</code> or <code>std::shared_future</code> that reference that shared state.</p>
<hr>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://118.25.53.128/Picture/C_C++/promise01.png" alt="promise01"></p>
<p><strong>来个直观的例子</strong>：</p>
<p>This example shows how <code>promise&lt;int&gt;</code> can be used as signals between threads.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.set_value(sum);  <span class="comment">// Notify future</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; barrier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    barrier.set_value();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; accumulate_future = accumulate_promise.get_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::move(accumulate_promise))</span></span>;</span><br><span class="line">    accumulate_future.wait();  <span class="comment">// wait for result</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result="</span> &lt;&lt; accumulate_future.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    work_thread.join();  <span class="comment">// wait for thread completion</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;void&gt; to signal state between threads.</span></span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; barrier;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt; barrier_future = barrier.get_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">new_work_thread</span><span class="params">(do_work, <span class="built_in">std</span>::move(barrier))</span></span>;</span><br><span class="line">    barrier_future.wait();</span><br><span class="line">    new_work_thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>std::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p>
<p>一个有效(valid)的 std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联。Provider 可以是函数或者类，其实我们前面都已经提到了，他们分别是：</p>
<ul>
<li>std::async 函数。</li>
<li>std::promise::get_future，get_future 为 promise 类的成员函数。</li>
<li>std::packaged_task::get_future，此时 get_future为 packaged_task 的成员函数。</li>
</ul>
<p>一个 std::future 对象只有在有效(valid)的情况下才有用(useful)，由 std::future 默认构造函数创建的 future 对象不是有效的（除非当前非有效的 future 对象被 move 赋值另一个有效的 future 对象）。</p>
<p>在一个有效的 future 对象上调用 get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值或异常（此时共享状态的标志变为 ready），std::future::get 将返回异步任务的值或异常（如果发生了异常）。</p>
<hr>
<p><strong>Member Function</strong></p>
<ul>
<li><p><code>share()</code></p>
<p>返回一个 std::shared_future 对象（本文后续内容将介绍 std::shared_future ），调用该函数之后，该 std::future 对象本身已经不和任何共享状态相关联，因此该 std::future 的状态不再是 valid 的了。</p>
</li>
<li><p><code>get()</code>  get 返回 Provider 所设置的共享状态的值或者异常。如果共享状态的标志不为 ready，则调用该函数会阻塞当前的调用者，而此后一旦共享状态的标志变为 ready，get 返回。</p>
</li>
<li><p><code>valid()</code>  检查当前的 std::future 对象是否有效，即是否与某个共享状态相关联。</p>
</li>
<li><p><code>wait()</code>  等待与当前std::future 对象相关联的共享状态的标志变为 ready.</p>
</li>
<li><p><code>wait_for()</code>  时间点过后如果没ready，则直接阻塞当前线程。</p>
</li>
<li><p><code>wait_until()</code></p>
</li>
</ul>
<h4 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h4><p>std::shared_future 与 std::future 类似，但是 std::shared_future 可以拷贝、多个 std::shared_future 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。shared_future 可以通过某个 std::future 对象隐式转换（构造函数），或者通过 std::future::share() 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid.</p>
<p>成员函数和 std::future 基本相同。</p>
<h4 id="future-error"><a href="#future-error" class="headerlink" title="future_error"></a>future_error</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">future_error</span> :</span> <span class="keyword">public</span> logic_error;</span><br></pre></td></tr></table></figure>
<h4 id="future-errc"><a href="#future-errc" class="headerlink" title="future_errc"></a>future_errc</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_errc</span> &#123;</span></span><br><span class="line">    broken_promise             = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    future_already_retrieved   = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    promise_already_satisfied  = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    no_state                   = <span class="comment">/* implementation-defined */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="future-status"><a href="#future-status" class="headerlink" title="future_status"></a>future_status</h4><p>Specifies state of a future as returned by <code>wait_for</code> and <code>wait_until</code> functions of std::future and std::shared_future.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_status</span> &#123;</span></span><br><span class="line">    ready,</span><br><span class="line">    timeout,</span><br><span class="line">    deferred</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>deferred</code></td>
<td>the shared state contains a deferred function, so the result will be computed only when explicitly requested</td>
</tr>
<tr>
<td><code>ready</code></td>
<td>the shared state is ready</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>the shared state did not become ready before specified timeout duration has passed</td>
</tr>
</tbody>
</table>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span> &gt; <span class="title">class</span> <span class="title">promise</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span> &gt; <span class="title">class</span> <span class="title">promise</span>&lt;R&amp;&gt;;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="class"><span class="keyword">class</span> <span class="title">promise</span>&lt;void&gt;;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>base template</li>
<li>non-void specialization, used to communicate objects between threads</li>
<li>void specialization, used to communicate stateless events</li>
</ol>
<hr>
<p><strong>Member functions</strong></p>
<table>
<thead>
<tr>
<th>functions</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>operator=</td>
<td>只有移动赋值，没有拷贝赋值。First, abandons the shared state (as in ~promise()), then assigns the shared state of <code>other</code> as if by executing <code>std::promise(std::move(other)).swap(*this)</code>.</td>
</tr>
<tr>
<td>swap</td>
<td>swaps two promise objects</td>
</tr>
<tr>
<td>get_future</td>
<td>returns a <code>future</code> associated with the promised result</td>
</tr>
<tr>
<td>set_value</td>
<td>sets the result to specific value</td>
</tr>
<tr>
<td>set_value_at_thread_exit</td>
<td>sets only at thread exit</td>
</tr>
<tr>
<td>set_exception( p )</td>
<td>p is exception pointer to store. The behavior is undefined if <code>p</code> is null.</td>
</tr>
<tr>
<td>set_exception_at_thread_exit</td>
<td>sets only at thread exit</td>
</tr>
</tbody>
</table>
<p><strong>set_exception的例子</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = p.get_future();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([&amp;p]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// code that may throw</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Example"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125; <span class="keyword">catch</span>(...) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// store anything thrown in the promise</span></span></span></span><br><span class="line"><span class="function"><span class="params">                p.set_exception(<span class="built_in">std</span>::current_exception());</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125; <span class="keyword">catch</span>(...) &#123;&#125; <span class="comment">// set_exception() may throw too</span></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception from the thread: "</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><p>std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，从包装可调用对象意义上来讲，std::packaged_task 与 std::function 类似（可参照），只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。</p>
<p>std::packaged_task 对象内部包含了两个最基本元素：</p>
<ol>
<li>被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象，</li>
<li>共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果。</li>
</ol>
<p><strong>构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> ...<span class="title">Args</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">packaged_task</span>&lt;R(Args...)&gt;;</span></span><br></pre></td></tr></table></figure>
<p><strong>成员方法：</strong></p>
<ul>
<li><p><code>valid()</code>  checks if the task object has a valid function.</p>
</li>
<li><p><code>swap()</code></p>
</li>
<li><p><code>get_future()</code>  returns a <code>std::future</code> associated with the promised result </p>
</li>
<li><p><code>void operator()( ArgTypes... args );</code></p>
<p>Calls the stored task with <code>args</code> as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</p>
</li>
<li><p><code>void make_ready_at_thread_exit( ArgTypes... args );</code></p>
<p>和 <code>operator()</code> 一样，但是 The shared state is only made ready after the current thread exits and all objects of <em>thread local</em> storage duration are destroyed.</p>
</li>
<li><p><code>reset()</code>  </p>
<p>Resets the state abandoning the results of previous executions. New shared state is constructed.</p>
<p>Equivalent to <code>*this = packaged_task(std::move(f))</code>, where <code>f</code> is the stored task.</p>
</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// unique function to avoid disambiguating the std::pow overload set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(x,y); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(a, b); </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_lambda:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task(<span class="built_in">std</span>::bind(f, <span class="number">2</span>, <span class="number">11</span>));</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_bind:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(f);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">task_td</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="number">2</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    task_td.join();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_thread:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_lambda();</span><br><span class="line">    task_bind();</span><br><span class="line">    task_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>大致上有两类函数原型（省略模板声明部分）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">future <span class="title">async</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">future <span class="title">async</span><span class="params">( <span class="built_in">std</span>::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>std::async() 的 fn 和 args 参数用来指定异步任务及其参数。另外，std::async() 返回一个 std::future 对象，通过该对象可以获取异步任务的值或异常（如果异步任务抛出了异常）。</p>
</li>
<li><p>第二类函数指定了启动策略。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::launch::async</td>
<td>a new thread is launched to execute the task asynchronously</td>
</tr>
<tr>
<td>std::launch::deferred</td>
<td>the task is executed on the calling thread the first time its result is requested (lazy evaluation)</td>
</tr>
</tbody>
</table>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parallel_sum</span><span class="params">(RandomIt beg, RandomIt end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(beg, end, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    RandomIt mid = beg + len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,</span><br><span class="line">                             parallel_sum&lt;RandomIt&gt;, mid, end);</span><br><span class="line">    <span class="keyword">int</span> sum = parallel_sum(beg, mid);</span><br><span class="line">    <span class="keyword">return</span> sum + handle.get();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is "</span> &lt;&lt; parallel_sum(v.begin(), v.end()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fin"><a href="#fin" class="headerlink" title="fin"></a>fin</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++chrono时间库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/13/C-C++/C++Collection/C++chrono时间库/" class="article-date">
      <time datetime="2019-03-13T11:20:05.000Z" itemprop="datePublished">2019-03-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/C-C++/C++Collection/C++chrono时间库/">C++chrono时间库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="时间库chrono（简述）"><a href="#时间库chrono（简述）" class="headerlink" title="时间库chrono（简述）"></a>时间库chrono（简述）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br></pre></td></tr></table></figure>
<h4 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h4><p><code>std::chrono::duration</code> 表示一段时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> = <span class="title">ratio</span>&lt;1&gt; &gt; <span class="title">class</span> <span class="title">duration</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Rep表示一种数值类型，用来表示Period的数量，比如int float double</p>
<p>常用的duration&lt;Rep,Period&gt;已经定义好了，在std::chrono::duration下：</p>
<p>ratio&lt;3600, 1&gt;                hours</p>
<p>ratio&lt;60, 1&gt;                    minutes</p>
<p>ratio&lt;1, 1&gt;                      seconds</p>
<p>ratio&lt;1, 1000&gt;               microseconds</p>
<p>ratio&lt;1, 1000000&gt;         microseconds</p>
<p>ratio&lt;1, 1000000000&gt;    nanosecons</p>
<ul>
<li><p>在<code>std::chrono::chrono_literals</code>名称空间下，还定义了<strong>用户字面常量</strong>，只举两个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span><span class="string">""</span>h</span><br><span class="line"><span class="keyword">operator</span><span class="string">""</span>s</span><br></pre></td></tr></table></figure>
<p>所以可以直接使用 “1s” 来表示一秒的时间。</p>
</li>
</ul>
</li>
<li><p>Period是ratio类型，用来表示【用秒表示的时间单位】比如second milisecond</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">intmax_t</span> N, <span class="keyword">intmax_t</span> D = <span class="number">1</span>&gt; class ratio;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>N代表分子，D代表分母，所以ratio表示一个分数值。</p>
<p>注意，我们自己可以定义Period，比如ratio&lt;1, -2&gt;表示单位时间是-0.5秒。</p>
</li>
</ul>
</li>
<li><p>由于各种duration表示不同，chrono库提供了duration_cast类型转换函数。</p>
<p>默认可以转化为更小单位的时间，但是转化为大单位（缩窄）就需调用要这个类型转换函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ToDuration</span>, <span class="title">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">ToDuration</span> <span class="title">duration_cast</span> (<span class="title">const</span> <span class="title">duration</span>&lt;Rep,Period&gt;&amp; <span class="title">dtn</span>);</span></span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>&gt; seconds_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::milli&gt; milliseconds_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>&gt;&gt; hours_type;</span><br><span class="line"></span><br><span class="line"><span class="function">seconds_type <span class="title">s_onehour</span> <span class="params">(<span class="number">60</span>*<span class="number">60</span>)</span></span>;				<span class="comment">// 3600s</span></span><br><span class="line"><span class="comment">//hours_type h_onehour (s_onehour);			// NOT VALID (type truncates), use:</span></span><br><span class="line"><span class="function">hours_type <span class="title">h_onehour</span> <span class="params">(<span class="built_in">std</span>::chrono::duration_cast&lt;hours_type&gt;(s_onehour))</span></span>;</span><br><span class="line"><span class="function">milliseconds_type <span class="title">ms_onehour</span> <span class="params">(s_onehour)</span></span>;	<span class="comment">// 3600000ms (ok, no type truncation)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>duration还有一个成员函数count() 返回Rep类型的Period数量，通常就是用这个函数来显示时间的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">milliseconds <span class="title">foo</span> <span class="params">(<span class="number">1000</span>)</span></span>; <span class="comment">// 1 second</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo.count() &lt;&lt; <span class="string">" milliseconds.\n"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h4><p><code>std::chrono::&lt;clock&gt;::time_point</code> 表示一个具体时间。一个time point必须有一个clock计时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span> = <span class="title">typename</span> <span class="title">Clock</span>:</span>:duration&gt;  <span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure>
<p>由于各种time_point表示方式不同，chrono也提供了相应的转换函数 time_point_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ToDuration</span>, <span class="title">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">time_point</span>&lt;Clock,ToDuration&gt; <span class="title">time_point_cast</span> (<span class="title">const</span> <span class="title">time_point</span>&lt;Clock,Duration&gt;&amp; <span class="title">tp</span>);</span></span><br></pre></td></tr></table></figure>
<h4 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h4><p>每一个clock类中都有确定的time_point, duration, Rep, Period类型。</p>
<ul>
<li><p><code>std::chrono::system_clock</code> 它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</p>
<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">now(); 			<span class="comment">//当前时间time_point</span></span><br><span class="line"><span class="keyword">to_time_t</span>(); 	<span class="comment">//time_point转换成time_t秒</span></span><br><span class="line"><span class="keyword">from_time_t</span>();	<span class="comment">//从time_t转换成time_point</span></span><br></pre></td></tr></table></figure>
<p>比如线程库里的一个<strong>例子</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello waiter\n"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">2</span>s);</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed = end-start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waited "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::chrono::steady_clock</code> 为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大（这句话的意思其实是，如果中途修改了系统时间，也不影响now()的结果），每次tick都保证过了稳定的时间间隔。</p>
</li>
<li><p><code>std::chrono::high_resolution_clock</code> 顾名思义，这是系统可用的最高精度的时钟。实际上只不过是system_clock或者steady_clock的typedef。</p>
</li>
</ul>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++右值引用和移动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/11/C-C++/C++Collection/C++右值引用和移动/" class="article-date">
      <time datetime="2019-03-11T15:46:45.000Z" itemprop="datePublished">2019-03-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/C-C++/C++Collection/C++右值引用和移动/">C++右值引用和移动</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="C-右值引用和移动"><a href="#C-右值引用和移动" class="headerlink" title="C++右值引用和移动"></a>C++右值引用和移动</h2><p>参考：<a href="https://www.jianshu.com/p/31cea1b6ee24" target="_blank" rel="noopener">简书</a> 、<a href="https://www.cnblogs.com/likaiming/p/9045642.html" target="_blank" rel="noopener">cnblogs</a> 、《C++primer Plus》、C++标准库文档</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/03/11/C-C++/C++Collection/C++右值引用和移动/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Http/http" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/11/Network/Http/http/" class="article-date">
      <time datetime="2019-03-11T15:27:43.000Z" itemprop="datePublished">2019-03-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/Network/Http/http/">http</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>学习自：<a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/03/11/Network/Http/http/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2022 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>