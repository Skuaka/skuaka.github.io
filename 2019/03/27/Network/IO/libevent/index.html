<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">



<meta name="description" content="libeventIntroduction官方文档：http://libevent.org . 本篇是对官方文档的学习摘录。有目录方便查找。  各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，libevent就是对这些高效IO的封装，提供">
<meta name="keywords" content="Network">
<meta property="og:type" content="article">
<meta property="og:title" content="libevent">
<meta property="og:url" content="http://skuaka.cn/2019/03/27/Network/IO/libevent/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="libeventIntroduction官方文档：http://libevent.org . 本篇是对官方文档的学习摘录。有目录方便查找。  各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，libevent就是对这些高效IO的封装，提供">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-04-21T12:46:39.421Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="libevent">
<meta name="twitter:description" content="libeventIntroduction官方文档：http://libevent.org . 本篇是对官方文档的学习摘录。有目录方便查找。  各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，libevent就是对这些高效IO的封装，提供">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>libevent | Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/">unp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap"><article id="post-Network/IO/libevent" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/27/Network/IO/libevent/" class="article-date">
      <time datetime="2019-03-27T14:47:57.000Z" itemprop="datePublished">2019-03-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      libevent
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>官方文档：<a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org </a>.</p>
<p>本篇是对官方文档的学习摘录。有目录方便查找。</p>
<hr>
<p>各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，<strong>libevent就是对这些高效IO的封装，提供统一的API，简化开发。</strong></p>
<p><em>libevent</em> is meant to replace the event loop found in event driven network servers. An application just needs to call<em>event_dispatch()</em> and then add or remove events dynamically without having to change the event loop.</p>
<p>Libevent can also be used for multi-threaded applications, either by isolating each event_base so that only a single thread accesses it, or by locked access to a single shared event_base. </p>
<p>Libevent additionally provides a sophisticated framework for buffered network IO, with support for sockets, filters, rate-limiting, SSL, zero-copy file transmission, and IOCP. Libevent includes support for several useful protocols, including DNS, HTTP, and a minimal RPC framework.</p>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><strong>Libevent is divided into the following components:</strong></p>
<p><strong>evutil</strong></p>
<p>Generic functionality to abstract out the differences between different platforms’ networking implementations.</p>
<p><strong>event</strong> and <strong>event_base</strong></p>
<p>This is <em>the heart of Libevent</em>. It provides an abstract API to the various platform-specific, event-based nonblocking IO backends. It can let you know when sockets are ready to read or write, do basic timeout functionality, and detect OS signals.</p>
<p><strong>bufferevent</strong></p>
<p>These functions provide a more convenient wrapper around Libevent’s event-based core. They let your application request buffered reads and writes, and rather than informing you when sockets are ready to do, they let you know when IO has actually occurred.</p>
<p><strong>evbuffer</strong></p>
<p>This module implements the buffers underlying bufferevents, and provides functions for efficient and/or convenient access.</p>
<p><strong>evhttp</strong></p>
<p>A simple HTTP client/server implementation.</p>
<p><strong>evdns</strong></p>
<p>A simple DNS client/server implementation.</p>
<p><strong>evrpc</strong></p>
<p>A simple RPC implementation.</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>When Libevent is built, by default it installs the following libraries:</p>
<ul>
<li><p>libevent_core</p>
<p>All core event and buffer functionality. This library contains all the event_base, evbuffer, bufferevent, and utility functions.</p>
</li>
<li><p>libevent_extra</p>
<p>This library defines protocol-specific functionality that you may or may not want for your application, <em>including HTTP, DNS, and RPC</em>.</p>
</li>
<li><p>libevent</p>
<p>This library <em>exists for historical reasons</em>; it contains the contents of both libevent_core and libevent_extra. <em>You shouldn’t use it; it may go away in a future version of Libevent</em>.</p>
</li>
</ul>
<p>The following libraries are installed only on some platforms:</p>
<ul>
<li><p>libevent_pthreads</p>
<p>This library adds threading and locking implementations based on the pthreads portable threading library. It is separated from libevent_core so that you don’t need to link against pthreads to use Libevent unless you are <em>actually</em> using Libevent in a multithreaded way.</p>
</li>
<li><p>libevent_openssl</p>
<p>This library provides support for encrypted communications using bufferevents and the OpenSSL library. It is separated from libevent_core so that you don’t need to link against OpenSSL to use Libevent unless you are <em>actually</em> using encrypted connections.</p>
</li>
</ul>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>All current public Libevent headers are <strong>installed under the <em>event2</em> directory</strong>. </p>
<table>
<thead>
<tr>
<th>OLD HEADER</th>
<th>REPLACED BY CURRENT HEADERS</th>
</tr>
</thead>
<tbody>
<tr>
<td>event.h</td>
<td>event2/event*.h, event2/buffer*.h event2/bufferevent*.h event2/tag*.h</td>
</tr>
<tr>
<td>evdns.h</td>
<td>event2/dns*.h</td>
</tr>
<tr>
<td>evhttp.h</td>
<td>event2/http*.h</td>
</tr>
<tr>
<td>evrpc.h</td>
<td>event2/rpc*.h</td>
</tr>
<tr>
<td>evutil.h</td>
<td>event2/util*.h</td>
</tr>
</tbody>
</table>
<p><strong>编译参数：</strong></p>
<p>gcc link lib：<code>-levent</code> .</p>
<p>因为我是在mac下用brew安装的，所以我的<strong>cmake</strong>这么写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(/usr/local/Cellar/libevent/<span class="number">2.1</span>.<span class="number">8</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/libevent/<span class="number">2.1</span>.<span class="number">8</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(server main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(server event)</span><br></pre></td></tr></table></figure>
<p>目录可以用 <code>brew info libevent</code> 查找。</p>
<h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><h3 id="Lib-setup"><a href="#Lib-setup" class="headerlink" title="Lib setup"></a>Lib setup</h3><p>在开始调用libevent之前，可以进行一些设置来影响程序的行为。</p>
<a id="more"></a>
<p>官方文档：<a href="http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html" target="_blank" rel="noopener">http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html</a> .</p>
<p>其中可以设置的内容有：</p>
<ul>
<li>错误和警告日志的行为</li>
<li>产生致命错误时的行为</li>
<li>自定义内存管理函数</li>
<li>使用锁来保证线程安全</li>
<li>开启锁或者事件的debug选项</li>
<li>确定libevent库的版本</li>
<li>释放libevent库运行内部分配的内存(不是用户分配的)</li>
</ul>
<h3 id="可移植工具"><a href="#可移植工具" class="headerlink" title="可移植工具"></a>可移植工具</h3><h4 id="可移植类型"><a href="#可移植类型" class="headerlink" title="可移植类型"></a>可移植类型</h4><p><strong>套接字类型</strong>    evutil_socket_t</p>
<p><strong>整型</strong>        比如 ev_uint64_t、ev_ssize_t</p>
<h4 id="时间操纵函数"><a href="#时间操纵函数" class="headerlink" title="时间操纵函数"></a>时间操纵函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timeradd(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timersub(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br></pre></td></tr></table></figure>
<p>These macros add or subtract (respectively) their first two arguments, and stores the result in the third.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerisset(tvp) <span class="comment">/* ... */</span></span></span><br></pre></td></tr></table></figure>
<p>Clearing a timeval sets its value to zero. Checking whether it is set returns true if it is nonzero and false otherwise.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)</span></span><br></pre></td></tr></table></figure>
<p>The evutil_timercmp macro compares two timevals, and yields true if they are in the relationship specified by the relational operator <em>cmp</em>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The evutil_gettimeofday function sets <em>tv</em> to the current time. The tz argument is unused.</p>
<h4 id="套接字api"><a href="#套接字api" class="headerlink" title="套接字api"></a>套接字api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> s)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)</span></span><br></pre></td></tr></table></figure>
<p>closes a socket. On Unix, it’s an alias for <code>close()</code>; on Windows, it calls <code>closesocket()</code>.</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SOCKET_ERROR()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SET_SOCKET_ERROR(errcode)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode)</span></span><br></pre></td></tr></table></figure>
<p>These macros access and manipulate socket error codes. EVUTIL_SOCKET_ERROR() returns the global error code for the last socket operation from this thread, and evutil_socket_geterror() does so for a particular socket. (Both are errno on Unix-like systems.) EVUTIL_SET_SOCKET_ERROR() changes the current socket error code (like setting errno on Unix), and evutil_socket_error_to_string() returns a string representation of a given socket error code (like strerror() on Unix).</p>
<p>(We need these functions because Windows doesn’t use errno for errors from socket functions, but instead uses WSAGetLastError().)</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;				<span class="comment">// O_NONBLOCK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_listen_socket_reuseable</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;	<span class="comment">// SO_REUSEADDR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;				<span class="comment">// FD_CLOEXEC</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">evutil_socket_t</span> sv[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// This function behaves as the Unix socketpair() call: it makes two sockets that are connected with each other and can be used with ordinary socket IO calls. It stores the two sockets in sv[0] and sv[1], and returns 0 for success and -1 for failure.</span></span><br></pre></td></tr></table></figure>
<h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h4><p>Many applications (including evdns) need a source of hard-to-predict random numbers for their security.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_get_bytes</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function fills n-byte buffer at <em>buf</em> with <em>n</em> bytes of random data.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_secure_rng_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_add_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dat, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You do not need to manually initialize the secure random number generator, but if you want to make sure it is successfully initialized, you can do so by calling <code>evutil_secure_rng_init()</code>. It seeds the RNG (if it was not already seeded) and returns 0 on success. If it returns -1, Libevent wasn’t able to find a good source of entropy on your OS, and you can’t use the RNG safely without initializing it yourself.</p>
<p>If you are running in an environment where your program is likely to drop privileges (for example, by running <code>chroot()</code>), you should call <code>evutil_secure_rng_init()</code> before you do so.</p>
<h3 id="Event-base"><a href="#Event-base" class="headerlink" title="Event_base"></a>Event_base</h3><p>Each event_base structure holds a set of events and can poll to determine which events are active.</p>
<h4 id="多线程？"><a href="#多线程？" class="headerlink" title="多线程？"></a>多线程？</h4><p>如果为event_base设置了锁，那么在多个线程中访问它是安全的，但是一个事件循环只能在一个线程上运行，如果要多线程，必须为每一个线程都分配一个event_base。(未来版本会实现跨线程循环)</p>
<hr>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p><code>event_base_new()</code> : allocates and returns a new event base with the default settings. If there is an error, it returns NULL.</p>
<h4 id="配置初始化"><a href="#配置初始化" class="headerlink" title="配置初始化"></a>配置初始化</h4><p><code>event_config</code> 的创建、使用和释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct event_base *<span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>event_config</code> 的配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg, <span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> event_method_feature &#123;</span><br><span class="line">    EV_FEATURE_ET = <span class="number">0x01</span>,		<span class="comment">// supports edge-triggered IO.</span></span><br><span class="line">    EV_FEATURE_O1 = <span class="number">0x02</span>,		<span class="comment">// O(1) operation</span></span><br><span class="line">    EV_FEATURE_FDS = <span class="number">0x04</span>,	<span class="comment">// support arbitrary file descriptor, not just sockets.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">enum</span> event_method_feature feature)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> event_base_config_flag &#123;</span><br><span class="line">    EVENT_BASE_FLAG_NOLOCK = <span class="number">0x01</span>,</span><br><span class="line">    EVENT_BASE_FLAG_IGNORE_ENV = <span class="number">0x02</span>,</span><br><span class="line">    EVENT_BASE_FLAG_STARTUP_IOCP = <span class="number">0x04</span>,</span><br><span class="line">    EVENT_BASE_FLAG_NO_CACHE_TIME = <span class="number">0x08</span>,</span><br><span class="line">    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = <span class="number">0x10</span>,</span><br><span class="line">    EVENT_BASE_FLAG_PRECISE_TIMER = <span class="number">0x20</span></span><br><span class="line">&#125;;	<span class="comment">// detail: http://www.wangafu.net/~nickm/libevent-book/Ref2_eventbase.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> event_base_config_flag flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function prevents priority inversion by limiting how many low-priority event callbacks can be invoked before checking for more high-priority events. If max_interval is non-null, the event loop checks the time after each callback, and re-scans for high-priority events if max_interval has passed. If max_callbacks is nonnegative, the event loop also checks for more events after max_callbacks callbacks have been invoked. These rules apply to any event of min_priority or higher.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_max_dispatch_interval</span><span class="params">(struct event_config *cfg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *max_interval, <span class="keyword">int</span> max_callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> min_priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The above functions that manipulate an event_config all return 0 on success, -1 on failure.</p>
<p><strong>If you have made a configuration that Libevent can’t satisfy, event_base_new_with_config() will return NULL.</strong></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><strong>Example</strong>: Preferring edge-triggered backends</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_config</span> *<span class="title">cfg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* My program wants to use edge-triggered events if at all possible.  So</span></span><br><span class="line"><span class="comment">   I'll try to get a base twice: Once insisting on edge-triggered IO, and</span></span><br><span class="line"><span class="comment">   once not. */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i) &#123;</span><br><span class="line">    cfg = event_config_new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I don't like select. */</span></span><br><span class="line">    event_config_avoid_method(cfg, <span class="string">"select"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        event_config_require_features(cfg, EV_FEATURE_ET);</span><br><span class="line"></span><br><span class="line">    base = event_base_new_with_config(cfg);</span><br><span class="line">    event_config_free(cfg);</span><br><span class="line">    <span class="keyword">if</span> (base)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Example</strong>: Avoiding priority-inversion</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_config</span> *<span class="title">cfg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">cfg = event_config_new();</span><br><span class="line"><span class="keyword">if</span> (!cfg)</span><br><span class="line">   <span class="comment">/* Handle error */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I'm going to have events running at two priorities.  I expect that</span></span><br><span class="line"><span class="comment">   some of my priority-1 events are going to have pretty slow callbacks,</span></span><br><span class="line"><span class="comment">   so I don't want more than 100 msec to elapse (or 5 callbacks) before</span></span><br><span class="line"><span class="comment">   checking for priority-0 events. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">msec_100</span> = &#123;</span> <span class="number">0</span>, <span class="number">100</span>*<span class="number">1000</span> &#125;;</span><br><span class="line"><span class="comment">/*The &lt;sys/time.h&gt; header defines the timeval structure that includes at least the following members:</span></span><br><span class="line"><span class="comment">time_t         tv_sec      seconds</span></span><br><span class="line"><span class="comment">suseconds_t    tv_usec     microseconds */</span></span><br><span class="line">event_config_set_max_dispatch_interval(cfg, &amp;msec_100, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">base = event_base_new_with_config(cfg);</span><br><span class="line"><span class="keyword">if</span> (!base)</span><br><span class="line">   <span class="comment">/* Handle error */</span>;</span><br><span class="line"></span><br><span class="line">event_base_priority_init(base, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **methods = event_get_supported_methods();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Starting Libevent %s.  Available methods are:\n"</span>,</span><br><span class="line">    event_get_version());</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; methods[i] != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    %s\n"</span>, methods[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="keyword">enum</span> event_method_feature f;</span><br><span class="line"></span><br><span class="line">base = event_base_new();</span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Couldn't get an event_base!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using Libevent with backend method %s."</span>,</span><br><span class="line">        event_base_get_method(base));</span><br><span class="line">    f = event_base_get_features(base);</span><br><span class="line">    <span class="keyword">if</span> ((f &amp; EV_FEATURE_ET))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  Edge-triggered events are supported."</span>);</span><br><span class="line">    <span class="keyword">if</span> ((f &amp; EV_FEATURE_O1))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  O(1) event notification is supported."</span>);</span><br><span class="line">    <span class="keyword">if</span> ((f &amp; EV_FEATURE_FDS))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  All FD types are supported."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放event-base"><a href="#释放event-base" class="headerlink" title="释放event_base"></a>释放event_base</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_free</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h4><p>By default, though, an event_base supports only a single priority level.</p>
<p>You can set the number of priorities on an event_base by calling <code>event_base_priority_init()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> n_priorities)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success and -1 on failure</span></span><br><span class="line"><span class="comment">// n_priorities is the number of priorities to support.( &gt;=1 ).</span></span><br></pre></td></tr></table></figure>
<p>The available priorities for new events will be numbered from 0 (most important) to n_priorities-1 (least important).</p>
<p>By default, all new events associated with this base will be initialized with priority: <strong>n_priorities / 2</strong>.</p>
<p>You <strong>must</strong> call this function before any events become active.</p>
<p>查看当前设置的优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_npriorities</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fork之后重置"><a href="#fork之后重置" class="headerlink" title="fork之后重置"></a>fork之后重置</h4><p>Not all event backends persist cleanly after a call to fork(). Thus, if your program uses fork() or a related system call in order to start a new process, and you want to continue using an event_base after you have forked, you may need to reinitialize it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork()) &#123;</span><br><span class="line">    <span class="comment">/* In parent */</span></span><br><span class="line">    continue_running_parent(base); <span class="comment">/*...*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* In child */</span></span><br><span class="line">    event_reinit(base);</span><br><span class="line">    continue_running_child(base); <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_ONCE             0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK         0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <code>event_base_dispatch()</code> call is the same as <code>event_base_loop()</code>, <em>with no flags set</em>.</p>
<p>By default, the two functions <strong>run</strong> an event_base <strong>until</strong> :</p>
<ol>
<li>there are no more events registered in it</li>
<li><code>event_base_loopbreak()</code> is called.</li>
<li><code>event_base_loopexit()</code> is called.</li>
</ol>
<p>When it is done, <code>event_base_loop()</code> <strong>returns</strong> <strong>0</strong> if it exited normally, <strong>-1</strong> if it exited because of some unhandled error in the backend, and <strong>1</strong> if it exited because there were no more pending or active events.</p>
<p><strong>Pseudocode :</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (any events are registered with the loop,</span><br><span class="line">        <span class="keyword">or</span> EVLOOP_NO_EXIT_ON_EMPTY was <span class="built_in">set</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EVLOOP_NONBLOCK was <span class="built_in">set</span>, <span class="keyword">or</span> any events are already active)</span><br><span class="line">        If any registered events have triggered, mark them active.</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Wait until at least one event has triggered, <span class="keyword">and</span> mark it active.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n_priorities; ++p) &#123;</span><br><span class="line">       <span class="keyword">if</span> (any event with priority of p is active) &#123;</span><br><span class="line">          Run all active events with priority of p.</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">/* Do not run any events of a less important priority */</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EVLOOP_ONCE was <span class="built_in">set</span> <span class="keyword">or</span> EVLOOP_NONBLOCK was <span class="built_in">set</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>differences :</strong></p>
<p>The <code>event_base_loopexit()</code> function tells an event_base to stop looping after a given time has elapsed. If the <em>tv</em> argument is NULL, the event_base stops looping without a delay. If the event_base is currently running callbacks for any active events, it will continue running them, and not exit until <strong>they</strong> have all been run.</p>
<p>The <code>event_base_loopbreak()</code> function tells the event_base to exit its loop immediately. It <strong>differs from</strong> <code>event_base_loopexit(base, NULL)</code> in that if the event_base is currently running callbacks for any active events, it will exit immediately after finishing the <strong>one</strong> it’s currently processing.</p>
<p>Note also that <code>event_base_loopexit(base,NULL)</code> and <code>event_base_loopbreak(base)</code> act differently when no event loop is running: <em>loopexit</em> schedules the next instance of the event loop to stop right after the next round of callbacks are run (as if it had been invoked with EVLOOP_ONCE) whereas <em>loopbreak</em> only stops a currently running loop, and has no effect if the event loop isn’t running.</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p>Example: Shut down immediately</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here's a callback function that calls loopbreak */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">short</span> what, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">arg</span>;</span></span><br><span class="line">    event_base_loopbreak(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_loop</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> watchdog_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">watchdog_event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct a new event to trigger whenever there are any bytes to</span></span><br><span class="line"><span class="comment">       read from a watchdog socket.  When that happens, we'll call the</span></span><br><span class="line"><span class="comment">       cb function, which will make the loop exit immediately without</span></span><br><span class="line"><span class="comment">       running any other active events at all.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    watchdog_event = event_new(base, watchdog_fd, EV_READ, cb, base);</span><br><span class="line"></span><br><span class="line">    event_add(watchdog_event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example: Run an event loop for 10 seconds, then exit.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_base_with_ticks</span><span class="params">(struct event_base *base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ten_sec</span>;</span></span><br><span class="line"></span><br><span class="line">  ten_sec.tv_sec = <span class="number">10</span>;</span><br><span class="line">  ten_sec.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we run the event_base for a series of 10-second intervals, printing</span></span><br><span class="line"><span class="comment">     "Tick" after each.  For a much better way to implement a 10-second</span></span><br><span class="line"><span class="comment">     timer, see the section below about persistent timer events. */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">/* This schedules an exit ten seconds from now. */</span></span><br><span class="line">     event_base_loopexit(base, &amp;ten_sec);</span><br><span class="line"></span><br><span class="line">     event_base_dispatch(base);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"Tick"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检查退出原因"><a href="#检查退出原因" class="headerlink" title="检查退出原因"></a>检查退出原因</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>These two functions will return true if the loop was stopped with <code>event_base_loopexit()</code> or <code>event_base_break()</code> respectively, and false otherwise. Their values will be reset the next time you start the event loop.</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>Sometimes you might want to stop Libevent right after the current callback has been run, and tell it to scan again. By analogy to <code>event_base_loopbreak()</code>, you can do this with the function <code>event_base_loopcontinue()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopcontinue</span><span class="params">(struct event_base *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Calling <code>event_base_loopcontinue()</code> has no effect if we aren’t currently running event callbacks.</p>
<h4 id="other-api"><a href="#other-api" class="headerlink" title="other api"></a>other api</h4><h5 id="time-cache"><a href="#time-cache" class="headerlink" title="time cache"></a>time cache</h5><p>系统时钟的代替方案：<a href="http://www.wangafu.net/~nickm/libevent-book/Ref3_eventloop.html" target="_blank" rel="noopener">http://www.wangafu.net/~nickm/libevent-book/Ref3_eventloop.html</a></p>
<h5 id="dump-status"><a href="#dump-status" class="headerlink" title="dump status"></a>dump status</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_dump_events</span><span class="params">(struct event_base *base, FILE *f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>For help debugging your program (or debugging Libevent!) you might sometimes want a complete list of all events added in the event_base and their status. </p>
<p>Calling <code>event_base_dump_events()</code> writes this list to the stdio file provided.</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*event_base_foreach_event_cb)</span><span class="params">(<span class="keyword">const</span> struct event_base *,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct event *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_foreach_event</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">                             event_base_foreach_event_cb fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Use <code>event_base_foreach_event()</code> to iterate over every currently active or pending event associated with an event_base. The provided callback will be invoked exactly once <strong>per event</strong>, in an <em>unspecified order</em>. </p>
<p>The callback function must <strong>return 0 to continue iteration</strong>, or some other integer to stop iterating. <strong>Whatever value it returns will then be returned by <code>event_base_foreach_function()</code></strong>.</p>
<p>Your callback function <strong>must not modify</strong> any of the events that it receives, or add or remove any events to the event base, or otherwise modify any event associated with the event base, or undefined behavior can occur, up to or including crashes and heap-smashing.</p>
<p>The event_base <strong>lock will be held</strong> for the duration of the call to <code>event_base_foreach_event()</code> — this will block other threads from doing anything useful with the event_base, <em>so make sure that your callback doesn’t take a long time</em>.</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Every event represents a set of conditions, including:</p>
<ul>
<li>A file descriptor being ready to read from or write to.</li>
<li>A file descriptor <em>becoming</em> ready to read from or write to (Edge-triggered IO only).</li>
<li>A timeout expiring.</li>
<li>A signal occurring.</li>
<li>A user-triggered event.</li>
</ul>
<p>Events have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an event base, it becomes <strong>initialized</strong>. At this point, you can <em>add</em>, which makes it <strong>pending</strong> in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomes <strong>active</strong>, and its (user-provided) callback function is run. If the event is configured <strong>persistent</strong>, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by <em>deleting</em> it, and you can <em>add</em> a non-pending event to make it pending again.</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT      0x01	<span class="comment">// ignored when construct, only return to cb</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ         0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE        0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL       0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST      0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET           0x20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">short</span> what, event_callback_fn cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <em>what</em> argument is a set of the flags listed above. When the event is active, Libevent will invoke the provided <em>cb</em> function, passing it as arguments: the file descriptor <em>fd</em>, a bitfield of <em>all</em> the events that triggered, and the value that was passed in for <em>arg</em> when the function was constructed.</p>
<p>The <strong>EV_PERSIST</strong> flag  means that event remains pending even when its callback is activated. If you want to make it non-pending from within its callback, you can call <code>event_del()</code> on it. The timeout on a persistent event <strong>resets</strong> whenever the event’s callback runs.</p>
<p>On an internal error, or invalid arguments, <code>event_new()</code> will <strong>return</strong> NULL.</p>
<p>All new events are initialized and non-pending. To make an event pending, call <code>event_add()</code>.</p>
<p>To deallocate an event, call <code>event_free()</code>. It is <strong>safe</strong> to call <code>event_free()</code> on an event that is pending or active: doing so makes the event non-pending and inactive before deallocating it.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *data = arg;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Got an event on socket %d:%s%s%s%s [%s]"</span>,</span><br><span class="line">            (<span class="keyword">int</span>) fd,</span><br><span class="line">            (what&amp;EV_TIMEOUT) ? <span class="string">" timeout"</span> : <span class="string">""</span>,</span><br><span class="line">            (what&amp;EV_READ)    ? <span class="string">" read"</span> : <span class="string">""</span>,</span><br><span class="line">            (what&amp;EV_WRITE)   ? <span class="string">" write"</span> : <span class="string">""</span>,</span><br><span class="line">            (what&amp;EV_SIGNAL)  ? <span class="string">" signal"</span> : <span class="string">""</span>,</span><br><span class="line">            data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_loop</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd1, <span class="keyword">evutil_socket_t</span> fd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev1</span>, *<span class="title">ev2</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">five_seconds</span> = &#123;</span><span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The caller has already set up fd1, fd2 somehow, and make them</span></span><br><span class="line"><span class="comment">           nonblocking. */</span></span><br><span class="line"></span><br><span class="line">        ev1 = event_new(base, fd1, EV_TIMEOUT|EV_READ|EV_PERSIST, cb_func,</span><br><span class="line">           (<span class="keyword">char</span>*)<span class="string">"Reading event"</span>);</span><br><span class="line">        ev2 = event_new(base, fd2, EV_WRITE|EV_PERSIST, cb_func,</span><br><span class="line">           (<span class="keyword">char</span>*)<span class="string">"Writing event"</span>);</span><br><span class="line"></span><br><span class="line">        event_add(ev1, &amp;five_seconds);</span><br><span class="line">        event_add(ev2, <span class="literal">NULL</span>);</span><br><span class="line">        event_base_dispatch(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Timeout-only"><a href="#Timeout-only" class="headerlink" title="Timeout-only"></a>Timeout-only</h5><p>As a convenience, there are a set of <strong>macros</strong> beginning with evtimer_ that you can use in place of the event_* calls to allocate and manipulate pure-timeout events.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(base, callback, arg) \</span></span><br><span class="line">    event_new((base), <span class="number">-1</span>, <span class="number">0</span>, (callback), (arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv) \</span></span><br><span class="line">    event_add((ev),(tv))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev) \</span></span><br><span class="line">    event_del(ev)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv_out) \</span></span><br><span class="line">    event_pending((ev), EV_TIMEOUT, (tv_out))</span><br></pre></td></tr></table></figure>
<h5 id="signal-events"><a href="#signal-events" class="headerlink" title="signal events"></a>signal events</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(base, signum, cb, arg) \</span></span><br><span class="line">    event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv) \</span></span><br><span class="line">    event_add((ev),(tv))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev) \</span></span><br><span class="line">    event_del(ev)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, what, tv_out) \</span></span><br><span class="line">    event_pending((ev), (what), (tv_out))</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evsignal_new(base, SIGHUP, sighup_function, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *event, struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>All the arguments of <code>event_assign()</code> are as for <code>event_new()</code>, except for the <em>event</em> argument, which must point to an uninitialized event. </p>
<p><strong>Example :</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Watch out!  Including event_struct.h means that your code will not</span></span><br><span class="line"><span class="comment"> * be binary-compatible with future versions of Libevent. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event_struct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_pair</span> &#123;</span></span><br><span class="line">         <span class="keyword">evutil_socket_t</span> fd;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">read_event</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">write_event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readcb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writecb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function">struct event_pair *<span class="title">event_pair_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_pair</span> *<span class="title">p</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">event_pair</span>));</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;fd = fd;</span><br><span class="line">        event_assign(&amp;p-&gt;read_event, base, fd, EV_READ|EV_PERSIST, readcb, p);</span><br><span class="line">        event_assign(&amp;p-&gt;write_event, base, fd, EV_WRITE|EV_PERSIST, writecb, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can also use <code>event_assign()</code> to initialize stack-allocated or statically allocated events.</p>
<p><strong>WARNING</strong>: Never call <code>event_assign()</code> on an event that is already pending in an event base. If the event is already initialized and pending, call <code>event_del()</code> on it <strong>before</strong> you call <code>event_assign()</code> on it again.</p>
<p>There are convenience <strong>macros</strong> you can use to <code>event_assign()</code> a timeout-only or a signal event:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(event, base, callback, arg) \</span></span><br><span class="line">    event_assign(event, base, <span class="number">-1</span>, <span class="number">0</span>, callback, arg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(event, base, signum, callback, arg) \</span></span><br><span class="line">    event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)</span><br></pre></td></tr></table></figure>
<p>关于<code>event_assign()</code>不同版本的兼容性问题，见<a href="http://www.wangafu.net/~nickm/libevent-book/Ref4_event.html" target="_blank" rel="noopener">官方文档</a> 。</p>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a>use</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure</span></span><br></pre></td></tr></table></figure>
<p>If you delete an event after it becomes active but before its callback has a chance to execute, the callback will not be executed.</p>
<p>If you call <code>event_add()</code> on an event that is <em>already</em> pending, it will leave it pending, and reschedule it with the provided timeout. If the event is already pending, and you re-add it with the timeout NULL, <code>event_add()</code> will have no effect.</p>
<p>You can remove a pending event’s timeout completely without deleting its IO or signal components. If the event had no timeout pending, <code>event_remove_timer()</code> has no effect. If the event had only a timeout but no IO or signal component, <code>event_remove_timer()</code> has the same effect as <code>event_del()</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_remove_timer</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h5><p>Before adding an event to the event_base, but after initializing it, you can set its priority.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *event, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>When multiple events of multiple priorities become active, the low-priority events are not run. Instead, Libevent runs the high priority events, then checks for events again. Only when no high-priority events are active are the low-priority events run.</p>
<h5 id="event-status"><a href="#event-status" class="headerlink" title="event status"></a>event status</h5><p>Sometimes you want to tell whether an event has been added, and check what it refers to.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev);</span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct event_base **base_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">evutil_socket_t</span> *fd_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">short</span> *events_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        event_callback_fn *callback_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> **arg_out)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <code>event_pending()</code> function determines whether the given event is pending or active. If it is, and any of the flags EV_READ, EV_WRITE, EV_SIGNAL, and EV_TIMEOUT are set in the <em>what</em> argument, the function returns all of the flags that the event is currently pending or active on. If <em>tv_out</em> is provided, and EV_TIMEOUT is set in <em>what</em>, and the event is currently pending or active on a timeout, then <em>tv_out</em> is set to hold the time when the event’s timeout will expire.</p>
<p>The <code>event_get_fd()</code> and <code>event_get_signal()</code> functions return the configured file descriptor or signal number for an event. The <code>event_get_base()</code> function returns its configured event_base. The <code>event_get_events()</code> function returns the event <em>flags</em> (EV_READ, EV_WRITE, etc) of the event. The <code>event_get_callback()</code> and <code>event_get_callback_arg()</code> functions return the callback function and argument pointer. The <code>event_get_priority()</code> function returns the event’s currently assigned priority.</p>
<p>The <code>event_get_assignment()</code> function copies all of the assigned fields of the event into the provided pointers. If any of the pointers is NULL, it is ignored.</p>
<p><strong>Example :</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Change the callback and callback_arg of 'ev', which must not be pending. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace_callback</span><span class="params">(struct event *ev, event_callback_fn new_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *new_callback_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> fd;</span><br><span class="line">    <span class="keyword">short</span> events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pending;</span><br><span class="line"></span><br><span class="line">    pending = event_pending(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT,</span><br><span class="line">                            <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="comment">/* We want to catch this here so that we do not re-assign a</span></span><br><span class="line"><span class="comment">         * pending event.  That would be very very bad. */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"Error! replace_callback called on a pending event!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event_get_assignment(ev, &amp;base, &amp;fd, &amp;events,</span><br><span class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback */</span> ,</span><br><span class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback argument */</span>);</span><br><span class="line"></span><br><span class="line">    event_assign(ev, base, fd, events, new_callback, new_callback_arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>currently running event</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_base_get_running_event</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="one-off-events"><a href="#one-off-events" class="headerlink" title="one-off events"></a>one-off events</h5><p>If you don’t need to add an event more than once, or delete it once it has been added, and it doesn’t have to be persistent, you can use <code>event_base_once()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_once</span><span class="params">(struct event_base *, <span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> (*)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *, <span class="keyword">const</span> struct timeval *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function’s interface is the same as <code>event_new()</code>, except that it does not support EV_SIGNAL or EV_PERSIST. The scheduled event is inserted and run with the default priority. <strong><em>When the callback is finally done, Libevent frees the internal event structure itself</em></strong>.</p>
<p>Events inserted with <code>event_base_once()</code> cannot be deleted or manually activated: if you want to be able to cancel an event, create it with regular way.</p>
<h5 id="manually-activate"><a href="#manually-activate" class="headerlink" title="manually activate"></a>manually activate</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> what, <span class="keyword">short</span> ncalls)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function makes an event <em>ev</em> become active with the flags <em>what</em> (a combination of EV_READ, EV_WRITE, and EV_TIMEOUT). The event does not need to have previously been pending, and activating it does not make it pending.</p>
<h5 id="others"><a href="#others" class="headerlink" title="others"></a>others</h5><p><strong>optimize timeouts</strong></p>
<p>默认的存储事件超时的数据结构是堆，复杂度O(lgN)。可以改变存储的方式，比如改成O(1)的双端列队，具体见<a href="http://www.wangafu.net/~nickm/libevent-book/Ref4_event.html" target="_blank" rel="noopener">官方文档</a> 。</p>
<p><strong>Telling a good event</strong></p>
<p>辨别一个event结构是否是良好的(也许被清空了)。</p>
<p>具体见<a href="http://www.wangafu.net/~nickm/libevent-book/Ref4_event.html" target="_blank" rel="noopener">官方文档</a> 。</p>
<h3 id="Bufferevents"><a href="#Bufferevents" class="headerlink" title="Bufferevents"></a>Bufferevents</h3><h4 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h4><p>A “bufferevent” consists of an underlying transport (like a socket), a read buffer, and a write buffer. Instead of regular events, which give callbacks when the underlying transport is ready to be read or written, a bufferevent invokes its user-supplied callbacks when it has read or written enough data.</p>
<p>There are multiple types of bufferevent that all share a common interface. As of this writing, the following types exist:</p>
<ul>
<li><p>socket-based bufferevents</p>
<p>A bufferevent that sends and receives data from an underlying stream socket, using the <code>event_*</code> interface as its backend.</p>
</li>
<li><p>asynchronous-IO bufferevents</p>
<p>A bufferevent that uses the Windows IOCP interface to send and receive data to an underlying stream socket. (Windows only; experimental.)</p>
</li>
<li><p>filtering bufferevents</p>
<p>A bufferevent that processes incoming and outgoing data before passing it to an underlying bufferevent object—for example, to compress or translate data.</p>
</li>
<li><p>paired bufferevents</p>
<p>Two bufferevents that transmit data to one another.</p>
</li>
</ul>
<p>Bufferevents currently <strong>only work for</strong> stream-oriented protocols like <strong>TCP</strong>. There may in the future be support for datagram-oriented protocols like UDP.</p>
<p>Every bufferevent has an input buffer and an output buffer. These are of type <code>struct evbuffer</code>. When you have data to write on a bufferevent, you add it to the output buffer; when a bufferevent has data for you to read, you drain it from the input buffer.</p>
<h5 id="watermarks"><a href="#watermarks" class="headerlink" title="watermarks"></a>watermarks</h5><p>Every bufferevent has <strong>two data-related callbacks</strong>: a read callback and a write callback. <strong>By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport.</strong> You can override the behavior of these functions by adjusting the read and write “watermarks” of the bufferevent.</p>
<p>Every bufferevent has four watermarks:</p>
<ul>
<li><p>Read low-water mark</p>
<p>Whenever a read occurs that leaves the bufferevent’s input buffer <strong>at this level or higher</strong>, the bufferevent’s <strong>read callback is invoked</strong>. <strong><em>Defaults to 0</em></strong>, so that every read results in the read callback being invoked.</p>
</li>
<li><p>Read high-water mark</p>
<p>If the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. <strong><em>Defaults to unlimited</em></strong>, <strong>so that we never stop reading</strong> because of the size of the input buffer.</p>
</li>
<li><p>Write low-water mark</p>
<p>Whenever a write occurs that takes us <strong>to this level or below</strong>, we invoke the write callback. <strong><em>Defaults to 0</em></strong>, so that a write callback is invoked when the output buffer is emptied.</p>
</li>
<li><p>Write high-water mark</p>
<p><strong>Not used by a bufferevent directly</strong>, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below.</p>
</li>
</ul>
<h5 id="callbacks"><a href="#callbacks" class="headerlink" title="callbacks"></a>callbacks</h5><p>A bufferevent <strong>also</strong> has <strong>an “error” or “event” callback</strong> that gets invoked to tell the application about <strong>non-data-oriented events</strong>, like when a connection is closed or an error occurs. The following <strong>event flags</strong> are defined:</p>
<ul>
<li><p>BEV_EVENT_READING</p>
<p><em>An event</em> occured during a read operation on the bufferevent. <em>See the other flags for which event it was.</em></p>
</li>
<li><p>BEV_EVENT_WRITING</p>
<p><em>An event</em> occured during a write operation on the bufferevent. <em>See the other flags for which event it was.</em></p>
</li>
<li><p>BEV_EVENT_ERROR</p>
<p>An error occurred during a bufferevent operation. For more information on what the error was, call <code>EVUTIL_SOCKET_ERROR()</code>.</p>
</li>
<li><p>BEV_EVENT_TIMEOUT</p>
<p>A timeout expired on the bufferevent.</p>
</li>
<li><p>BEV_EVENT_EOF</p>
<p>We got an end-of-file indication on the bufferevent.</p>
</li>
<li><p>BEV_EVENT_CONNECTED</p>
<p>We finished a requested connection on the bufferevent.</p>
</li>
</ul>
<h5 id="deferred-callbacks"><a href="#deferred-callbacks" class="headerlink" title="deferred callbacks"></a>deferred callbacks</h5><p>By default, a bufferevent callbacks are executed <em>immediately</em> when the corresponding condition happens. (This is true of evbuffer callbacks too; we’ll get to those later.) This immediate invocation can make trouble when dependencies get complex. For example, suppose that there is a callback that moves data into evbuffer A when it grows empty, and another callback that processes data out of evbuffer A when it grows full. Since these calls are all happening on the stack, you might risk a stack overflow if the dependency grows nasty enough.</p>
<p>To solve this, you can tell a bufferevent (or an evbuffer) that its callbacks should be <em>deferred</em>. When the conditions are met for a deferred callback, rather than invoking it immediately, it is queued as part of the <code>event_loop()</code> call, and invoked after the regular events’ callbacks.</p>
<h5 id="option-flags"><a href="#option-flags" class="headerlink" title="option flags"></a>option flags</h5><ul>
<li><p>BEV_OPT_CLOSE_ON_FREE</p>
<p>When the bufferevent is freed, close the underlying transport. This will close an underlying socket, free an underlying bufferevent, etc.</p>
</li>
<li><p>BEV_OPT_THREADSAFE</p>
<p>Automatically allocate locks for the bufferevent, so that it’s safe to use from multiple threads.</p>
</li>
<li><p>BEV_OPT_DEFER_CALLBACKS</p>
<p>When this flag is set, the bufferevent defers all of its callbacks, as described above.</p>
</li>
<li><p>BEV_OPT_UNLOCK_CALLBACKS</p>
<p>By default, when the bufferevent is set up to be threadsafe, the bufferevent’s locks are held whenever the any user-provided callback is invoked. Setting this option makes Libevent release the bufferevent’s lock when it’s invoking your callbacks.</p>
</li>
</ul>
<h4 id="advanced"><a href="#advanced" class="headerlink" title="advanced"></a>advanced</h4><p>This chapter describes some advanced features of Libevent’s bufferevent implementation that aren’t necessary for typical uses. If you’re just learning how to use bufferevents, you should skip this chapter for now.</p>
<p>see: <a href="http://www.wangafu.net/~nickm/libevent-book/Ref6a_advanced_bufferevents.html" target="_blank" rel="noopener">http://www.wangafu.net/~nickm/libevent-book/Ref6a_advanced_bufferevents.html</a></p>
<p>包括：</p>
<ul>
<li>Paired bufferevents</li>
<li>Filtering bufferevents</li>
<li>Limiting maximum single read/write size</li>
<li>Rate-limiting: limit the amount of bandwidth used for any single bufferevent, or for a group of bufferevents</li>
<li>SSL</li>
</ul>
<h3 id="Socket-based-bufferevents"><a href="#Socket-based-bufferevents" class="headerlink" title="Socket-based bufferevents"></a>Socket-based bufferevents</h3><p>The simplest bufferevents to work with is the socket-based type. A socket-based bufferevent uses Libevent’s underlying event mechanism to detect when an underlying network socket is ready for read and/or write operations, and uses underlying network calls (like readv, writev) to transmit and receive data.</p>
<h4 id="construct-1"><a href="#construct-1" class="headerlink" title="construct"></a>construct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> bufferevent_options options)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Make sure</strong> that the socket you provide to bufferevent_socket_new is <strong>in non-blocking mode</strong>.</p>
<p>The <em>fd</em> argument is an optional file descriptor for a socket. You can set fd to -1 if you want to set the file descriptor later.</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Bufferevents are internally reference-counted, so if the bufferevent has pending deferred callbacks when you free it, it won’t be deleted until the callbacks are done.</p>
<p>The <code>bufferevent_free()</code> function does, however, try to free the bufferevent as soon as possible. If there is pending data to write on the bufferevent, it probably won’t be flushed before the bufferevent is freed.</p>
<p>If the BEV_OPT_CLOSE_ON_FREE flag was set, and this bufferevent has a socket or underlying bufferevent associated with it as its transport, that transport is closed when you free the bufferevent.</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>If the bufferevent’s socket is not yet connected, you can launch a new connection.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *address, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 if the connect was launched, and -1 if an error occurred.</span></span><br></pre></td></tr></table></figure>
<p>The address and addrlen arguments are as for the standard call <code>connect()</code>. <em>If the bufferevent does not already have a socket set</em>, calling this function allocates a new stream socket for it, and makes it nonblocking.</p>
<p>If the bufferevent <strong>does</strong> have a socket already, calling <code>bufferevent_socket_connect()</code> tells Libevent that the socket is not connected, and no reads or writes should be done on the socket until the connect operation has succeeded.</p>
<p>It is okay to add data to the output buffer before the connect is done.</p>
<p><strong>注意：如果使用bufferevent_socket_connect()发起连接，将只会收到BEV_EVENT_CONNECTED事件。如果自己调用connect()，则这个连接将被报告为写入事件。</strong></p>
<p><strong>example:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> events, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_CONNECTED) &#123;</span><br><span class="line">         <span class="comment">/* We're connected to 127.0.0.1:8080.   Ordinarily we'd do</span></span><br><span class="line"><span class="comment">            something here, like start reading or writing. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">         <span class="comment">/* An error occured while connecting. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main_loop(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    struct event_base *base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    base = event_base_new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = htonl(<span class="number">0x7f000001</span>); <span class="comment">/* 127.0.0.1 */</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">8080</span>); <span class="comment">/* Port 8080 */</span></span><br><span class="line"></span><br><span class="line">    bev = bufferevent_socket_new(base, <span class="number">-1</span>, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line">    bufferevent_setcb(bev, <span class="literal">NULL</span>, <span class="literal">NULL</span>, eventcb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferevent_socket_connect(bev,</span><br><span class="line">        (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Error starting connection */</span></span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h5><p>Quite often, you’d like to combine resolving a hostname and connecting to it into a single operation. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect_hostname</span><span class="params">(struct bufferevent *bev,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evdns_base *dns_base, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *hostname,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_get_dns_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>暂时用不到，详情见<a href="http://www.wangafu.net/~nickm/libevent-book/Ref6a_advanced_bufferevents.html" target="_blank" rel="noopener">官方文档</a> .</p>
<h4 id="set-callbacks"><a href="#set-callbacks" class="headerlink" title="set callbacks"></a>set callbacks</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">short</span> events, <span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_getcb</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_data_cb *readcb_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_data_cb *writecb_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_event_cb *eventcb_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> **cbarg_ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The readcb, writecb, and eventcb functions are called (respectively) when enough data is read, when enough data is written, or when an event occurs.</p>
<p>You can disable a callback by passing NULL instead of the callback function. Note all the callback functions on a bufferevent share a single <em>cbarg</em> value, so changing it will affect all of them.</p>
<h5 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You can enable or disable the events EV_READ, EV_WRITE, or EV_READ|EV_WRITE on a bufferevent. When reading or writing is not enabled, the bufferevent will not try to read or write data.</p>
<p>There is no need to disable writing when the output buffer is empty.</p>
<p><strong>By default, a newly created bufferevent has writing enabled, but not reading.</strong></p>
<hr>
<h5 id="watermark"><a href="#watermark" class="headerlink" title="watermark"></a>watermark</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setwatermark</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> lowmark, <span class="keyword">size_t</span> highmark)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Adjusts the read watermarks, the write watermarks, or both.</p>
<p>A high-water mark of 0 is equivalent to “unlimited”.</p>
<hr>
<p><strong>Example:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">size_t</span> total_drained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_callback</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">inf</span> = <span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span> = <span class="title">bufferevent_get_input</span>(<span class="title">bev</span>);</span></span><br><span class="line">    <span class="keyword">size_t</span> len = evbuffer_get_length(input);</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        inf-&gt;total_drained += len;</span><br><span class="line">        evbuffer_drain(input, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Drained %lu bytes from %s\n"</span>,</span><br><span class="line">             (<span class="keyword">unsigned</span> <span class="keyword">long</span>) len, inf-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_callback</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> events, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">inf</span> = <span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span> = <span class="title">bufferevent_get_input</span>(<span class="title">bev</span>);</span></span><br><span class="line">    <span class="keyword">int</span> finished = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = evbuffer_get_length(input);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Got a close from %s.  We drained %lu bytes from it, "</span></span><br><span class="line">            <span class="string">"and have %lu left.\n"</span>, inf-&gt;name,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)inf-&gt;total_drained, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)len);</span><br><span class="line">        finished = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Got an error from %s: %s\n"</span>,</span><br><span class="line">            inf-&gt;name, evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));</span><br><span class="line">        finished = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct bufferevent *<span class="title">setup_bufferevent</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">b1</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">info1</span>;</span></span><br><span class="line"></span><br><span class="line">    info1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct info));</span><br><span class="line">    info1-&gt;name = <span class="string">"buffer 1"</span>;</span><br><span class="line">    info1-&gt;total_drained = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... Here we should set up the bufferevent and make sure it gets</span></span><br><span class="line"><span class="comment">       connected... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trigger the read callback only whenever there is at least 128 bytes</span></span><br><span class="line"><span class="comment">       of data in the buffer. */</span></span><br><span class="line">    bufferevent_setwatermark(b1, EV_READ, <span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bufferevent_setcb(b1, read_callback, <span class="literal">NULL</span>, event_callback, info1);</span><br><span class="line"></span><br><span class="line">    bufferevent_enable(b1, EV_READ); <span class="comment">/* Start reading. */</span></span><br><span class="line">    <span class="keyword">return</span> b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read&amp;write"></a>read&amp;write</h4><p>Bufferevents give you these methods to give them data to write, and to get the data to read:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_input</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_output</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>These two functions are very powerful fundamental: they return the input and output buffers respectively. For full information on all the operations you can perform on an evbuffer type, see evbuffer.</p>
<p>Note that the application may only remove (not add) data on the input buffer, and may only add (not remove) data from the output buffer.</p>
<p>If writing on the bufferevent was stalled because of too little data (or if reading was stalled because of too much), then adding data to the output buffer (or removing data from the input buffer) will automatically restart it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write_buffer</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="comment">// both return 0 on success and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>These functions add data to a bufferevent’s output buffer. Calling <code>bufferevent_write()</code> adds <em>size</em> bytes from the memory at <em>data</em> to the end of the output buffer. Calling <code>bufferevent_write_buffer()</code> removes the entire contents of <em>buf</em> and puts them at the end of the output buffer. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bufferevent_read(struct bufferevent *bufev, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="comment">// returns the number of bytes actually removed</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_read_buffer</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>These functions remove data from a bufferevent’s input buffer. The <code>bufferevent_read()</code> function removes up to <em>size</em> bytes from the input buffer, storing them into the memory at <em>data</em>. The <code>bufferevent_read_buffer()</code> function drains the entire contents of the input buffer and places them into <em>buf</em>.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">read_callback_uppercase(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* This callback removes the data from bev's input buffer 128</span></span><br><span class="line"><span class="comment">           bytes at a time, uppercases it, and starts sending it</span></span><br><span class="line"><span class="comment">           back.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           (Watch out!  In practice, you shouldn't use toupper to implement</span></span><br><span class="line"><span class="comment">           a network protocol, unless you know for a fact that the current</span></span><br><span class="line"><span class="comment">           locale is the one you want to be using.)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">size_t</span> n;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                n = bufferevent_read(bev, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">/* No more data. */</span></span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">                        tmp[i] = <span class="built_in">toupper</span>(tmp[i]);</span><br><span class="line">                bufferevent_write(bev, tmp, n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proxy_info</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">other_bev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">read_callback_proxy(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* You might use a function like this if you're implementing</span></span><br><span class="line"><span class="comment">           a simple proxy: it will take data from one connection (on</span></span><br><span class="line"><span class="comment">           bev), and write it to another, copying as little as</span></span><br><span class="line"><span class="comment">           possible. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proxy_info</span> *<span class="title">inf</span> = <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">        bufferevent_read_buffer(bev,</span><br><span class="line">            bufferevent_get_output(inf-&gt;other_bev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">count</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> last_fib[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">write_callback_fibonacci(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Here's a callback that adds some Fibonacci numbers to the</span></span><br><span class="line"><span class="comment">           output buffer of bev.  It stops once we have added 1k of</span></span><br><span class="line"><span class="comment">           data; once this data is drained, we'll add more. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">count</span> *<span class="title">c</span> = <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">tmp</span> = <span class="title">evbuffer_new</span>();</span></span><br><span class="line">        <span class="keyword">while</span> (evbuffer_get_length(tmp) &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">long</span> next = c-&gt;last_fib[<span class="number">0</span>] + c-&gt;last_fib[<span class="number">1</span>];</span><br><span class="line">                 c-&gt;last_fib[<span class="number">0</span>] = c-&gt;last_fib[<span class="number">1</span>];</span><br><span class="line">                 c-&gt;last_fib[<span class="number">1</span>] = next;</span><br><span class="line"></span><br><span class="line">                 evbuffer_add_printf(tmp, <span class="string">"%lu"</span>, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now we add the whole contents of tmp to bev. */</span></span><br><span class="line">        bufferevent_write_buffer(bev, tmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don't need tmp any longer. */</span></span><br><span class="line">        evbuffer_free(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="set-timeout"><a href="#set-timeout" class="headerlink" title="set timeout"></a>set timeout</h5><p>As with other events, you can have a timeout get invoked if a certain amount of time passes without any data having been successfully written or read by a bufferevent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *timeout_read, <span class="keyword">const</span> struct timeval *timeout_write)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Setting a timeout to NULL is supposed to remove it.</p>
<p>Note that <strong>the timeouts only count when the bufferevent would like to read or write</strong>. <em>In other words</em>, <strong>the read timeout is not enabled if reading is disabled on the bufferevent, or if the input buffer is full</strong> (at its high-water mark). Similarly, the write timeout is not enabled if if writing is disabled, or if there is no data to write.</p>
<p>When a read or write timeout occurs, the corresponding read or write operation <strong>becomes disabled</strong> on the bufferevent. The event callback is then invoked with either BEV_EVENT_TIMEOUT|BEV_EVENT_READING or BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.</p>
<h5 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_flush</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">short</span> iotype, <span class="keyword">enum</span> bufferevent_flush_mode state)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Flushing a bufferevent tells the bufferevent to force as many bytes as possible to be read to or written from the underlying transport, ignoring other restrictions that might otherwise keep them from being written. Its detailed function depends on the type of the bufferevent.</p>
<p>The iotype argument should be EV_READ, EV_WRITE, or EV_READ|EV_WRITE to indicate whether bytes being read, written, or both should be processed. The state argument may be one of BEV_NORMAL, BEV_FLUSH, or BEV_FINISHED. BEV_FINISHED indicates that the other side should be told that no more data will be sent; the distinction between BEV_NORMAL and BEV_FLUSH depends on the type of the bufferevent.</p>
<p>This function is only implemented for some bufferevent types. In particular, <strong>socket-based bufferevents don’t have it</strong>.</p>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><p>These bufferevent functions are <strong>not supported on all</strong> bufferevent types.</p>
<h5 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_priority_set</span><span class="params">(struct bufferevent *bufev, <span class="keyword">int</span> pri)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_get_priority</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>This function adjusts the priority of the events used to implement <em>bufev</em> to <em>pri</em>. See event_priority_set() for more information on priorities.</p>
<p> It works on <strong>socket-based</strong> bufferevents only.</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_setfd</span><span class="params">(struct bufferevent *bufev, <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">evutil_socket_t</span> bufferevent_getfd(struct bufferevent *bufev);</span><br><span class="line"><span class="comment">// Both return -1 on failure; setfd() returns 0 on success.</span></span><br></pre></td></tr></table></figure>
<p>These functions set or return the file descriptor for a fd-based event. </p>
<p>Only <strong>socket-based</strong> bufferevents support <code>setfd()</code>. </p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">bufferevent_get_base</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function returns the event_base of a bufferevent.</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_get_underlying</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function returns the bufferevent that another bufferevent is using as a transport, if any. For information on when this situation would occur, see notes on <strong>filtering</strong> bufferevents.</p>
<h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><p>As with evbuffers, sometimes you want to ensure that a number of operations on a bufferevent are all performed atomically. Libevent exposes functions that you can use to manually lock and unlock a bufferevent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_lock</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_unlock</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Note that locking a bufferevent <strong>has no effect if the bufferevent was not given the BEV_OPT_THREADSAFE thread on creation</strong>, or if Libevent’s threading support wasn’t activated.</p>
<p>Locking the bufferevent with this function <strong>will lock its associated evbuffers</strong> as well. These functions are <strong>recursive</strong>: it is safe to lock a bufferevent for which you already hold the lock. <em>You must call unlock once for every time that you locked the bufferevent.</em></p>
<h3 id="Evbuffers"><a href="#Evbuffers" class="headerlink" title="Evbuffers"></a>Evbuffers</h3><p>Libevent’s evbuffer functionality implements a queue of bytes, optimized for adding data to the end and removing it from the front.</p>
<p>Evbuffers are meant to be generally useful for doing the “buffer” part of buffered network IO. They do not provide functions to schedule the IO or trigger the IO when it’s ready: that is what bufferevents do.</p>
<h4 id="construct-2"><a href="#construct-2" class="headerlink" title="construct"></a>construct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">evbuffer_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_free</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_enable_locking</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_lock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_unlock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>By default, it is not safe to access an evbuffer from multiple threads at once. </p>
<p>If its <em>lock</em> argument is NULL, Libevent allocates a new lock using the lock creation function that was provided to <code>evthread_set_lock_creation_callback</code>. Otherwise, it uses the argument as the lock.</p>
<p>(Note that you do not need to call <code>evbuffer_lock()</code> and <code>evbuffer_unlock()</code> around <em>individual</em> operations: <strong>if locking is enabled on the evbuffer, individual operations are already atomic</strong>. You only need to lock the evbuffer manually when you have more than one operation that need to execute without another thread butting in.)</p>
<h4 id="Inspect"><a href="#Inspect" class="headerlink" title="Inspect"></a>Inspect</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> struct evbuffer *buf);</span><br></pre></td></tr></table></figure>
<p>This function returns the number of bytes stored in an evbuffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_contiguous_space(<span class="keyword">const</span> struct evbuffer *buf);</span><br></pre></td></tr></table></figure>
<p>This function returns the number of bytes stored contiguously at the front of the evbuffer. <em>The bytes in an evbuffer may be stored in multiple separate chunks of memory</em>; this function returns the number of bytes currently stored in the <em>first</em> chunk.</p>
<h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>This function appends the <em>datlen</em> bytes in <em>data</em> to the end of <em>buf</em>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_printf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_vprintf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// return the number of bytes appended.</span></span><br></pre></td></tr></table></figure>
<p>These functions append formatted data to the end of <em>buf</em>. The format argument and other remaining arguments are handled as if by the C library functions “printf” and “vprintf” respectively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_expand</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This function alters the last chunk of memory in the buffer, <em>or</em> adds a new chunk, such that the buffer is now large enough to contain datlen bytes without any further allocations.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer* src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>These functions behave as <code>evbuffer_add()</code> and <code>evbuffer_add_buffer()</code> respectively, except that they move data to the <em>front</em> of the destination buffer.</p>
<h5 id="move"><a href="#move" class="headerlink" title="move"></a>move</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer *src)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_buffer</span><span class="params">(struct evbuffer *src, struct evbuffer *dst,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="comment">// returns the number of bytes moved.</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_add_buffer()</code> function moves all data from <em>src</em> to the end of <em>dst</em>.</p>
<p>The <code>evbuffer_remove_buffer()</code> function moves exactly <em>datlen</em> bytes from <em>src</em> to the end of <em>dst</em>, copying as little as possible. If there are fewer than <em>datlen</em> bytes to move, it moves all the bytes.</p>
<h5 id="rearrange"><a href="#rearrange" class="headerlink" title="rearrange"></a>rearrange</h5><p>Sometimes you want to peek at the first N bytes of data in the front of an evbuffer, and see it as a contiguous array of bytes. To do this, you must first ensure that the front of the buffer really <em>is</em>contiguous.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">evbuffer_pullup</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_pullup()</code> function “linearizes” the first <em>size</em> bytes of <em>buf</em>, copying or moving them as needed to <em>ensure that they are all contiguous and occupying the same chunk of memory</em>. </p>
<p>If <em>size</em> is negative, the function linearizes the entire buffer. </p>
<p>If <em>size</em> is greater than the number of bytes in the buffer, the function <strong>returns NULL</strong>. Otherwise, <code>evbuffer_pullup()</code> <strong>returns a pointer to the first byte</strong> in buf.</p>
<p>Calling <code>evbuffer_pullup()</code> with a large size <em>can be quite slow</em>, since it potentially needs to copy the entire buffer’s contents.</p>
<p>Calling <code>evbuffer_pullup()</code> with size equal to the value returned by <code>evbuffer_get_contiguous_space()</code> will not result in any data being copied or moved.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_socks4</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_uint16_t</span> *port, <span class="keyword">ev_uint32_t</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let's parse the start of a SOCKS4 request!  The format is easy:</span></span><br><span class="line"><span class="comment">     * 1 byte of version, 1 byte of command, 2 bytes destport, 4 bytes of</span></span><br><span class="line"><span class="comment">     * destip. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    mem = evbuffer_pullup(buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Not enough data in the buffer */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mem[<span class="number">0</span>] != <span class="number">4</span> || mem[<span class="number">1</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Unrecognized protocol or command */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(port, mem+<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(addr, mem+<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        *port = ntohs(*port);</span><br><span class="line">        *addr = ntohl(*addr);</span><br><span class="line">        <span class="comment">/* Actually remove the data from the buffer now that we know we</span></span><br><span class="line"><span class="comment">           like it. */</span></span><br><span class="line">        evbuffer_drain(buf, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_drain</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success and -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="comment">// returns -1 on failure, and otherwise the number of bytes copied.</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_remove()</code> function copies and removes the first <em>datlen</em> bytes from the front of <em>buf</em> into the memory at <em>data</em>. If there are fewer than <em>datlen</em> bytes available, the function copies all the bytes there are.</p>
<p>The <code>evbuffer_drain()</code> function behaves as evbuffer_remove(), except that it does not copy the data: it just removes it from the front of the buffer.</p>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>Sometimes you want to get a copy of the data at the start of a buffer without draining it. For example, you might want to see whether a complete record of some kind has arrived, <em>without</em> draining any of the data (as <code>evbuffer_remove()</code> would do), or rearranging the buffer internally (as <code>evbuffer_pullup()</code> would do.)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen);</span><br><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout_from(struct evbuffer *buf,</span><br><span class="line">     <span class="keyword">const</span> struct evbuffer_ptr *pos,</span><br><span class="line">     <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen);</span><br><span class="line"><span class="comment">// returns -1 on failure, and otherwise the number of bytes copied.</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_copyout()</code> behaves just like <code>evbuffer_remove()</code>, but does not drain any data from the buffer.</p>
<p>The <code>evbuffer_copyout_from()</code> function behaves like <code>evbuffer_copyout()</code>, but instead of copying bytes from the front of the buffer, it copies them beginning at the position provided in <em>pos</em>. <em>See “Searching within an evbuffer” below for information on the evbuffer_ptr structure.</em></p>
<p>If copying data from the buffer is too slow, use <code>evbuffer_peek()</code> instead.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_record</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> *size_out, <span class="keyword">char</span> **record_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let's assume that we're speaking some protocol where records</span></span><br><span class="line"><span class="comment">       contain a 4-byte size field in network order, followed by that</span></span><br><span class="line"><span class="comment">       number of bytes.  We will return 1 and set the 'out' fields if we</span></span><br><span class="line"><span class="comment">       have a whole record, return 0 if the record isn't here yet, and</span></span><br><span class="line"><span class="comment">       -1 on error.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_len = evbuffer_get_length(buf);</span><br><span class="line">    <span class="keyword">ev_uint32_t</span> record_len;</span><br><span class="line">    <span class="keyword">char</span> *record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer_len &lt; <span class="number">4</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* The size field hasn't arrived. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* We use evbuffer_copyout here so that the size field will stay on</span></span><br><span class="line"><span class="comment">       the buffer for now. */</span></span><br><span class="line">    evbuffer_copyout(buf, &amp;record_len, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* Convert len_buf into host order. */</span></span><br><span class="line">    record_len = ntohl(record_len);</span><br><span class="line">    <span class="keyword">if</span> (buffer_len &lt; record_len + <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* The record hasn't arrived */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Okay, _now_ we can remove the record. */</span></span><br><span class="line">    record = <span class="built_in">malloc</span>(record_len);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    evbuffer_drain(buf, <span class="number">4</span>);</span><br><span class="line">    evbuffer_remove(buf, record, record_len);</span><br><span class="line"></span><br><span class="line">    *record_out = record;</span><br><span class="line">    *size_out = record_len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="line-based"><a href="#line-based" class="headerlink" title="line-based"></a>line-based</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> evbuffer_eol_style &#123;</span><br><span class="line">        EVBUFFER_EOL_ANY,</span><br><span class="line">        EVBUFFER_EOL_CRLF,</span><br><span class="line">        EVBUFFER_EOL_CRLF_STRICT,</span><br><span class="line">        EVBUFFER_EOL_LF,</span><br><span class="line">        EVBUFFER_EOL_NUL</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer *buffer, <span class="keyword">size_t</span> *n_read_out,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Many Internet protocols use line-based formats. The <code>evbuffer_readln()</code> function extracts a line from the front of an evbuffer and returns it in a newly allocated NULL-terminated string. Remember to free it.</p>
<p>If <em>n_read_out</em> is not NULL, <em>\</em>n_read_out<em> is set to the number of bytes in the string returned. If there is not a whole line to read, the function returns NULL. </em>The line terminator is not included in the copied string.*</p>
<p>The <code>evbuffer_readln()</code> function understands 4 line termination formats:</p>
<ul>
<li><p>EVBUFFER_EOL_LF</p>
<p>The end of a line is a single linefeed character. (This is also known as <strong>“\n”</strong>. It is ASCII value is 0x0A.)</p>
</li>
<li><p>EVBUFFER_EOL_CRLF_STRICT</p>
<p>The end of a line is a single carriage return, followed by a single linefeed. (This is also known as <strong>“\r\n”</strong>. The ASCII values are 0x0D 0x0A).</p>
</li>
<li><p>EVBUFFER_EOL_CRLF</p>
<p>The end of the line is an optional carriage return, followed by a linefeed. (In other words, it is either a <strong>“\r\n”</strong> or a <strong>“\n”</strong>.) This format is <em>useful in parsing text-based Internet protocols</em>.</p>
</li>
<li><p>EVBUFFER_EOL_ANY</p>
<p>The end of line is any sequence of any number of carriage return and linefeed characters. <em>This format is not very useful</em>; it exists mainly for backward compatibility.</p>
</li>
<li><p>EVBUFFER_EOL_NUL</p>
<p>The end of line is a single byte with the value 0 — that is, an <strong>ASCII NULL</strong>.</p>
</li>
</ul>
<p>(Note that if you used <code>event_set_mem_functions()</code> to override the default malloc, the string returned by evbuffer_readln will be allocated by the malloc-replacement you specified.)</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *request_line;</span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">request_line = evbuffer_readln(buf, &amp;len, EVBUFFER_EOL_CRLF);</span><br><span class="line"><span class="keyword">if</span> (!request_line) &#123;</span><br><span class="line">    <span class="comment">/* The first line has not arrived yet. */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(request_line, <span class="string">"HTTP/1.0 "</span>, <span class="number">9</span>)) &#123;</span><br><span class="line">        <span class="comment">/* HTTP 1.0 detected ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(request_line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sarch"><a href="#sarch" class="headerlink" title="sarch"></a>sarch</h5><p>The <strong>evbuffer_ptr structure</strong> points to a location within an evbuffer, and contains data that you can use to iterate through an evbuffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_ptr</span> &#123;</span></span><br><span class="line">        <span class="keyword">ev_ssize_t</span> pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="comment">/* internal fields */</span></span><br><span class="line">        &#125; _internal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>The <em>pos</em> field is the only public field</strong>; the others should not be used by user code. It indicates a position in the evbuffer as an offset from the start.</p>
<p><em>WARNING</em>: Any call that modifies an evbuffer or its layout invalidates all outstanding evbuffer_ptr values, and makes them unsafe to use.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start)</span></span>;</span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_range</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct evbuffer_ptr *end)</span></span>;</span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_eol</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_ptr *start, <span class="keyword">size_t</span> *eol_len_out,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_search()</code> function scans the buffer for an occurrence of the <em>len</em>-character string <em>what</em>.</p>
<p><strong>It returns an evbuffer_ptr containing the position of the string, or -1 if the string was not found</strong>. If the <em>start</em> argument is provided, it’s the position at which the search should begin; otherwise, the search is from the start of the string.</p>
<p>The <code>evbuffer_search_range()</code> function behaves as <code>evbuffer_search()</code>, except that it only considers occurrences of <em>what</em> that occur before the evbuffer_ptr <em>end</em>.</p>
<p>The <code>evbuffer_search_eol()</code> function detects line-endings as <code>evbuffer_readln()</code>, but instead of copying out the line, returns an evbuffer_ptr to the start of the end-of-line character(s). If eol_len_out is non-NULL, it is set to the length of the EOL string.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> evbuffer_ptr_how &#123;</span><br><span class="line">        EVBUFFER_PTR_SET,</span><br><span class="line">        EVBUFFER_PTR_ADD</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_ptr_set</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *pos,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> position, <span class="keyword">enum</span> evbuffer_ptr_how how)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>The evbuffer_ptr_set function manipulates the position of an evbuffer_ptr <em>pos</em> within <em>buffer</em>. If <em>how</em> is EVBUFFER_PTR_SET, the pointer is moved to an absolute position <em>position</em> within the buffer. If it is EVBUFFER_PTR_ADD, the pointer moves <em>position</em> bytes forward.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count the total occurrences of 'str' in 'buf'. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_instances</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_ptr</span> <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">        <span class="comment">/* Don't try to count the occurrences of a 0-length string. */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    evbuffer_ptr_set(buf, &amp;p, <span class="number">0</span>, EVBUFFER_PTR_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         p = evbuffer_search(buf, str, len, &amp;p);</span><br><span class="line">         <span class="keyword">if</span> (p.pos &lt; <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         total++;</span><br><span class="line">         evbuffer_ptr_set(buf, &amp;p, <span class="number">1</span>, EVBUFFER_PTR_ADD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h5><p>Sometimes, you want to read data in an evbuffer without copying it out (as <code>evbuffer_copyout()</code> does), and without rearranging the evbuffer’s internal memory (as <code>evbuffer_pullup()</code> does). Sometimes you might want to see data in the middle of an evbuffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *iov_base;</span><br><span class="line">        <span class="keyword">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_peek</span><span class="params">(struct evbuffer *buffer, <span class="keyword">ev_ssize_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_ptr *start_at,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_iovec *vec_out, <span class="keyword">int</span> n_vec)</span></span>;</span><br></pre></td></tr></table></figure>
<p>When you call <code>evbuffer_peek()</code>, you give it an array of evbuffer_iovec structures in <em>vec_out</em>. The array’s length is <em>n_vec</em>. It sets these structures so that each one contains a pointer to a chunk of the evbuffer’s internal RAM (<em>iov_base</em>), and the length of memory that is set in that chunk.</p>
<p>If <em>len</em> is less than 0, <code>evbuffer_peek()</code> tries to fill all of the evbuffer_iovec structs you have given it. Otherwise, <strong><em>it fills them until either they are all used, or at least len bytes are visible</em></strong>. If the function could give you all the data you asked for, it returns the number of evbuffer_iovec structures that it actually used. Otherwise, it returns the number that it would need in order to give what you asked for.</p>
<p>When <em>start_at</em> is NULL, <code>evbuffer_peek()</code> starts at the beginning of the buffer. Otherwise, it starts at the pointer given in <em>start_at</em>.</p>
<p><strong>Notes</strong></p>
<ul>
<li>Modifying the data pointed to by the evbuffer_iovec can result in undefined behavior.</li>
<li>If any function is called that modifies the evbuffer, the pointers that <code>evbuffer_peek()</code> yields may become invalid.</li>
<li>If your evbuffer could be used in multiple threads, make sure to lock it with <code>evbuffer_lock()</code> before you call <code>evbuffer_peek()</code>, and unlock it once you are done using the extents that <code>evbuffer_peek()</code> gave you.</li>
</ul>
<p><strong>Examples</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Let's look at the first two chunks of buf, and write them to stderr. */</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> <span class="title">v</span>[2];</span></span><br><span class="line">    n = evbuffer_peek(buf, <span class="number">-1</span>, <span class="literal">NULL</span>, v, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) &#123; <span class="comment">/* There might be less than two chunks available. */</span></span><br><span class="line">        fwrite(v[i].iov_base, <span class="number">1</span>, v[i].iov_len, <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Let's send the first 4906 bytes to stdout via write. */</span></span><br><span class="line">    <span class="keyword">int</span> n, i, r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> written = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine how many chunks we need. */</span></span><br><span class="line">    n = evbuffer_peek(buf, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Allocate space for the chunks.  This would be a good time to use</span></span><br><span class="line"><span class="comment">       alloca() if you have it. */</span></span><br><span class="line">    v = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct evbuffer_iovec)*n);</span><br><span class="line">    <span class="comment">/* Actually fill up v. */</span></span><br><span class="line">    n = evbuffer_peek(buf, <span class="number">4096</span>, <span class="literal">NULL</span>, v, n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = v[i].iov_len;</span><br><span class="line">        <span class="keyword">if</span> (written + len &gt; <span class="number">4096</span>)</span><br><span class="line">            len = <span class="number">4096</span> - written;</span><br><span class="line">        r = write(<span class="number">1</span> <span class="comment">/* stdout */</span>, v[i].iov_base, len);</span><br><span class="line">        <span class="keyword">if</span> (r&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* We keep track of the bytes written separately; if we don't,</span></span><br><span class="line"><span class="comment">           we may write more than 4096 bytes if the last chunk puts</span></span><br><span class="line"><span class="comment">           us over the limit. */</span></span><br><span class="line">        written += len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Let's get the first 16K of data after the first occurrence of the</span></span><br><span class="line"><span class="comment">       string "start\n", and pass it to a consume() function. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_ptr</span> <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> <span class="title">v</span>[1];</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> s[] = <span class="string">"start\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> n_written;</span><br><span class="line"></span><br><span class="line">    ptr = evbuffer_search(buf, s, <span class="built_in">strlen</span>(s), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr.pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* no start string found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance the pointer past the start string. */</span></span><br><span class="line">    <span class="keyword">if</span> (evbuffer_ptr_set(buf, &amp;ptr, <span class="built_in">strlen</span>(s), EVBUFFER_PTR_ADD) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* off the end of the string. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n_written &lt; <span class="number">16</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">/* Peek at a single chunk. */</span></span><br><span class="line">        <span class="keyword">if</span> (evbuffer_peek(buf, <span class="number">-1</span>, &amp;ptr, v, <span class="number">1</span>) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Pass the data to some user-defined consume function */</span></span><br><span class="line">        consume(v[<span class="number">0</span>].iov_base, v[<span class="number">0</span>].iov_len);</span><br><span class="line">        n_written += v[<span class="number">0</span>].iov_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advance the pointer so we see the next chunk next time. */</span></span><br><span class="line">        <span class="keyword">if</span> (evbuffer_ptr_set(buf, &amp;ptr, v[<span class="number">0</span>].iov_len, EVBUFFER_PTR_ADD)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>Sometimes you want to insert data into an evbuffer directly, without first writing it into a character array and then copying it in with <code>evbuffer_add()</code>. There are an advanced pair of functions you can use to do this: <code>evbuffer_reserve_space()</code> and <code>evbuffer_commit_space()</code>. As with <code>evbuffer_peek()</code>, these functions use the evbuffer_iovec structure to provide direct access to memory inside the evbuffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_reserve_space</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br><span class="line"><span class="comment">// returns the number of provided vectors that needed for the space requested</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_commit_space</span><span class="params">(struct evbuffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success and -1 on failure</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_reserve_space()</code> function gives you pointers to space inside the evbuffer. It expands the buffer as necessary to give you at least <em>size</em> bytes. The pointers to these extents, and their lengths, will be stored in the array of vectors you pass in with <em>vec</em>; <em>n_vec</em> is the length of this array.</p>
<p><strong>The value of <em>n_vec</em> must be at least 1</strong>. If you provide only one vector, then Libevent will ensure that you have all the contiguous space you requested in a single extent, but it may have to rearrange the buffer or waste memory in order to do so. For better performance, provide at least 2 vectors.</p>
<p>The data that you write into these vectors is not part of the buffer until you call <code>evbuffer_commit_space()</code>, which actually makes the data you wrote count as being in the buffer. If you want to commit less space than you asked for, you can decrease the iov_len field in any of the evbuffer_iovec structures you were given. You can also pass back fewer vectors than you were given.</p>
<p><strong>Notes</strong></p>
<ul>
<li>Calling any function that rearranges the evbuffer or adds data to it evbuffer will invalidate the pointers you got from <code>evbuffer_reserve_space()</code>.</li>
<li>In the <strong>current implementation</strong>, <code>evbuffer_reserve_space()</code> <strong>never uses more than two vectors</strong>, no matter how many the user supplies. This may change in a future release.</li>
<li>It is safe to call <code>evbuffer_reserve_space()</code> any number of times.</li>
<li>If your evbuffer could be used in multiple threads, make sure to lock it with <code>evbuffer_lock()</code> before you call <code>evbuffer_reserve_space()</code>, and unlock it once you commit.</li>
</ul>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Suppose we want to fill a buffer with 2048 bytes of output from a</span></span><br><span class="line"><span class="comment">   generate_data() function, without copying. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> <span class="title">v</span>[2];</span></span><br><span class="line"><span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">size_t</span> n_to_add = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reserve 2048 bytes.*/</span></span><br><span class="line">n = evbuffer_reserve_space(buf, n_to_add, v, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">/* Unable to reserve the space for some reason. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n &amp;&amp; n_to_add &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">   <span class="keyword">size_t</span> len = v[i].iov_len;</span><br><span class="line">   <span class="keyword">if</span> (len &gt; n_to_add) <span class="comment">/* Don't write more than n_to_add bytes. */</span></span><br><span class="line">      len = n_to_add;</span><br><span class="line">   <span class="keyword">if</span> (generate_data(v[i].iov_base, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* If there was a problem during data generation, we can just stop</span></span><br><span class="line"><span class="comment">         here; no data will be committed to the buffer. */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Set iov_len to the number of bytes we actually wrote, so we</span></span><br><span class="line"><span class="comment">      don't commit too much. */</span></span><br><span class="line">   v[i].iov_len = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We commit the space here.  Note that we give it 'i' (the number of</span></span><br><span class="line"><span class="comment">   vectors we actually used) rather than 'n' (the number of vectors we</span></span><br><span class="line"><span class="comment">   had available. */</span></span><br><span class="line"><span class="keyword">if</span> (evbuffer_commit_space(buf, v, i) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">/* Error committing */</span></span><br></pre></td></tr></table></figure>
<p><strong>Bad Examples</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Here are some mistakes you can make with evbuffer_reserve().</span></span><br><span class="line"><span class="comment">   DO NOT IMITATE THIS CODE. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> <span class="title">v</span>[2];</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Do not use the pointers from evbuffer_reserve_space() after</span></span><br><span class="line"><span class="comment">     calling any functions that modify the buffer. */</span></span><br><span class="line">  evbuffer_reserve_space(buf, <span class="number">1024</span>, v, <span class="number">2</span>);</span><br><span class="line">  evbuffer_add(buf, <span class="string">"X"</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* WRONG: This next line won't work if evbuffer_add needed to rearrange</span></span><br><span class="line"><span class="comment">     the buffer's contents.  It might even crash your program. Instead,</span></span><br><span class="line"><span class="comment">     you add the data before calling evbuffer_reserve_space. */</span></span><br><span class="line">  <span class="built_in">memset</span>(v[<span class="number">0</span>].iov_base, <span class="string">'Y'</span>, v[<span class="number">0</span>].iov_len<span class="number">-1</span>);</span><br><span class="line">  evbuffer_commit_space(buf, v, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Do not modify the iov_base pointers. */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *data = <span class="string">"Here is some data"</span>;</span><br><span class="line">  evbuffer_reserve_space(buf, <span class="built_in">strlen</span>(data), v, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* WRONG: The next line will not do what you want.  Instead, you</span></span><br><span class="line"><span class="comment">     should _copy_ the contents of data into v[0].iov_base. */</span></span><br><span class="line">  v[<span class="number">0</span>].iov_base = (<span class="keyword">char</span>*) data;</span><br><span class="line">  v[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(data);</span><br><span class="line">  <span class="comment">/* In this case, evbuffer_commit_space might give an error if you're</span></span><br><span class="line"><span class="comment">     lucky */</span></span><br><span class="line">  evbuffer_commit_space(buf, v, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="network-IO"><a href="#network-IO" class="headerlink" title="network IO"></a>network IO</h4><p>The most common use case for evbuffers in Libevent is network IO. The interface for performing network IO on an evbuffer is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_read</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> howmuch)</span></span>;</span><br><span class="line"><span class="comment">// returns a number of bytes read on success, 0 on EOF, and -1 on an error. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write_atmost</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">ev_ssize_t</span> howmuch)</span></span>;</span><br><span class="line"><span class="comment">// returns a number of bytes written on success, and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_read()</code> function reads up to <em>howmuch</em> bytes from the socket <em>fd</em> onto the end of <em>buffer</em>. Note that the error may indicate that a nonblocking operation would not succeed; <strong>you need to check the error code for EAGAIN</strong> (or WSAEWOULDBLOCK on Windows). If <em>howmuch</em> is negative, <code>evbuffer_read()</code> tries to guess how much to read itself.</p>
<p>The <code>evbuffer_write_atmost()</code> function tries to write up to <em>howmuch</em> bytes from the front of <em>buffer</em> onto the socket <em>fd</em>. As with <code>evbuffer_read()</code>, you need to <strong>check the error code</strong> to see whether the error is real, or just indicates that nonblocking IO could not be completed immediately. If you give a negative value for <em>howmuch</em>, we try to write the entire contents of the buffer.</p>
<p>Calling <code>evbuffer_write()</code> is the same as calling <code>evbuffer_write_atmost()</code> with a negative <em>howmuch</em> argument: it attempts to flush as much of the buffer as it can.</p>
<p>On Unix, these functions should work on any file descriptor that supports read and write. On Windows, only sockets are supported.</p>
<p><strong>Note that when you are using bufferevents, you do not need to call these IO functions; the bufferevents code does it for you.</strong></p>
<h4 id="callbacks-1"><a href="#callbacks-1" class="headerlink" title="callbacks"></a>callbacks</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> orig_size;</span><br><span class="line">        <span class="keyword">size_t</span> n_added;</span><br><span class="line">        <span class="keyword">size_t</span> n_deleted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_cb_func)</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct evbuffer_cb_info *info, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>An evbuffer callback <strong>is invoked whenever data is added to or removed from the evbuffer</strong>. It receives the buffer, a pointer to an evbuffer_cb_info structure, and a user-supplied argument. </p>
<p>The evbuffer_cb_info structure’s orig_size field records how many bytes there were on the buffer before its size changed; its n_added field records how many bytes were added to the buffer, and its n_deleted field records how many bytes were removed.</p>
<h5 id="add-cb"><a href="#add-cb" class="headerlink" title="add_cb"></a>add_cb</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_entry</span>;</span></span><br><span class="line"><span class="function">struct evbuffer_cb_entry *<span class="title">evbuffer_add_cb</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_add_cb()</code> function adds a callback to an evbuffer, and returns an opaque pointer that can later be used to refer to this particular callback instance. The <em>cb</em> argument is the function that will be invoked, and the <em>cbarg</em> is the user-supplied pointer to pass to the function.</p>
<p>You <strong>can have multiple callbacks set on a single evbuffer</strong>. Adding a new callback does not remove old callbacks.</p>
<p><strong>example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here's a callback that remembers how many bytes we have drained in</span></span><br><span class="line"><span class="comment">   total from the buffer, and prints a dot every time we hit a</span></span><br><span class="line"><span class="comment">   megabyte. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">total_processed</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_megabytes_cb</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct evbuffer_cb_info *info, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">total_processed</span> *<span class="title">tp</span> = <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> old_n = tp-&gt;n;</span><br><span class="line">    <span class="keyword">int</span> megabytes, i;</span><br><span class="line">    tp-&gt;n += info-&gt;n_deleted;</span><br><span class="line">    megabytes = ((tp-&gt;n) &gt;&gt; <span class="number">20</span>) - (old_n &gt;&gt; <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;megabytes; ++i)</span><br><span class="line">        putc(<span class="string">'.'</span>, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation_with_counted_bytes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">total_processed</span> *<span class="title">tp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">tp</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">buf</span> = <span class="title">evbuffer_new</span>();</span></span><br><span class="line">    tp-&gt;n = <span class="number">0</span>;</span><br><span class="line">    evbuffer_add_cb(buf, count_megabytes_cb, tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the evbuffer for a while.  When we're done: */</span></span><br><span class="line">    evbuffer_free(buf);</span><br><span class="line">    <span class="built_in">free</span>(tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note in passing that freeing a nonempty evbuffer does not count as draining data from it, and that freeing an evbuffer does not free the user-supplied data pointer for its callbacks.</p>
<h5 id="remove-cb"><a href="#remove-cb" class="headerlink" title="remove_cb"></a>remove_cb</h5><p>If you don’t want a callback to be permanently active on a buffer, you can <em>remove</em> it (to make it gone for good), or disable it (to turn it off for a while):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb_entry</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer_cb_entry *ent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"><span class="comment">// return 0 on success and -1 on failure</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVBUFFER_CB_ENABLED 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_set_flags</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                          struct evbuffer_cb_entry *cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_clear_flags</span><span class="params">(struct evbuffer *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                          struct evbuffer_cb_entry *cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You can remove a callback either by the evbuffer_cb_entry you got when you added it, or by the callback and pointer you used.</p>
<p>The <code>evbuffer_cb_set_flags()</code> function and the <code>evbuffer_cb_clear_flags()</code> function make a given flag be set or cleared on a given callback respectively. <strong>Right now, only one user-visible flag is supported: <em>EVBUFFER_CB_ENABLED</em>.</strong> The flag is set by default. When it is cleared, modifications to the evbuffer do not cause this callback to get invoked.</p>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_defer_callbacks</span><span class="params">(struct evbuffer *buffer, struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>As with bufferevent callbacks, you can cause evbuffer callbacks to not run immediately when the evbuffer is changed, but rather to be <em>deferred</em> and run as part of the event loop of a given event base. This can be helpful if you have multiple evbuffers whose callbacks potentially cause data to be added and removed from one another, and you want to avoid smashing the stack.</p>
<p><strong>Like bufferevents</strong>, evbuffers are internally reference-counted, so that it is safe to free an evbuffer even if it has deferred callbacks that have not yet executed.</p>
<h5 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h5><p>Really fast network programming often calls for doing as few data copies as possible.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_ref_cleanup_cb)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> datalen, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_reference</span><span class="params">(struct evbuffer *outbuf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen,</span></span></span><br><span class="line"><span class="function"><span class="params">    evbuffer_ref_cleanup_cb cleanupfn, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>This function adds a piece of data <strong>to the end</strong> of an evbuffer <em>by reference</em>. No copy is performed: instead, the evbuffer just stores a pointer to the <em>datlen</em> bytes stored at <em>data</em>. <strong>Therefore, the pointer must remain valid for as long as the evbuffer is using it. When the evbuffer no longer needs data, it will call the provided “cleanupfn” function</strong> with the provided “data” pointer, “datlen” value, and “extra” pointer as arguments.</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* In this example, we have a bunch of evbuffers that we want to use to</span></span><br><span class="line"><span class="comment">   spool a one-megabyte resource out to the network.  We do this</span></span><br><span class="line"><span class="comment">   without keeping any more copies of the resource in memory than</span></span><br><span class="line"><span class="comment">   necessary. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUGE_RESOURCE_SIZE (1024*1024)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">huge_resource</span> &#123;</span></span><br><span class="line">    <span class="comment">/* We keep a count of the references that exist to this structure,</span></span><br><span class="line"><span class="comment">       so that we know when we can free it. */</span></span><br><span class="line">    <span class="keyword">int</span> reference_count;</span><br><span class="line">    <span class="keyword">char</span> data[HUGE_RESOURCE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct huge_resource *<span class="title">new_resource</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">huge_resource</span> *<span class="title">hr</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">huge_resource</span>));</span></span><br><span class="line">    hr-&gt;reference_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Here we should fill hr-&gt;data with something.  In real life,</span></span><br><span class="line"><span class="comment">       we'd probably load something or do a complex calculation.</span></span><br><span class="line"><span class="comment">       Here, we'll just fill it with EEs. */</span></span><br><span class="line">    <span class="built_in">memset</span>(hr-&gt;data, <span class="number">0xEE</span>, <span class="keyword">sizeof</span>(hr-&gt;data));</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_resource</span><span class="params">(struct huge_resource *hr)</span> </span>&#123;</span><br><span class="line">    --hr-&gt;reference_count;</span><br><span class="line">    <span class="keyword">if</span> (hr-&gt;reference_count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">free</span>(hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    free_resource(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the function that actually adds the resource to the</span></span><br><span class="line"><span class="comment">   buffer. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spool_resource_to_evbuffer</span><span class="params">(struct evbuffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct huge_resource *hr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++hr-&gt;reference_count;</span><br><span class="line">    evbuffer_add_reference(buf, hr-&gt;data, HUGE_RESOURCE_SIZE,</span><br><span class="line">        cleanup, hr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>Adding an evbuffer to another by reference</em></strong></p>
<p>You can also add one evbuffer’s to another by reference: rather than removing the contents of one buffer and adding them to another, you give one evbuffer a reference to another, and it behaves as though you had copied all the bytes in.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer_reference</span><span class="params">(struct evbuffer *outbuf,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evbuffer *inbuf)</span></span>;</span><br><span class="line"><span class="comment">// returns 0 if successful and -1 on failure.</span></span><br></pre></td></tr></table></figure>
<p>The <code>evbuffer_add_buffer_reference()</code> function behaves as though you had copied all the data from <em>outbuf</em> to <em>inbuf</em>, but does not perform any unnecessary copies.</p>
<p>Note that subsequent changes to the contents of <em>inbuf</em> are not reflected in <em>outbuf</em>: this function adds the current contents of the evbuffer by reference, not the evbuffer itself.</p>
<p>Note also that you cannot nest buffer references: a buffer that has already been the <em>outbuf</em> of one evbuffer_add_buffer_reference call cannot be the <em>inbuf</em> of another.</p>
<h4 id="other-1"><a href="#other-1" class="headerlink" title="other"></a>other</h4><p><strong>file</strong></p>
<p>Some operating systems provide ways to write files to the network without ever copying the data to userspace. </p>
<p>see: <a href="http://www.wangafu.net/~nickm/libevent-book/Ref7_evbuffer.html" target="_blank" rel="noopener">http://www.wangafu.net/~nickm/libevent-book/Ref7_evbuffer.html</a></p>
<hr>
<p><strong>add- or remove-only</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_freeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_unfreeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You can use these functions to temporarily disable changes to the front or end of an evbuffer. The <em>bufferevent code uses them internally</em> to prevent accidental modifications to the front of an output buffer, or the end of an input buffer.(因为output buffer是在后面添加数据，input buffer是从前面读取数据)</p>
<h3 id="Evconnlistener"><a href="#Evconnlistener" class="headerlink" title="Evconnlistener"></a>Evconnlistener</h3><p>The evconnlistener mechanism gives you a way to listen for and accept incoming <strong>TCP</strong> connections.</p>
<p><code>#include &lt;event2/listener.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The two new functions both allocate and return a new connection listener object.</p>
<p>The <strong><em>cb</em></strong> function is a callback to invoke when a new connection is received; <strong>if <em>cb</em> is NULL</strong>, the listener is treated as disabled until a callback is set. The <em>ptr</em> pointer will be passed to the callback.</p>
<p>The <strong><em>backlog</em></strong> parameter controls the maximum number of pending connections that the network stack should allow to wait in a not-yet-accepted state at any time; see documentation for your system’s <code>listen()</code> function for more details. <strong>If <em>backlog</em> is negative</strong>, Libevent tries to pick a good value for the backlog; <strong>if it is zero</strong>, Libevent assumes that you have already called listen() on the socket you are providing it.</p>
<p>The functions differ in how they set up their listener socket. The <code>evconnlistener_new()</code> function assumes that you have already bound a socket to the port you want to listen on, and that you’re passing the socket in as <em>fd</em>. If you want Libevent to allocate and bind to a socket on its own, call <code>evconnlistener_new_bind()</code>, and pass in the sockaddr you want to bind to, and its length.</p>
<p>To free a connection listener, pass it to <code>evconnlistener_free()</code>.</p>
<h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><ul>
<li><p>LEV_OPT_LEAVE_SOCKETS_BLOCKING</p>
<p><strong>By default</strong>, when the connection listener accepts a new incoming socket, it sets it up to be <strong>nonblocking</strong> so that you can use it with the rest of Libevent. Set this flag if you do not want this behavior.</p>
</li>
<li><p>LEV_OPT_CLOSE_ON_FREE</p>
<p>If this option is set, the connection listener closes its underlying socket when you free it.</p>
</li>
<li><p>LEV_OPT_CLOSE_ON_EXEC</p>
<p>If this option is set, the connection listener sets the close-on-exec flag on the underlying listener socket. See your platform documentation for fcntl and FD_CLOEXEC for more information.</p>
</li>
<li><p>LEV_OPT_REUSEABLE</p>
<p>By default on some platforms, once a listener socket is closed, no other socket can bind to the same port until a while has passed. Setting this option makes Libevent mark the socket as reusable, so that once it is closed, another socket can be opened to listen on the same port.</p>
</li>
<li><p>LEV_OPT_THREADSAFE</p>
<p>Allocate locks for the listener, so that it’s safe to use it from multiple threads. New in Libevent 2.0.8-rc.</p>
</li>
<li><p>LEV_OPT_DISABLED</p>
<p>Initialize the listener to be disabled, not enabled. You can turn it on manually with <code>evconnlistener_enable()</code>.</p>
</li>
</ul>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> sock, struct sockaddr *addr, <span class="keyword">int</span> len, <span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>When a new connection is received, the provided callback function is invoked. The <em>listener</em> argument is the connection listener that received the connection. The <em>sock</em> argument is the new socket itself. The <em>addr</em> and <em>len</em> arguments are the address from which the connection was received and the length of that address respectively. The <em>ptr</em> argument is the user-supplied pointer that was passed to <code>evconnlistener_new()</code>.</p>
<h4 id="enable-disable"><a href="#enable-disable" class="headerlink" title="enable/disable"></a>enable/disable</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_disable</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_enable</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>These functions temporarily disable or reenable listening for new connections.</p>
<h4 id="adjuste-cb"><a href="#adjuste-cb" class="headerlink" title="adjuste cb"></a>adjuste cb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void evconnlistener_set_cb(struct evconnlistener *lev,</span><br><span class="line">    evconnlistener_cb cb, void *arg);</span><br></pre></td></tr></table></figure>
<p>This function adjusts the callback and callback argument of an existing evconnlistener. </p>
<h4 id="Inspect-1"><a href="#Inspect-1" class="headerlink" title="Inspect"></a>Inspect</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">evutil_socket_t</span> evconnlistener_get_fd(struct evconnlistener *lev);</span><br><span class="line"><span class="function">struct event_base *<span class="title">evconnlistener_get_base</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>These functions return a listener’s associated socket and event_base respectively.</p>
<h4 id="error-cb"><a href="#error-cb" class="headerlink" title="error cb"></a>error cb</h4><p>You can set an error callback that gets informed whenever an accept() call fails on the listener. This can be important to do if you’re facing an error condition that would lock the process unless you addressed it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_errorcb)</span><span class="params">(struct evconnlistener *lis, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_error_cb</span><span class="params">(struct evconnlistener *lev,</span></span></span><br><span class="line"><span class="function"><span class="params">    evconnlistener_errorcb errorcb)</span></span>;</span><br></pre></td></tr></table></figure>
<p>If you use <code>evconnlistener_set_error_cb()</code> to set an error callback on a listener, the callback will be invoked every time that an error occurs on the listener. It will receive the listener as its first argument, and the argument passed as <em>ptr</em> to <code>evconnlistener_new()</code> as its second argument.</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2019/03/27/Network/IO/libevent/">libevent</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">Skuaka</a></p>
        <p><span>Created:</span>2019-03-27, 22:47:57</p>
        <p><span>Updated:</span>2019-04-21, 20:46:39</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2019/03/27/Network/IO/libevent/" title="libevent">http://skuaka.cn/2019/03/27/Network/IO/libevent/</a>
            <span class="copy-path" data-clipboard-text="From http://skuaka.cn/2019/03/27/Network/IO/libevent/　　By Skuaka" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/04/01/Unix/Programming/Git笔记/">
                    Git使用笔记
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/03/25/Operating System/操作系统知识点/">
                    操作系统知识点
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#libevent"><span class="toc-number">1.</span> <span class="toc-text">libevent</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Components"><span class="toc-number">1.1.1.</span> <span class="toc-text">Components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Libraries"><span class="toc-number">1.1.2.</span> <span class="toc-text">Libraries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headers"><span class="toc-number">1.1.3.</span> <span class="toc-text">Headers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Program"><span class="toc-number">1.2.</span> <span class="toc-text">Program</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lib-setup"><span class="toc-number">1.2.1.</span> <span class="toc-text">Lib setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可移植工具"><span class="toc-number">1.2.2.</span> <span class="toc-text">可移植工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可移植类型"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">可移植类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间操纵函数"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">时间操纵函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#套接字api"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">套接字api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#随机数生成"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">随机数生成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-base"><span class="toc-number">1.2.3.</span> <span class="toc-text">Event_base</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程？"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认初始化"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">默认初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置初始化"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">配置初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#例子"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看配置"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">查看配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放event-base"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">释放event_base</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置优先级"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">设置优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork之后重置"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">fork之后重置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-loop"><span class="toc-number">1.2.4.</span> <span class="toc-text">Event loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">stop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#example"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">example</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检查退出原因"><span class="toc-number">1.2.4.2.2.</span> <span class="toc-text">检查退出原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#other-api"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">other api</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#time-cache"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">time cache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dump-status"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">dump status</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#foreach"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">foreach</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Events"><span class="toc-number">1.2.5.</span> <span class="toc-text">Events</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#construct"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">construct</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Timeout-only"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">Timeout-only</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal-events"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">signal events</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#assign"><span class="toc-number">1.2.5.1.3.</span> <span class="toc-text">assign</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#use"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">use</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#priorities"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">priorities</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-status"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">event status</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#one-off-events"><span class="toc-number">1.2.5.2.3.</span> <span class="toc-text">one-off events</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#manually-activate"><span class="toc-number">1.2.5.2.4.</span> <span class="toc-text">manually activate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#others"><span class="toc-number">1.2.5.2.5.</span> <span class="toc-text">others</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bufferevents"><span class="toc-number">1.2.6.</span> <span class="toc-text">Bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concept"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">concept</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#watermarks"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">watermarks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#callbacks"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">callbacks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deferred-callbacks"><span class="toc-number">1.2.6.1.3.</span> <span class="toc-text">deferred callbacks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#option-flags"><span class="toc-number">1.2.6.1.4.</span> <span class="toc-text">option flags</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#advanced"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">advanced</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-based-bufferevents"><span class="toc-number">1.2.7.</span> <span class="toc-text">Socket-based bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#construct-1"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">construct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connect"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">connect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hostname"><span class="toc-number">1.2.7.3.1.</span> <span class="toc-text">hostname</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-callbacks"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">set callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#enable"><span class="toc-number">1.2.7.4.1.</span> <span class="toc-text">enable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#watermark"><span class="toc-number">1.2.7.4.2.</span> <span class="toc-text">watermark</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-amp-write"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">read&amp;write</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-timeout"><span class="toc-number">1.2.7.5.1.</span> <span class="toc-text">set timeout</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flush"><span class="toc-number">1.2.7.5.2.</span> <span class="toc-text">flush</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#other"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">other</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#priority"><span class="toc-number">1.2.7.6.1.</span> <span class="toc-text">priority</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lock"><span class="toc-number">1.2.7.6.2.</span> <span class="toc-text">lock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evbuffers"><span class="toc-number">1.2.8.</span> <span class="toc-text">Evbuffers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#construct-2"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">construct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-1"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inspect"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">Inspect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">data</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#add"><span class="toc-number">1.2.8.4.1.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#move"><span class="toc-number">1.2.8.4.2.</span> <span class="toc-text">move</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rearrange"><span class="toc-number">1.2.8.4.3.</span> <span class="toc-text">rearrange</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove"><span class="toc-number">1.2.8.4.4.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#copy"><span class="toc-number">1.2.8.4.5.</span> <span class="toc-text">copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#line-based"><span class="toc-number">1.2.8.4.6.</span> <span class="toc-text">line-based</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sarch"><span class="toc-number">1.2.8.4.7.</span> <span class="toc-text">sarch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#peek"><span class="toc-number">1.2.8.4.8.</span> <span class="toc-text">peek</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert"><span class="toc-number">1.2.8.4.9.</span> <span class="toc-text">insert</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#network-IO"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">network IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#callbacks-1"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#add-cb"><span class="toc-number">1.2.8.6.1.</span> <span class="toc-text">add_cb</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-cb"><span class="toc-number">1.2.8.6.2.</span> <span class="toc-text">remove_cb</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defer"><span class="toc-number">1.2.8.6.3.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reference"><span class="toc-number">1.2.8.6.4.</span> <span class="toc-text">reference</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#other-1"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">other</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evconnlistener"><span class="toc-number">1.2.9.</span> <span class="toc-text">Evconnlistener</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flags"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">flags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#callback"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">callback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enable-disable"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">enable/disable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adjuste-cb"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">adjuste cb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inspect-1"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">Inspect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error-cb"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">error cb</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">2.</span> <span class="toc-text">结束</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-5 i,
        .toc-level-5 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide" title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"libevent　| Skuaka　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/04/01/Unix/Programming/Git笔记/" title="Pre: Git使用笔记">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/03/25/Operating System/操作系统知识点/" title="Next: 操作系统知识点">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/27/Unix/Command/xargs/">xargs</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/Unix/Programming/守护进程的创建/">守护进程的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/C_C++/Concept_gcc/attribute-packed/">__attribute__</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/Unix/System/SIGINT-SIGTERM-SIGKILL区别/">SIGINT SIGTERM SIGKILL区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/Mess/趋势科技面经/">趋势科技 Linux C++ 面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/QT/Qt issues/">Qt issues</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/QT/qt隐藏标题栏并鼠标拖动/">qt隐藏标题栏并鼠标拖动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/Security/openssl/">openssl</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/14/Algorithm/C++栈实现队列/">C++栈实现队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C_C++/C++模板和元编程/C++编译期快速排序/">C++编译期快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/Algorithm/Hash/">Hash</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C_C++/C++Collection/C++bitset/">C++bitset</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C_C++/C++模板和元编程/C++可变参数模板/">C++可变参数模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/C_C++/Mess/C++多线程排序/">C++多线程多路归并排序函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/C_C++/Mess/new和malloc区别/">new和malloc区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/C_C++/Concept_gcc/C++命名规范/">C++命名规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/Network/Http/https与ssl/">https 与 ssl</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/Unix/Programming/Git笔记/">Git使用笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/27/Network/IO/libevent/">libevent</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/25/Operating System/操作系统知识点/">操作系统知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/25/Database/Concept/数据库理论知识/">数据库理论知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/Operating System/Linux虚拟地址空间/">Linux虚拟地址空间</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/C_C++/C++Collection/C++ref/">C++ref</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/">IP头_TCP头_UDP头</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/C_C++/C++Collection/C++线程池/">C++线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/C_C++/C++Collection/C++algorithm/">c++algorithm</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/Network/Unp/unp笔记/">《unp》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/Algorithm/逆元/">逆元</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/C_C++/C++Collection/C++线程库/">C++线程库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/C_C++/C++Collection/C++chrono时间库/">C++chrono时间库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/C_C++/C++Collection/C++右值引用和移动/">C++右值引用和移动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/Network/Http/http/">http</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/Algorithm/堆和优先队列/">堆和优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C_C++/C++Collection/C++string/">C++ string类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C_C++/C++Collection/C++强制类型转换/">C++强制类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/Operating System/浮点数存储法/">浮点数存储法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C_C++/Mess/C_C++pow函数实现/">C_C++ pow函数实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C_C++/C++Collection/C++杂类/">C++杂类(持续更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/Mess/C++运算符优先级/">C运算符优先级</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/C++Collection/C++虚函数表/">C++虚函数表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/Mess/结构体offsetof宏/">结构体offsetof宏 和 bit位测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Database/Concept/mysql数据库引擎/">mysql数据库引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating System/互斥锁-自旋锁-读写锁/">互斥锁 自旋锁 读写锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating System/虚拟内存概念/">虚拟内存概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/C_C++/C++Collection/C++智能指针/">C++智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/Operating System/C程序内存区域/">C程序内存区域</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/Algorithm/LIS-最长上升子序列/">LIS 最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/Algorithm/LCS-最长公共子序列/">LCS (最长公共子序列)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/C_C++/C++Collection/C++Lambda表达式/">C++ Lambda表达式用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/QT/QT 贪吃蛇/">QT 贪吃蛇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/QT/PaintEvent/">QT PaintEvent</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/C_C++/Mess/C语言杂记/">C语言杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/QT/窗口视口/">窗口视口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/Network/Tcp/TCP半关闭,半连接,半打开/">TCP 半关闭,半连接,半打开</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/Network/Tcp/Tcp_ip协议栈/">Tcp_ip协议栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/05/Unix/Command/内存cpu/">Linux 内存Cpu 查看</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/tar/">Tar命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/ln/">ln</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/screen/">使用 screen 管理远程会话</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒联机控制台/">饥荒联机控制台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒Linux服务器/">饥荒Linux服务器搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/Unix/Command/输出重定向/">Linux 输出重定向</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/26/C_C++/C++模板和元编程/C++编译期备忘录/">C++ 编译期备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C_C++/C++模板和元编程/C++typename用法/">C++ typename 用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C_C++/C++模板和元编程/C++模板元编程书上习题/">C++模板元编程书上习题（待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/C_C++/C++模板和元编程/C++模板元编程/">C++模板元编程(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C_C++/C++Collection/C++基础笔记/">C++ 基础笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C_C++/Mess/C++和Java的引用/">C++和Java的引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Network/IO/Reactor/">高性能IO之Reactor模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Database/Redis/Redis设计与实现/">Redis 设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/Database/Redis/Mac 下 Redis 使用/">Mac 下 Redis 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/10/Operating System/操作系统期末背诵点/">操作系统期末背诵点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/05/QT/QT入门/">QT 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/QT/QString/">QString与char*的相互转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/28/Algorithm/排序算法/">排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/Network/Tcp/TCP网络拥塞控制/">TCP网络拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/Unix/Programming/Makefile学习/">Makefile学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/C_C++/C++Collection/C++STL/">C++ STL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/Algorithm/查找树/">查找树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/Database/SQLserver/远程登入sqlserver/">远程登入 SQL server</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mysql c api/">mysql c&c++ api</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mysql安装与配置/">mysql安装与配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C_C++/Mess/C++显式实例化的用途/">C++显式实例化的用途</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C_C++/Mess/C++ofstream输出为1的情况/">fstream输出为1的情况</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Backend/Dreamweaver服务器配置/">Dreamweaver 连接到 Linux 云服务器 php</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Macos/Mac杂项记录/">Mac杂项</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Macos/mac软件推荐/">mac软件推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Unix/Raspberrypi/树莓派安装kali/">树莓派安装kali</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/30/Script Language/Perl/Perl入门/">Perl 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/29/Unix/Command/vim备忘录/">vim备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/C_C++/Concept_gcc/标准IO的三类缓冲/">标准IO的三类缓冲</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/C_C++/Mess/C++杂记/">C++杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Network/Wireshark/Wireshark入门/">Wireshark 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Unix/Command/Linux不常用小命令/">Linux 小命令记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/C_C++/Mess/C++类与结构区别/">C++中结构体和类的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Security/DDos/DDos攻击详解/">DDos 攻击详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Network/Wireshark/qq好友IP定位/">qq好友IP定位</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Backend/apache删除后Nginx显示Apache界面/">apache删除后使用Nginx服务仍然显示Apache界面</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Unix/Proxy/Socks5/">Linux搭建Socks5 Proxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/Network/IO/epoll/">epoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/Unix/Command/sed/">sed 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/12/Unix/Command/awk/">awk 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Unix/Command/nmap/">nmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Unix/System/使用过的端口/">使用过的端口(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Macos/mac显示隐藏文件/">macos 显示隐藏文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Mess/win逆向工程(弃)/">win逆向工程（放弃）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/Mess/计算机专业名词/">计算机专业名词记录(放弃更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/C_C++/Concept_gcc/不可重入函数/">不可重入函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/Unix/System/Linux日志文件分析/">Linux 日志文件分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Unix/Programming/解释器文件/">解释器文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Script Language/Python/Python杂记/">Python 杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/Database/SQLserver/mssql实验/">mssql实验(放弃更新)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql 基本命令/">mysql 基本命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql大小写区分/">mysql大小写区分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Unix/Programming/CMake入门/">CMake入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/Macos/mac平台开发工具/">我用的mac平台开发工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Mess/vultr问题集/">vultr 问题集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Unix/System/Linux备忘录/">Linux备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/Network/Unp/unp_code/">《unp》源代码问题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/Database/PostgreSQL/C++ connector for PostgreSQL/">C++ connector for PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/PostgreSQL 命令/">PostgreSQL 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/Mac 下 PostgreSQL /">Mac 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Macos/macos apache problem/">macos apache problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/Database/Mysql/mysql创建时间和更新时间/">mysql创建时间和更新时间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/Database/Mysql/mysql远程连接/">mysql远程连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Database/PostgreSQL/Linux 下 PostgreSQL/">Linux 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Backend/php入门/">php入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Frontend/DTD入门/">DTD入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Mess/File structure/mp3文件格式/">mp3文件格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/多播/">CCIE 多播（multicast）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS VPN/">CCIE MPLS VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS/">CCIE MPLS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/bgp/">CCIE bgp</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/跨域的多播/">CCIE 跨域的多播</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/交换机基础/">CCIE 交换机基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/NAT 地址转换协议/">CCIE NAT 地址转换协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/网络知识总结/">CCIE 网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/逻辑子接口/">CCIE 逻辑子接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS协议/">CCIE IS-IS协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/重分发 /">CCIE 重分发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/路由协议分类/">CCIE 路由协议分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/防火墙/">CCIE 防火墙</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/STP生成树协议/">CCIE STP生成树协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/acl控制/">CCIE acl控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/ipv6/">CCIE ipv6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS/">CCIE IS-IS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IPSEC VPN/">CCIE IPSEC VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/DM-VPN/">CCIE DM-VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/BGP 补充知识/">CCIE BGP 补充知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/C_C++/Concept_gcc/gcc_gdb备忘录/">gcc_gdb备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/Frontend/Javascript入门/">Javascript 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Frontend/XML入门/">XML入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Database/Mysql/mysql用户名及密码/">mysql用户名及密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/Database/Mysql/centos彻底删除mysql/">centos彻底删除mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/Security/无线安全/Dsniff/">Dsniff</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/Backend/base64原理/">Base64原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/Security/无线安全/reaver/">reaver</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/wireshark fatal IO error 2/">kali vnc wireshark fatal IO error 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/Aircrack-ng/">Aircrack-ng</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/C_C++/C++Collection/C++11新特性/">C++11（待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/HTMLl5+CSS3入门/">HTML5+CSS3入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/Html入门/">Html入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/CSS入门/">CSS入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/25/Algorithm/DFS/">DFS BFS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/Script Language/Python/懒得整理的python学习笔记/">懒得整理的python学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/Unix/Programming/Shell入门/">shell程序设计入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/Mess/Markdown/">Markdown标记语言</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>