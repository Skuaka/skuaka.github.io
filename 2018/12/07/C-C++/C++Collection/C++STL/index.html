<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">



<meta name="description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ STL">
<meta property="og:url" content="http://blog.skuaka.cn/2018/12/07/C-C++/C++Collection/C++STL/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-05-08T04:23:01.823Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ STL">
<meta name="twitter:description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>C++ STL | Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Job/">Job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Op-System/">Op-System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openSSL/">openSSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postman/">postman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/steamcmd/">steamcmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travis/">travis</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap"><article id="post-C-C++/C++Collection/C++STL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/C-C++/C++Collection/C++STL/" class="article-date">
      <time datetime="2018-12-07T12:51:15.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ STL
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h1><p>STL 提供了一组表示容器、迭代器、函数对象、算法的模板。</p>
<a id="more"></a>
<p>STL 容器是同质的，即存储的值的类型相同。</p>
<h2 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h2><h3 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h3><p>各种STL容器模板都接受一个可选的模板参数，指定使用哪个分配器来管理内存。</p>
<p>默认使用 <code>allocator&lt;T&gt;</code> 类，这个类使用 new 和 delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class">	<span class="title">class</span> <span class="title">vector</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是广义指针。让 STL 能够为不同的容器类提供统一的接口。</p>
<p>每个类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，其作用域为整个类。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pd;<span class="comment">// pd an iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的行为就像指针</span></span><br><span class="line"><span class="keyword">auto</span> pd = scores.begin(); <span class="comment">// c++ automatic tyoe deduction</span></span><br><span class="line">*pd = <span class="number">22.3</span>;</span><br><span class="line">++pd;</span><br><span class="line"><span class="keyword">for</span>(pd = scores.begin(); pd != scores.end(); ++pd)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pd &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器操作函数 &lt;iterator&gt;</span></span><br><span class="line">advance()	<span class="comment">//advances an iterator by given distance</span></span><br><span class="line">distance()	<span class="comment">//returns the distance between two iterators </span></span><br><span class="line">next()	<span class="comment">//(C++11)increment an iterator </span></span><br><span class="line">prev()	<span class="comment">//(C++11)decrement an iterator</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p>不同的算法对迭代器的要求也不同。STL定义了5种迭代器，并根据所需要的类型对算法进行了描述。</p>
<p>例如，find()的原型与下面类似，指出了算法需要一个输入迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>);</span></span><br></pre></td></tr></table></figure>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><ul>
<li>术语“输入”是从程序的角度说的，即来自容器的信息被视为输入。</li>
<li>不能修改元素。</li>
<li><p>必须能够访问容器中所有元素，通过支持两种形式的++运算符。</p>
</li>
<li><p>并不能保证第二次遍历容器时，顺序不变。</p>
</li>
<li>是单向迭代器，可以递增，但不能倒退。</li>
</ul>
<h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><ul>
<li><p>术语“输出”指用于将信息从程序传输给容器。</p>
</li>
<li><p>只能解引用修改容器值，不能读取。</p>
<p>这点可能很奇怪。其实类似的，发送到显示器上的输出就是如此，cout 可以修改发送到显示器的字符流，却不能读取屏幕上的内容。STL足够通用，其容器可以表示输出设备。</p>
</li>
<li><p>单向迭代器。</p>
</li>
</ul>
<p>简而言之：对于单通行、只读算法，可以使用输入迭代器；单通行、只写，输出迭代器。</p>
<h4 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h4><ul>
<li><p>只使用++运算符来遍历容器，与输入、输出迭代器不同的是，它总是按相同的顺序遍历。</p>
<p>另外，将正向迭代器递增后，仍然可以对前面的迭代器值解引用，并得到相同的值。</p>
</li>
<li><p>即可以读写，也可以只读：</p>
<p><code>int * pitrw;</code>    <code>const int * pitr;</code></p>
</li>
</ul>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4><ul>
<li>具有正向迭代器的所有特性，并支持两种递减运算符。</li>
</ul>
<p>比如 reverse() 函数，交换第一个和最后一个元素，并将指向第一个元素的指针加一、指向最后的减一，并重复这种过程。</p>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><ul>
<li>有些算法要求能够直接跳到容器中的任何一个元素，这叫做随机访问。</li>
<li>随机访问拥有双向迭代器的所有特性，并且支持随机访问（如指针增加运算）和用于对元素进行排序的关系运算符。</li>
</ul>
<h3 id="将指针用作迭代器"><a href="#将指针用作迭代器" class="headerlink" title="将指针用作迭代器"></a>将指针用作迭代器</h3><ul>
<li>指针满足所有迭代器要求。</li>
</ul>
<h3 id="迭代器的输入输出适配器"><a href="#迭代器的输入输出适配器" class="headerlink" title="迭代器的输入输出适配器"></a>迭代器的输入输出适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">// *** ostream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出了被发送给输出流的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输出流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数的第一个参数指出了要用的输出流，可以是文件流</span></span><br><span class="line"><span class="comment">// 构造函数的第二个参数是发送给输出流的每个项后的分隔字符串</span></span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">copy(dice.begin(), dice.end(), out_iter);	<span class="comment">// copy vector to output stream</span></span><br><span class="line"><span class="comment">// 也可使用匿名迭代器</span></span><br><span class="line">copy(dice.begin(), dice.end(), ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** istream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出要读取的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输入流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数参数标书使用的输入流，如果省略参数表示输入失败。</span></span><br><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cin</span>), </span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(), dice.begin());	</span><br><span class="line"><span class="comment">//从输入流读取，直到文件结尾、类型不匹配或其他输入故障</span></span><br></pre></td></tr></table></figure>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><ul>
<li>对 reverse_iterator 执行<strong>递增</strong>操作将导致它被<strong>递减</strong>。</li>
</ul>
<p>vector 类有名为 rbegin() 和 rend() 的成员函数，分别返回指向超尾和第一个元素的反向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(dice.rbegin(), dice.rend(), out_iter);	<span class="comment">// display in reverse order</span></span><br></pre></td></tr></table></figure>
<p>反向指针通过”先递减、再解引用”来访问到每一个项。</p>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入迭代器提供了以下几种操作：*itr，itr++，++itr，itr = value。</p>
<p>前三种操作为“空操作”(no-op)，仅仅返回itr，也就是取消了它们本来的语义，保护这个迭代器指向的位置。</p>
<p>第四种操作itr = value才是插入迭代器的核心，这个操作通过调用容器的成员函数（push_back()，push_front()，insert()，取决于插入器类型）把value插入到插入器对应容器的相应的位置上。</p>
<p><strong>三种类型</strong>：</p>
<ul>
<li><p><strong>back_insert_iterator</strong> 将元素插入到容器尾部。</p>
<p>通过调用容器的<code>push_back</code>成员函数来插入元素，因此这种插入器只对vector,list,deque和string有效。</p>
</li>
<li><p><strong>front_insert_iterator</strong> 将元素插入到容器前端。</p>
<p>通过调用容器的<code>push_front</code>成员函数来插入元素，因此它只对list和deque有效。</p>
</li>
<li><p><strong>insert_iterator</strong> 将元素插入到构造函数指定的位置的前面。</p>
<p>通过调用<code>insert</code>在指定位置插入元素，同时更新下次插入位置。</p>
<p><code>itr = value</code> 等效于如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = container.insert(pos,value);</span><br><span class="line">++pos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li><p>将容器作为模板参数，前两种将实际的容器标识符作为构造函数参数。</p>
<p><code>back_insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice);</code></p>
<p>back_insert_iterator 将假定传递给它的类型有一个 push_back() 方法。</p>
</li>
<li><p>对于 insert_iterator ，还需要一个指示插入位置的构造函数参数：</p>
<p><code>insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice, dice.begin() );</code></p>
</li>
</ul>
<h4 id="插入迭代器适配函数"><a href="#插入迭代器适配函数" class="headerlink" title="插入迭代器适配函数"></a>插入迭代器适配函数</h4><p>很多STL算法需要插入迭代器，但是每次构造都要敲很长的模板参数和构造参数，有了下面的模板函数就只需要把对象作为参数，它会自动推断类型并且返回上面的三种插入迭代器。</p>
<table>
<thead>
<tr>
<th>back_inserter</th>
<th>creates a <code>std::back_insert_iterator</code> of type inferred from the argument</th>
</tr>
</thead>
<tbody>
<tr>
<td>front_inserter</td>
<td>creates a <code>std::front_insert_iterator</code> of type inferred from the argument</td>
</tr>
<tr>
<td>inserter</td>
<td>creates a <code>std::insert_iterator</code> of type inferred from the argument</td>
</tr>
</tbody>
</table>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite。</p>
<p>迭代器失效<em>分三种情况考虑</em></p>
<ul>
<li><p>数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说<code>insert(*iter)</code>( 或<code>erase(*iter)</code> )，然后在iter++，是没有意义的。</p>
<p>解决方法：<code>erase(*iter)</code>的返回值是下一个有效迭代器的值。 <code>iter = cont.erase(iter);</code></p>
</li>
<li><p>链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<p>解决办法两种：<code>erase(*iter)</code>会返回下一个有效迭代器的值，或者<code>erase(iter++)</code>.</p>
</li>
<li><p>树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用<code>erase(iter++)</code>的方式删除迭代器。</p>
</li>
</ul>
<p>给vector调用push_back也会使迭代器失效：因为vector增大时可能会重新分配内存。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li><p>STL具有容器概念和容器类型。</p>
<p><strong>容器概念</strong>是具有相同名称（如容器、序列容器、关联容器等）的通用类别；</p>
<p><strong>容器类型</strong>是可用于创建具体容器对象的模板。</p>
</li>
<li><p>容器是存储其他对象的对象。被存储的对象必须是<strong>同类型</strong>的，可以是内置类型值。</p>
</li>
<li><p>不是任何类型的对象都能存储在容器中。</p>
<p>类型必须是可复制构造的和可赋值的。</p>
<p>基本类型满足要求；只要类定义没有将复制构造函数和赋值运算符声明为私有的，也满足要求。</p>
</li>
</ul>
<p><strong>基本的容器特征</strong></p>
<ol>
<li>上文介绍的STL通用方法</li>
<li><code>X::iterator</code> 指向 T 的迭代器类型。要求：满足正向迭代器的任何迭代器。</li>
<li><code>X::value_type</code> T 的类型。</li>
</ol>
<h3 id="所有容器"><a href="#所有容器" class="headerlink" title="所有容器"></a>所有容器</h3><p><strong>11个基本容器</strong>：</p>
<p>deque、list、</p>
<p>queue、priority_queue、</p>
<p>stack、vector、</p>
<p>map、multimap、</p>
<p>set、multiset、bitset。</p>
<p><strong>5个c++11新增</strong>：</p>
<p>forward_list、</p>
<p>unordered_map、unordered_multimap、</p>
<p>unordered_set、unordered_multiset。</p>
<h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>对于已有的通用方法，类也有可能重新定义成员方法。因为针对特殊元素的成员方法一般比通用方法效率高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a.swap(b);	<span class="comment">//交换两个容器的内容</span></span><br><span class="line"></span><br><span class="line">copy(it1, it2, it3);	<span class="comment">//前两个参数表示要复制的范围(输入迭代器)，第三个参数表示复制到的位置(输出迭代器)。</span></span><br><span class="line"></span><br><span class="line">for_each(it1, it2, pfun);	<span class="comment">//替换for循环，对指定区间每个元素使用函数对象。不能修改元素值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x: books)&#123;*pfun(x)&#125;;	<span class="comment">//基于范围的for能修改元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*__需要支持随机访问__*/</span></span><br><span class="line"><span class="comment">//随机排列区间中的元素</span></span><br><span class="line">random_shuffle(it1, it2);</span><br><span class="line"><span class="comment">//排列指定区间，默认按照 &lt; 运算符，或者函数对象(接收两个元素引用，返回值bool，false表示顺序不对)</span></span><br><span class="line">sort(it1, it2[, pfun] );</span><br></pre></td></tr></table></figure>
<p><strong>通用成员方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a.empty();	<span class="comment">//是否为空</span></span><br><span class="line">a.size();	<span class="comment">//返回元素数目</span></span><br><span class="line">a.max_size();	<span class="comment">//最大元素数目</span></span><br><span class="line">a.capacity();	<span class="comment">//不重新分配内存就能够存储的容量</span></span><br><span class="line">a.reserve(size);	<span class="comment">//提升容量到指定的size，如果size小于目前容量，则什么也不做</span></span><br><span class="line">a.resize(size);		<span class="comment">//注意和reserve区别，这个会填补新的容量</span></span><br><span class="line"></span><br><span class="line">a.begin();	<span class="comment">//返回指向容器中第一个元素的迭代器</span></span><br><span class="line">a.cbegin();	<span class="comment">//c++11 const迭代器</span></span><br><span class="line">a.end();	<span class="comment">//返回一个表示超过容器尾的迭代器</span></span><br><span class="line">a.cend();</span><br><span class="line">a.rbegin();</span><br><span class="line">a.crbegin();</span><br><span class="line">a.rend();</span><br><span class="line">a.crend();</span><br></pre></td></tr></table></figure>
<h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p><strong>7种容器</strong>：</p>
<p>deque、queue、priority_queue、</p>
<p>list、forward_list (c++11)、</p>
<p>stack、vector 。</p>
<p><strong>要求</strong>：</p>
<ul>
<li>正向迭代器（保证了元素按特定顺序排列，不会在两次迭代之间发生变化）</li>
<li>线性顺序（树的分支结构就不是）</li>
</ul>
<h4 id="通用方法-1"><a href="#通用方法-1" class="headerlink" title="通用方法"></a>通用方法</h4><p><strong>通用方法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n,t)</span></span>;	<span class="comment">// 声明一个名为a的由n个t值组成的序列</span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i,j)</span></span>;	<span class="comment">// 声明并初始化为区间[i,j)的内容</span></span><br><span class="line"></span><br><span class="line">a.insert(p,t);	<span class="comment">// 将t插入到p的前面。返回迭代器。</span></span><br><span class="line">a.insert(p,n,t);<span class="comment">// 将n个t插入到p的前面。返回void。</span></span><br><span class="line">a.insert(p,i,j);<span class="comment">// 将区间[i,j)中的元素插入到p的前面。返回void。</span></span><br><span class="line"></span><br><span class="line">a.erase(p);		<span class="comment">// 删除p指向的元素。返回下一个元素的迭代器。</span></span><br><span class="line">a.erase(p,q);	<span class="comment">// 删除区间[p,q)中的元素。返回下一个元素的迭代器。</span></span><br><span class="line">a.clear();		<span class="comment">// 等价于 erase(begin(), end() )</span></span><br></pre></td></tr></table></figure>
<p><strong>可选方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*表达式*/</span>		<span class="comment">/*返回类型*/</span>	<span class="comment">/*含义*/</span>			<span class="comment">/*容器*/</span></span><br><span class="line">a.front();		  T&amp;		*a.begin()	<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.back();		  	T&amp;		*--a.end()	<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.push_front(t);  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.push_back(t);	  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.pop_front(t);   <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.pop_back(t);    <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a[n]			  		T&amp;				    					<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.at(n)			  	T&amp;					    				<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line"><span class="comment">//at(n)和a[n]区别在于会检查n是否合法。必要时引发out_of_range异常。</span></span><br></pre></td></tr></table></figure>
<h5 id="emplace-c-11"><a href="#emplace-c-11" class="headerlink" title="emplace(c++11)"></a>emplace(c++11)</h5><p>emplace系列函数是就地构造，而不是先构造再移动。</p>
<p>对于push_back()可以替换为emplace_back()；insert()和push()可替换为emplace()。</p>
<p><strong>emplace_back()比push_back()效率高：</strong></p>
<p><code>push_back()</code>：先构造对象，然后移动到容器尾部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">vs.push_back(<span class="built_in">string</span>(<span class="string">"1"</span>));</span><br><span class="line"><span class="comment">//String(const char *)  构造</span></span><br><span class="line"><span class="comment">//String(String &amp;&amp;)  移动</span></span><br></pre></td></tr></table></figure>
<p><code>emplace_back()</code> ：直接调用类的构造函数就地构造，没有移动操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">vs.emplace_back(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//直接在vector最后位置构造</span></span><br><span class="line"><span class="comment">//如果在capacity范围内，则只调用一次构造</span></span><br><span class="line"><span class="comment">//如果超出范围，则移动到新分配的内存，这点对于push_back()也是一样的</span></span><br></pre></td></tr></table></figure>
<p><strong>直观的测试例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myString</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span></span><br><span class="line">&#123;</span><br><span class="line">	myString(<span class="keyword">const</span> <span class="keyword">char</span> * str) : <span class="built_in">std</span>::<span class="built_in">string</span>(str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	myString(myString &amp;&amp; str) : <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="built_in">std</span>::move(str))&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"moved"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myString&gt; vs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"before emplace: "</span>&lt;&lt;<span class="string">"size:"</span>&lt;&lt;vs.size()</span><br><span class="line">					&lt;&lt;<span class="string">" capacity:"</span>&lt;&lt;vs.capacity()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				vs.emplace_back(<span class="string">"1"</span>);</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"after  emplace: "</span>&lt;&lt;<span class="string">"size:"</span>&lt;&lt;vs.size()</span><br><span class="line">					&lt;&lt;<span class="string">" capacity:"</span>&lt;&lt;vs.capacity()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">					&lt;&lt;<span class="string">"----------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">before emplace: size:0 capacity:0</span><br><span class="line">constructed</span><br><span class="line">after  emplace: size:1 capacity:1</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:1 capacity:1</span><br><span class="line">constructed</span><br><span class="line">moved</span><br><span class="line">after  emplace: size:2 capacity:2</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:2 capacity:2</span><br><span class="line">constructed</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">after  emplace: size:3 capacity:4</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:3 capacity:4</span><br><span class="line">constructed</span><br><span class="line">after  emplace: size:4 capacity:4</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:4 capacity:4</span><br><span class="line">constructed</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">after  emplace: size:5 capacity:8</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:5 capacity:8</span><br><span class="line">constructed</span><br><span class="line">after  emplace: size:6 capacity:8</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:6 capacity:8</span><br><span class="line">constructed</span><br><span class="line">after  emplace: size:7 capacity:8</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:7 capacity:8</span><br><span class="line">constructed</span><br><span class="line">after  emplace: size:8 capacity:8</span><br><span class="line">----------------------------</span><br><span class="line">before emplace: size:8 capacity:8</span><br><span class="line">constructed</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">moved</span><br><span class="line">after  emplace: size:9 capacity:16</span><br><span class="line">----------------------------</span><br></pre></td></tr></table></figure>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>简单地说，vector是数组的一种类表示。</p>
<p>除序列外，vector还是<strong>可反转容器概念</strong>的模型，增加了<code>rbegin()</code>和<code>rend()</code>。</p>
<p>vector 是最简单的序列类型，除非其他类型的特殊优点能更好地满足程序的要求，否则应默认使用这种类型。</p>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端列队</p>
<p>表面看起来和vector差不多。</p>
<p>主要区别：从deque的开始位置插入和删除元素的时间是固定的，而不像vector是线性的。</p>
<hr>
<p><strong>deque的内部实现</strong></p>
<p>deque由若干段连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。</p>
<p>实际上。deque内部会维护一个map（注意！不是STL中的map容器）即一小块连续的空间，该空间中每个元素都是指针，指向另一段（较大的）区域，这个区域称为缓冲区，缓冲区用来保存deque中的数据。因此deque在随机访问和遍历数据会比vector慢。它首次插入一个元素，默认会动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后虚拟地连在一起。deque的这种设计使得它具有比vector复杂得多的架构、算法和迭代器设计。它的随机访问和遍历性能比vector差。</p>
<p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>双向链表</p>
<p>可反转容器，不支持随机访问。</p>
<p>vector 强调的是通过随机访问进行快速访问，而 list 强调的是元素的快速插入和删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表x与调用链表合并。</span></span><br><span class="line"><span class="comment">//1.两个链表必须已经排序。</span></span><br><span class="line"><span class="comment">//2.合并后的经过排序的链表存在调用链表中，x清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&lt;T,Alloc&gt;&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除val的所有实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 如果谓词返回true,删除这些元素</span></span><br><span class="line">scores.remove_if(tooBig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用&lt;运算符对链表进行排序。O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表x的内容插入到pos的前面，x清空</span></span><br><span class="line"><span class="comment">// 和insert()的区别在于：splice()是移动原内容，insert()是插入副本。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator pos, <span class="built_in">list</span>&lt;T,Alloc&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连续的相同元素压缩为单个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort()、merge()、unique() 还各自拥有接受另一个参数的版本，该参数用于指定用来比较元素的函数。</span></span><br><span class="line"><span class="comment">   remove() 也可以有另一个参数，用于确定是否删除元素的函数。</span></span><br><span class="line"><span class="comment">   这些参数都是谓词函数。 */</span></span><br></pre></td></tr></table></figure>
<p>用途举例：</p>
<p>假如有两个邮件列表要整理，可以对每个列表进行排序，合并它们，然后删除重复的元素。</p>
<h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h4><p>单链表</p>
<p>不可反转，只需要正向迭代器。</p>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列</p>
<p>是一个适配器类，底层默认还是 deque。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义队列的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 队尾插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;		<span class="comment">// 队首弹出</span></span><br></pre></td></tr></table></figure>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先队列</p>
<p>是另一个适配器类，<strong>默认的底层类是 vector</strong>。</p>
<p><strong>默认是建立最大堆</strong>，可以修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;	<span class="comment">//返回队首元素的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;		<span class="comment">// 弹出堆首</span></span><br></pre></td></tr></table></figure>
<p>可以修改确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq1;				<span class="comment">// defult version</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2();	<span class="comment">// use greater&lt;int&gt; to order</span></span><br></pre></td></tr></table></figure>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈</p>
<p>也是一个适配器类，默认底层是 vector。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义栈的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;				<span class="comment">//accesses the top element</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 栈顶插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;				<span class="comment">// 栈顶弹出</span></span><br></pre></td></tr></table></figure>
<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>不是STL容器，因为其长度是固定的。</p>
<p>头文件：<code>&lt;array&gt;</code></p>
<p>array没有定义调整容器大小的操作，但是定义了对它来说有意义的成员函数，比如 <code>operator[]()</code> 和 <code>at()</code></p>
<p>可以将很多STL算法用于array，比如<code>copy()</code> 和 <code>for_each()</code>。</p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p><strong>4种容器</strong>：</p>
<p>set、multiset、</p>
<p>map、multimap。</p>
<p><strong>要求</strong>：</p>
<ul>
<li><p>关联容器将值与键关联在一起，并使用键来查找值。键被看做常量。</p>
</li>
<li><p>对于容器 X，<code>X::value_type</code> 指出存储在容器中的值类型；</p>
<p>对于关联容器，<code>X::key_type</code> 指出了键的类型。</p>
</li>
<li><p>关联容器通常是用树和哈希实现的，查找速度更快。</p>
</li>
<li><p>可以将自定义类型用作键，但是需要自定义比较函数。</p>
</li>
</ul>
<p><strong>4种容器都有的性质</strong>：</p>
<ul>
<li>可反转的</li>
<li>本身就是<strong>排序的</strong></li>
</ul>
<h4 id="通用方法-2"><a href="#通用方法-2" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count(key);	<span class="comment">//返回和指定的value相等的元素个数，如果不允许重复元素，那么只可能是0或1</span></span><br><span class="line">find(key);	<span class="comment">//查找指向key的迭代器，如果找不到则返回end()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;iterator,iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key );</span><br><span class="line"><span class="comment">// 返回所有值等于key指向的值的范围，其第一第二个迭代器可以分别由下面两个方法获得:</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">( <span class="keyword">const</span> Key&amp; key )</span></span>;	<span class="comment">//返回第一个不小于指定值的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">( <span class="keyword">const</span> Key&amp; key )</span></span>;	<span class="comment">//返回第一个大于指定值的迭代器</span></span><br></pre></td></tr></table></figure>
<h4 id="multi-set"><a href="#multi-set" class="headerlink" title="(multi)set"></a>(multi)set</h4><p>值与键类型相同，对于set来说，值就是键。</p>
<p>内部元素唯一，用一棵平衡树结构来存储，查找快。</p>
<p>multiset 类似于 set，区别是可以有多个值的键相同。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个模板参数是可选的，用来指示对键进行排序的比较函数或对象。默认用 less&lt;T&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, greater&lt;<span class="built_in">string</span>&gt; &gt; A;</span><br><span class="line">A.insert(T);	<span class="comment">// 因为排序决定了插入的位置，所以不需要指定插入位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set_union、set_intersection、set_difference</span></span><br><span class="line"><span class="comment">// 分别查找并集、交集、差集。</span></span><br><span class="line"><span class="comment">// 接口：前两个迭代器定义了第一个集合的区间，后两个定义第二个区间，最后一个是输出迭代器。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         ostream_iterator&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; out(<span class="built_in">cout</span>, <span class="string">" "</span>) );</span><br><span class="line"><span class="comment">// 假设要将结果放到集合C，而不是显示它，则最后一个参数应是一个指向C的迭代器。</span></span><br><span class="line"><span class="comment">// 首先想到用C.begin()，但是存在问题：</span></span><br><span class="line"><span class="comment">// 	1.关联容器的键是常量，所以 C.begin()是const迭代器，不能用作输出迭代器。</span></span><br><span class="line"><span class="comment">// 	2.与 copy() 相似，set_union() 将覆盖容器中已有的数据，并要求容器有足够的空间容纳新信息。</span></span><br><span class="line"><span class="comment">// 模板 insert_iterator 可解决这两个问题，它将复制转换为插入，还模拟了输出迭代器概念。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt;(C, C.begin() ) );</span><br></pre></td></tr></table></figure>
<h4 id="multi-map"><a href="#multi-map" class="headerlink" title="(multi)map"></a>(multi)map</h4><p>值与键类型不同</p>
<p>multimap 类似于 map，区别是可以有多个值的键相同。</p>
<ul>
<li><p>STL 使用模板 <code>pair&lt;class T, class U&gt;</code> 将建类型和数据类型存储到一个对象(<strong>值</strong>)中。</p>
<p>如果 keytype 是键类型， datatype 是存储的数据类型，则<strong>值类型</strong>为<code>pair&lt;const keytype, datatype&gt;</code></p>
</li>
<li><p>对于pair对象，可以使用 first 和 second 成员来访问其两部分</p>
<p><code>cout &lt;&lt; item.first &lt;&lt; &#39; &#39; &lt;&lt; item.second &lt;&lt; endl;</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数为：键类型，值类型，可选的排序比较函数或对象</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, less&lt;<span class="keyword">int</span>&gt; &gt; codes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个pair，然后插入</span></span><br><span class="line">pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt; item(<span class="number">213</span>, <span class="string">"Los"</span>);</span><br><span class="line">codes.insert(item);</span><br><span class="line"><span class="comment">// 或者直接插入匿名pair</span></span><br><span class="line">codes.insert(pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">213</span>, <span class="string">"Los"</span>));</span><br><span class="line"><span class="comment">// 或者使用数组表示法</span></span><br><span class="line">code[<span class="number">213</span>] = <span class="string">"Los"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p><strong>4种容器</strong>：</p>
<p>unordered_set、unordered_multiset、</p>
<p>unordered_map、unordered_multimap。</p>
<p><strong>区别</strong>：</p>
<p>关联容器基于<strong>红黑树</strong>，而无序关联容器基于<strong>哈希表</strong>。</p>
<p>这旨在提高添加和删除元素的速度以及查找算法的效率。</p>
<p><strong>有 hash_map 吗？</strong></p>
<p>STL有hash_map，但是C++标准库里没有，只有部分编译器支持hash_map，所以还是建议使用unordered_map。</p>
<p><strong>可以自己提供键类型和哈希函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Key</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> first;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyHash</span> &#123;</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Key&amp; k) <span class="keyword">const</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(k.first) ^</span><br><span class="line">            (<span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(k.second) &lt;&lt; <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyEqual</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Key&amp; lhs, <span class="keyword">const</span> Key&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.first == rhs.first &amp;&amp; lhs.second == rhs.second;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;Key, <span class="built_in">std</span>::<span class="built_in">string</span>, KeyHash, KeyEqual&gt; m6 = &#123;</span><br><span class="line">            &#123; &#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>&#125;, <span class="string">"example"</span>&#125;,</span><br><span class="line">            &#123; &#123;<span class="string">"Mary"</span>, <span class="string">"Sue"</span>&#125;, <span class="string">"another"</span>&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="容器内部实现"><a href="#容器内部实现" class="headerlink" title="容器内部实现"></a>容器内部实现</h3><p><strong>1.vector</strong>  （连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢（涉及元素复制移动），而且如果一开始分配的空间不够的话，有一个重新分配更大空间，此时需要拷贝的性能开销。可以快速地在最后添加删除元素,并可以快速地访问任意元素</p>
<p><strong>2.deque</strong>    在开始和最后添加删除元素都一样快,并提供了随机访问方法,像vector一样使用[]访问任意元素,但是随机访问速度比不上vector快,因为它要内部处理堆跳转deque也有保留空间.另外,由于deque不要求连续空间,所以可以保存的元素比vector更大,这点也要注意一下.还有就是在前面和后面添加元素时都不需要移动其它块的元素。对deque的排序操作，可将deque先复制到vector，排序后在复制回deque。<br>     1)  两端都能快速插入元素和删除元素（vector只在尾端快速进行此类操作）。<br>         2）存取元素时，deque的内部结构会多一个间接过程，所以元素的存取和迭代器的动作会稍稍慢一些。<br>         3）迭代器需要在不同区块间跳转，所以必须是特殊的智能型指针，非一般指针。<br>         4）在对内存区块有所限制的系统中（例如PC系统），deque可以内含更多元素，因为它使用不止一块内存。因此deque的max_size()可能更大。<br>         5）deque不支持对容量和内存重分配时机的控制。特别要注意的是，除了头尾两端，在任何地方插入或删除元素，都将导致指向deque元素的任何指针、引用、迭代器失效。不过，deque的内存重分配优于vector，因为其内部结构显示，deque不必在内存重分配时复制所有元素。<br>         6）deque的内存区块不再被使用时，会被释放。deque的内存大小是可缩减的。</p>
<p><strong>3.list</strong>（元素间使用链表相连）访问随机元素不如vector快，随机的插入元素比vector快，对每个元素分配空间，所以不存在空间不够，重新分配的情况。list可以快速地在所有地方添加删除元素,但是只能快速地访问最开始与最后的元素</p>
<p><strong>4.set</strong> 内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找比较快。</p>
<p><strong>5.map</strong> 一对一的映射的结合，key不能重复。</p>
<p><strong>6.stack</strong> 适配器，必须结合其他的容器使用，stl中默认的内部容器是deque。先进后出，只有一个出口，不允许遍历。</p>
<p><strong>7.queue</strong> 适配器。是受限制的deque，内部容器一般使用list较简单。先进先出，不允许遍历和元素的随机访问。</p>
<p>需要说明的是：由于deque可以从首位两端插入或剔除元素，所以只需要对其进行简单的封装就可以分别实现先进先出（FIFO）的stack和先进后出（FILO）的queue了。stack和queue中都有一个deque类型的成员，用做数据存储的容器，然后对deque的部分接口进行简单的封装，例如stack只提供从末端插入和删除的接口以及获取末端元素的接口，而queue则只提供从尾部插入而从头部删除的接口以及获取首位元素的接口。</p>
<p>像这样具有“修改某物接口，形成另一种风貌”的性质的，称为配接器（adapter），因此STL中stack和queue往往不被归类为容器（container），而被归类为容器配接器（container adapter）。</p>
<hr>
<p>Q：<strong>STL中set底层实现方式？ 为什么不用hash？</strong></p>
<p>A: 第一个问题:set底层实现方式为RB树（即红黑树）。</p>
<p>​    第二个问题:</p>
<p>首先set，不像map那样是key-value对，它的key与value是相同的。关于set有两种说法，第一个是STL中的set，用的是红黑树；第二个是hash_set，底层用得是hash table。</p>
<p>红黑树与hash table最大的不同是，红黑树是有序结构，而hash table不是。</p>
<p>如果只是判断set中的元素是否存在，那么hash显然更合适，因为set 的访问操作时间复杂度是log(N)的，而使用hash底层实现的hash_set是近似O(1)的。</p>
<p>然而，set应该更加被强调理解为“集合”，而集合所涉及的操作并、交、差等，即STL提供的如交集set_intersection()、并集set_union()、差集set_difference()和对称差集set_symmetric_difference()，都需要进行大量的比较工作，那么使用底层是有序结构的红黑树就十分恰当了，这也是其相对hash结构的优势所在。</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li><p>很多STL算法都使用函数对象，也叫函数符（functor）。</p>
</li>
<li><p>函数符是可以以函数方式与( )结合使用的任意对象，包括：</p>
<p>函数名、指向函数的指针、重载了( )运算符的类对象</p>
</li>
</ul>
<h3 id="函数符概念"><a href="#函数符概念" class="headerlink" title="函数符概念"></a>函数符概念</h3><ul>
<li><p><strong>生成器</strong>（generator）：不用参数就可以调用的函数符</p>
</li>
<li><p><strong>一元函数</strong>（unary function）：一个参数</p>
</li>
<li><p><strong>二元函数</strong>（binary function）：两个参数</p>
</li>
</ul>
<hr>
<ul>
<li><strong>谓词</strong>（predicate）：返回bool值的一元函数</li>
<li><strong>二元谓词</strong>（binary predicate）：返回bool值的二元函数</li>
</ul>
<p>一些 STL 函数需要谓词参数。比如 sort。</p>
<h3 id="函数适配器概念"><a href="#函数适配器概念" class="headerlink" title="函数适配器概念"></a>函数适配器概念</h3><p>类函数符可以作为函数适配器，使函数能够满足不同的接口。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个接收两个参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">tooBig</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">val</span>, <span class="title">const</span> <span class="title">T</span> &amp; <span class="title">lim</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> val &gt; lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以将它转化为单个参数的函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TooBig2</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T cutoff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TooBig2(<span class="keyword">const</span> T &amp; t) : cutoff(t) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tooBig&lt;T&gt;(v, cutoff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就可以这样做</span></span><br><span class="line">TooBig2&lt;<span class="keyword">int</span>&gt; tB100&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(tB100(x))	<span class="comment">//same as if(tooBig(x,100))</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="预定义函数符-lt-functional-gt"><a href="#预定义函数符-lt-functional-gt" class="headerlink" title="预定义函数符&lt;functional&gt;"></a>预定义函数符<code>&lt;functional&gt;</code></h3><p>STL 定义了多个基本函数符，这是为了支持将函数符作为参数的 STL 函数。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform(gr.begin(), gr.end(), out, <span class="built_in">sqrt</span>);</span><br><span class="line">transform(gr.begin(), gr.end(), m.begin(), out, plus&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line"><span class="comment">//plus&lt;double&gt;构造函数构造了一个函数符，以完成相加运算，括号表示调用默认构造函数。</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符和相应的函数符"><a href="#运算符和相应的函数符" class="headerlink" title="运算符和相应的函数符"></a>运算符和相应的函数符</h4><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">函数符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">plus</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">minus</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">multiples</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">divides</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">modulus</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">negate</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">equal_to</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">not_equal_to</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">greater</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">less</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">greater_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">less_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">logical_and</td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td style="text-align:center"></td>
<td>`</td>
<td>logical_or</td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">logical_not</td>
</tr>
</tbody>
</table>
<h3 id="自适应函数符"><a href="#自适应函数符" class="headerlink" title="自适应函数符"></a>自适应函数符</h3><p>上面列出的预定义函数符都是自适应的。</p>
<ul>
<li><p><strong>原因</strong>：它携带了标识参数类型和返回类型的 typedef 成员。</p>
<p>这些成员分别是：result_type、first_argument_type、second_argument_type …</p>
</li>
<li><p><strong>意义</strong>：函数适配器对象可以使用函数对象，并认为存在这些typedef对象。</p>
<p>例如，接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回类型匹配的变量。</p>
</li>
</ul>
<h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><ul>
<li><p>STL 使用<strong><em>类</em></strong>  <strong>binder1st</strong> 和 <strong>binder2st</strong> 将自适应二元函数转换为自适应一元函数。</p>
<p>假设有一个自适应二元函数对象 f2()，则可以创建一个 binder1st 对象，该对象与一个将被用作 f2() 的第一个参数的特定值（val）相关联：</p>
<p><code>binder1st(f2, val) f1;</code></p>
</li>
<li><p>STL 提供了<strong><em>函数</em></strong>  <strong>bind1st</strong> 和 <strong>bind2st</strong> 简化使用。它们返回上述类对象。</p>
<p><code>transform(gr.begin(), gr.end(), out, bind1st(multiplies&lt;double&gt;(), 2.5))</code></p>
</li>
</ul>
<h3 id="lambda表达式-C-11"><a href="#lambda表达式-C-11" class="headerlink" title="lambda表达式 C++11"></a>lambda表达式 C++11</h3><p>提供了函数指针和函数符的替代品。</p>
<p>详见另一篇。</p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><p>function可以将普通函数，lambda表达式和函数对象类统一起来。它们并不是相同的类型，然而通过function模板类，可以转化为相同类型的对象（function对象），从而放入一个map里。</p>
<p><strong>构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span>&lt;R(Args...)&gt;;</span></span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> denominator / divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 受限的map</span></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops_limit;</span><br><span class="line">	binops_limit.insert(&#123; <span class="string">'+'</span>, add &#125;);</span><br><span class="line">	binops_limit.insert(&#123; <span class="string">'%'</span>, mod &#125;);</span><br><span class="line">	<span class="comment">// 错误	1	error C2664: “void std::_Tree&lt;std::_Tmap_traits&lt;_Kty,_Ty,_Pr,_Alloc,false&gt;&gt;::insert(std::initializer_list&lt;std::pair&lt;const _Kty,_Ty&gt;&gt;)”: 无法将参数 1 从“initializer-list”转换为“std::pair&lt;const _Kty,_Ty&gt; &amp;&amp;”</span></span><br><span class="line">	<span class="comment">// binops_limit.insert(&#123; '%', divide() &#125;);</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 更灵活的map</span></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = </span><br><span class="line">	&#123;</span><br><span class="line">		&#123; <span class="string">'+'</span>, add &#125;,</span><br><span class="line">		&#123; <span class="string">'-'</span>, minus&lt;<span class="keyword">int</span>&gt;() &#125;,</span><br><span class="line">		&#123; <span class="string">'*'</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i - j; &#125; &#125;,</span><br><span class="line">		&#123; <span class="string">'/'</span>, divide() &#125;,</span><br><span class="line">		&#123; <span class="string">'%'</span>, mod &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'+'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'-'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'*'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'/'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'%'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p>算法都是内联的。</p>
</li>
<li><p>对于算法函数设计，首先，它们都使用模板来提供泛型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。</p>
</li>
<li><p>可以用==来比较不同类型的容器，因为容器重载的==运算符使用迭代器来比较内容，因此如果deque对象和vector对象的内容相同并且顺序相同，则它们是相等的。</p>
</li>
<li><p>STL 将算法库分成4组：</p>
<ol>
<li>非修改式序列操作</li>
<li>修改式序列操作</li>
<li>排序和相关操作</li>
<li>通用数字运算</li>
</ol>
<p>前三组在头文件 algorithm 中，第四组在 numeric 中。</p>
</li>
<li><p><code>_copy</code></p>
<p><strong>就地算法</strong>在算法完成时，结果被放到原始数据的位置上；</p>
<p><strong>复制算法</strong>将结果发送到另一个位置。</p>
<p>STL的约定是：</p>
<ol>
<li>复制版本的名称以 <code>_copy</code> 结尾。</li>
<li>复制版本将接受一个额外的输出迭代器参数。</li>
<li>复制算法返回一个迭代器，该迭代器指向复制的最后一个值后面的位置。</li>
</ol>
</li>
<li><p><code>_if</code><br>有些函数有另一个版本，即根据将函数应用于容器元素得到的结果来执行操作。它们的名字以 <code>_if</code> 结尾。</p>
<p>它们需要一个额外的谓词参数：<code>&lt;..., class Predicate, ...&gt;</code></p>
<p>同样，STL使用诸如 Generator 和 BinaryPredicate 等术语来表示需要模拟其他函数对象概念的参数。</p>
</li>
<li><p>string类</p>
<p>string类虽然不是STL的组成部分，但设计它时考虑到了STL。例如它包含：<code>begin(),end(),rbegin(),rend()</code></p>
<p>获得区间内容的排列组合：<code>next_permutation()</code> 算法将区间内容转换为下一种排列方式。对于字符串，排列按照字母递增的顺序进行。如果成功，返回true；如果区间已处于最后的序列中，则返回false。</p>
</li>
</ul>
<h1 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h1><p>vector、valarray、array。</p>
<p>它们是由不同的小组开发的，用于不同目的。</p>
<p>vector 模板类是一个容器类和算法系统的一部分，它支持面向容器的操作。</p>
<p>valarray 模板类是面向数值计算的，不是STL的一部分。</p>
<p>array 是为替代内置数组而设计的，她通过提供更好、更安全的接口，让数组更紧凑、效率更高。很多STL算法也能使用。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2018/12/07/C-C++/C++Collection/C++STL/">C++ STL</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">Skuaka</a></p>
        <p><span>Created:</span>2018-12-07, 20:51:15</p>
        <p><span>Updated:</span>2019-05-08, 12:23:01</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2018/12/07/C-C++/C++Collection/C++STL/" title="C++ STL">http://blog.skuaka.cn/2018/12/07/C-C++/C++Collection/C++STL/</a>
            <span class="copy-path" data-clipboard-text="From http://blog.skuaka.cn/2018/12/07/C-C++/C++Collection/C++STL/　　By Skuaka" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/12/15/Develop/Makefile学习/">
                    Makefile学习
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/12/07/Algorithm/Data Structure/查找树/">
                    查找树
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#标准模板库"><span class="toc-number">1.</span> <span class="toc-text">标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#杂项记录"><span class="toc-number">1.1.</span> <span class="toc-text">杂项记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocator"><span class="toc-number">1.1.1.</span> <span class="toc-text">Allocator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">1.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器类型"><span class="toc-number">1.2.1.</span> <span class="toc-text">迭代器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入迭代器"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">输入迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出迭代器"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">输出迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正向迭代器"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">正向迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向迭代器"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">双向迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#随机访问迭代器"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">随机访问迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将指针用作迭代器"><span class="toc-number">1.2.2.</span> <span class="toc-text">将指针用作迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器的输入输出适配器"><span class="toc-number">1.2.3.</span> <span class="toc-text">迭代器的输入输出适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向迭代器"><span class="toc-number">1.2.4.</span> <span class="toc-text">反向迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入迭代器"><span class="toc-number">1.2.5.</span> <span class="toc-text">插入迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#插入迭代器适配函数"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">插入迭代器适配函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器失效"><span class="toc-number">1.2.6.</span> <span class="toc-text">迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-number">1.3.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#所有容器"><span class="toc-number">1.3.1.</span> <span class="toc-text">所有容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通用方法"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">通用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列容器"><span class="toc-number">1.3.2.</span> <span class="toc-text">序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通用方法-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">通用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#emplace-c-11"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">emplace(c++11)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">forward_list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array"><span class="toc-number">1.3.2.9.</span> <span class="toc-text">array</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联容器"><span class="toc-number">1.3.3.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通用方法-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">通用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multi-set"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">(multi)set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multi-map"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">(multi)map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无序关联容器"><span class="toc-number">1.3.4.</span> <span class="toc-text">无序关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器内部实现"><span class="toc-number">1.3.5.</span> <span class="toc-text">容器内部实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数对象"><span class="toc-number">1.4.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数符概念"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数适配器概念"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数适配器概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预定义函数符-lt-functional-gt"><span class="toc-number">1.4.3.</span> <span class="toc-text">预定义函数符&lt;functional&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符和相应的函数符"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">运算符和相应的函数符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应函数符"><span class="toc-number">1.4.4.</span> <span class="toc-text">自适应函数符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数适配器"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">函数适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda表达式-C-11"><span class="toc-number">1.4.5.</span> <span class="toc-text">lambda表达式 C++11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-function"><span class="toc-number">1.4.6.</span> <span class="toc-text">std::function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">1.5.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他库"><span class="toc-number">2.</span> <span class="toc-text">其他库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">3.</span> <span class="toc-text">结束</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-5 i,
        .toc-level-5 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide" title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"C++ STL　| Skuaka　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/12/15/Develop/Makefile学习/" title="Pre: Makefile学习">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/12/07/Algorithm/Data Structure/查找树/" title="Next: 查找树">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/10/24/Linux/System/Linux安装中文/">Linux安装中文</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/16/Develop/Jenkins-node/">Jenkins-note</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/Develop/Github-config/">Github config</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/QT/Qt-with-CMake/">Qt-with-CMake</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/Develop/CMake-Note/">CMake-Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/QT/Qt-for-Macos/">Qt for Macos</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/QT/Qt-Note/">Qt Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/C-C++/Concept-gcc/gcc_cmake_gdb升级/">gcc_cmake_gdb升级</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/MacOS/mac维修记录/">mac维修记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Develop/CMake依赖图/">CMake依赖图</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/C-C++/Mess/va_list和vprintf/">va_list和vprintf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/16/Develop/hexo-note/">hexo-note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/13/Develop/开发工具问题集合/">开发工具问题集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/06/Linux/Command/yum-error/">yum error</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/Develop/kubectl-Cheat-Sheet/">kubectl-Cheat-Sheet</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Mess/Game/steamcmd/">steamcmd</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/22/Linux/Command/Linux文本处理笔记/">Linux文本处理笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/Develop/Robot-framework-note/">Robot framework note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/03/Linux/System/ppk-to-pem/">ppk_to_pem</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/02/Linux/Programming/Shell控制语句笔记/">Shell控制语句笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/02/Linux/Programming/Shell变量笔记/">Shell变量笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/27/Develop/docker笔记/">docker笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Develop/swagger搭建mock_server/">swagger搭建mock_server</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/22/Develop/travis/">travis笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/Linux/System/ssh证书改变后无法登入/">ssh证书改变后无法登入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/C-C++/C++Template/C++SFINAE/">C++SFINAE</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/Network/Vultr/vultr/">vultr</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/MacOS/macOS-command-line-tools/">macOS command line tools</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/26/Backend/Node-js/node-js笔记/">node-js笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/Linux/System/Linux操作系统笔记/">Linux操作系统笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/Algorithm/链表算法题笔记/">链表算法题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/29/Database/Concept/事务加锁协议/">事务加锁协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/24/Python/virtualenv/">virtualenv</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/Database/Mysql/mysql-dual表/">mysql-dual表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/Database/Mysql/mysql-EXPLAIN/">mysql-EXPLAIN</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/18/Linux/Command/grep减号/">shell double-dash(--)作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/Security/linux服务器入侵检测/">linux服务器入侵检测</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/27/Network/IO/libevent进阶/">libevent进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/Linux/Programming/守护进程的创建/">守护进程的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/C-C++/Concept-gcc/attribute-packed/">__attribute__</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/Linux/System/SIGINT-SIGTERM-SIGKILL区别/">SIGINT SIGTERM SIGKILL区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/Mess/趋势科技秋招面经/">趋势科技 Linux C++ 面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/QT/Qt-issues/">Qt issues</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/QT/qt隐藏标题栏并鼠标拖动/">qt隐藏标题栏并鼠标拖动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/Security/openssl/">openSSL</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/14/Algorithm/C++栈实现队列/">C++栈实现队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C-C++/C++Template/C++Compile-time-quicksort/">C++Compile-time-quicksort</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/Algorithm/Data Structure/Hash/">Hash</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C-C++/C++Collection/C++bitset/">C++bitset</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/C-C++/C++Template/C++可变参数模板/">C++可变参数模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/C-C++/Mess/C++多线程多路归并排序/">C++多线程多路归并排序函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/C-C++/Mess/new和malloc区别/">new和malloc区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/C-C++/Concept-gcc/C++命名规范/">C++命名规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/Network/Http/https与ssl/">https 与 ssl</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/Develop/Git笔记/">Git使用笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/27/Network/IO/libevent基础/">libevent基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/25/Operating-System/操作系统知识笔记/">操作系统知识笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/25/Database/Concept/数据库理论知识/">数据库理论知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/Operating-System/Linux虚拟地址空间/">Linux虚拟地址空间</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/C-C++/C++Collection/C++ref/">C++ref</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/Network/Tcp/ICMP/">ICMP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/">IP头_TCP头_UDP头</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/C-C++/C++Collection/C++线程池/">C++线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/C-C++/C++Collection/C++algorithm/">c++algorithm</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/Network/Unp/unp笔记/">《unp》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/Algorithm/逆元/">逆元</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/C-C++/C++Collection/C++线程库/">C++线程库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/C-C++/C++Collection/C++chrono时间库/">C++chrono时间库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/C-C++/C++Collection/C++右值引用和移动/">C++右值引用和移动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/Network/Http/http/">http</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/11/Algorithm/Data Structure/堆和优先队列/">堆和优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C-C++/C++Collection/C++string/">C++ string类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C-C++/C++Collection/C++强制类型转换/">C++强制类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/Operating-System/浮点数存储法/">浮点数存储法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C-C++/Mess/C_C++pow函数实现/">C_C++ pow函数实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C-C++/C++Collection/C++杂类/">C++杂类（持续更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C-C++/Mess/C++运算符优先级/">C运算符优先级</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C-C++/C++Collection/C++虚函数表/">C++虚函数表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C-C++/Mess/结构体offsetof宏/">结构体offsetof宏 和 bit位测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating-System/互斥锁-自旋锁-读写锁/">互斥锁 自旋锁 读写锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating-System/虚拟内存概念/">虚拟内存概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/C-C++/C++Collection/C++智能指针/">C++智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/Operating-System/C程序内存区域/">C程序内存区域</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/Algorithm/LIS-最长上升子序列/">LIS 最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/Algorithm/LCS-最长公共子序列/">LCS (最长公共子序列)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/C-C++/C++Collection/C++Lambda表达式/">C++ Lambda表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/QT/QT-贪吃蛇/">QT 贪吃蛇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/QT/PaintEvent/">QT PaintEvent</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/C-C++/Mess/C语言杂记/">C语言杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/QT/窗口视口/">窗口视口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/Network/Tcp/TCP半关闭,半连接,半打开/">TCP 半关闭,半连接,半打开</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/Network/Tcp/Tcp如何保证可靠/">Tcp_ip协议栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/05/Linux/Command/系统资源check/">System resource usage check</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Linux/Command/tar/">Tar命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Linux/Command/ln/">ln</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Linux/Command/screen/">使用 screen 管理远程会话</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒联机控制台/">饥荒联机控制台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒Linux服务器/">饥荒Linux服务器搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/Linux/Command/输出重定向/">Linux 输出重定向</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/26/C-C++/C++Template/C++编译期备忘录/">C++ 编译期备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C-C++/C++Template/C++typename/">C++ typename 用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C-C++/C++Template/C++模板元编程书上习题/">C++模板元编程书上习题（待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/C-C++/C++Template/C++模板元编程/">C++模板元编程(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C-C++/C++Collection/C++基础笔记/">C++ 基础笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C-C++/Mess/C++和Java的引用/">C++和Java的引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Network/IO/Reactor/">高性能IO之Reactor模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Database/Redis/Redis设计与实现/">Redis 设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/Database/Redis/Mac-Redis-Usage/">Mac-Redis-Usage</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/10/Operating-System/操作系统期末背诵点/">操作系统期末背诵点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/05/QT/QT入门/">QT 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/QT/QString/">QString与char*的相互转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/28/Algorithm/排序算法/">排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/Network/Tcp/TCP网络拥塞控制/">TCP网络拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/Develop/Makefile学习/">Makefile学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/C-C++/C++Collection/C++STL/">C++ STL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/Algorithm/Data Structure/查找树/">查找树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/Database/SQLserver/远程登入sqlserver/">远程登入 SQL server</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mysql-c-api/">mysql-c-api</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mac下安装与配置mysql/">mac下安装与配置mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C-C++/Mess/C++显式实例化的用途/">C++显式实例化的用途</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C-C++/Mess/C++ofstream输出为1的情况/">fstream输出为1的情况</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Backend/Mess/Dreamweaver服务器配置/">Dreamweaver 连接到 Linux 云服务器 php</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/MacOS/Mac杂项/">Mac杂项</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Mess/Raspberrypi/树莓派安装kali/">树莓派安装kali</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/30/Perl/Perl入门/">Perl 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/29/Linux/Command/vim备忘录/">vim备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/C-C++/Concept-gcc/标准IO的三类缓冲/">标准IO的三类缓冲</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/C-C++/Mess/C++杂记/">C++杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Network/Wireshark/Wireshark入门/">Wireshark 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Linux/Command/Linux小命令/">Linux 小命令记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/C-C++/Mess/C++类与结构区别/">C++中结构体和类的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Security/DDos/DDos攻击详解/">DDos 攻击详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Network/Wireshark/qq好友IP定位/">qq好友IP定位</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Backend/Mess/apache删除后Nginx显示Apache界面/">apache删除后使用Nginx服务仍然显示Apache界面</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/Network/IO/epoll/">epoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/Linux/Command/sed/">sed 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/12/Linux/Command/awk/">awk 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Linux/Command/nmap/">nmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Linux/System/使用过的端口/">使用过的端口(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/MacOS/frozen-app-store/">Frozen App Store</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/MacOS/mac显示隐藏文件/">macos 显示隐藏文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Mess/win逆向工程(弃)/">win逆向工程（放弃）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/Mess/计算机专业名词/">计算机专业名词记录(放弃更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/C-C++/Concept-gcc/不可重入函数/">不可重入函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/Linux/System/Linux日志文件分析/">Linux 日志文件分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Linux/Programming/解释器文件/">解释器文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Python/Python杂记/">Python 杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/Database/SQLserver/mssql实验(放弃更新)/">mssql实验(放弃更新)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql-基本命令/">mysql-基本命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql-大小写区分/">mysql-大小写区分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Develop/CMake入门/">CMake入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Linux/System/Linux备忘录/">Linux备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/Network/Unp/unp_code/">《unp》源代码问题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/Database/PostgreSQL/C++ connector for PostgreSQL/">C++ connector for PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/PostgreSQL 命令/">PostgreSQL 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/Mac 下 PostgreSQL /">Mac 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/Database/Mysql/mysql-创建时间和更新时间/">mysql-创建时间和更新时间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Database/PostgreSQL/Linux 下 PostgreSQL/">Linux 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Backend/php入门/">php入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Frontend/DTD入门/">DTD入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Mess/File structure/mp3文件格式/">mp3文件格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/BGP 补充知识/">CCIE BGP 补充知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS/">CCIE IS-IS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS协议/">CCIE IS-IS协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/DM-VPN/">CCIE DM-VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IPSEC VPN/">CCIE IPSEC VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS/">CCIE MPLS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/NAT 地址转换协议/">CCIE NAT 地址转换协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS VPN/">CCIE MPLS VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/acl控制/">CCIE acl控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/bgp/">CCIE bgp</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/STP生成树协议/">CCIE STP生成树协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/ipv6/">CCIE ipv6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/交换机基础/">CCIE 交换机基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/网络知识总结/">CCIE 网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/多播/">CCIE 多播（multicast）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/跨域的多播/">CCIE 跨域的多播</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/逻辑子接口/">CCIE 逻辑子接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/路由协议分类/">CCIE 路由协议分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/重分发 /">CCIE 重分发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/防火墙/">CCIE 防火墙</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/C-C++/Concept-gcc/gcc_gdb备忘录/">gcc_gdb备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/Frontend/Javascript入门/">Javascript 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Frontend/XML入门/">XML入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Database/Mysql/mysql-用户操作/">mysql-用户操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/Database/Mysql/Mess/centos彻底删除mysql/">centos彻底删除mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/Security/无线安全/Dsniff/">Dsniff</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/Backend/base64原理/">Base64原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/Security/无线安全/reaver/">reaver</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/wireshark fatal IO error 2/">kali vnc wireshark fatal IO error 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/Aircrack-ng/">Aircrack-ng</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/C-C++/C++Collection/C++11-new-feature/">C++11-new-feature</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/HTMLl5+CSS3入门/">HTML5+CSS3入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/Html入门/">Html入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/CSS入门/">CSS入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/25/Algorithm/DFS/">DFS BFS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/Python/懒得整理的python学习笔记/">懒得整理的python学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/Linux/Programming/Shell入门杂记/">Shell入门杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/Mess/Markdown/">Markdown标记语言</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2022 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>